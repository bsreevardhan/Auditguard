import subprocess
import pandas as pd
import datetime
import os 

cis_index = ['3.1.1', '3.1.2', '3.1.3', '3.2.1', '3.2.2', '1.1.1.1', '1.1.1.2', '3.3.1', '1.1.2.1', '1.1.2.2', '3.3.2', '1.1.2.3', '1.1.2.4', '1.1.3.1', '1.1.3.2', '1.1.3.3', '1.1.4.1', '1.1.4.2', '1.1.4.3', '1.1.4.4', '1.1.5.1', '1.1.5.2', '1.1.5.3', '1.1.5.4', '1.1.6.1', '1.1.6.2', '1.1.6.3', '1.1.6.4', '1.1.7.1', '1.1.7.2', '1.1.7.3', '1.1.8.1', '1.1.8.2', '1.1.8.3', '1.1.8.4', '1.1.9', '1.2.1', '1.2.2', '1.2.3', '1.2.4', '1.3.1', '1.3.2', '1.3.3', '1.4.1', '1.4.2', '1.5.1', '1.5.2', '1.5.3', '1.6.1.1', '1.6.1.2', '1.6.1.3', '1.6.1.4', '1.6.1.5', '1.6.1.6', '1.6.1.7', '1.6.1.8', '3.3.3', '3.3.4', '3.3.5', '3.3.6', '3.3.7', '3.3.8', '3.3.9', '3.4.1.1', '3.4.1.2', '3.4.2.1', '3.4.2.2', '1.7.1', '1.7.2', '1.7.3', '1.7.4', '1.7.5', '1.7.6', '1.8.1', '1.8.2', '1.8.3', '1.8.4', '1.8.5', '1.8.6', '1.8.7', '1.8.8', '1.8.9', '1.8.10', '1.10', '6.1.1', '6.1.2', '6.1.3', '6.1.4', '6.1.5', '6.1.6', '6.1.7', '6.1.8', '6.1.9 ', '6.1.10', '6.1.11', '6.1.12', '6.1.13', '6.1.14', '6.1.15', '6.2.1', '6.2.2', '6.2.3', '6.2.4', '6.2.5', '6.2.6', '6.2.7', '6.2.8', '6.2.9', '6.2.10', '6.2.11', '6.2.12', '6.2.13', '6.2.14', '6.2.15', '6.2.16', '5.1.1', '5.1.2', '5.1.3', '5.1.4', '5.1.5', '5.1.6', '5.1.7', '5.1.8', '5.1.9', '5.2.1', '5.2.2', '5.2.3', '5.2.4', '5.2.5', '5.2.6', '5.2.7', '5.2.8', '5.2.9', '5.2.10', '5.2.11', '5.2.12', '5.2.13', '5.2.14', '5.2.15', '5.2.16', '5.2.17', '5.2.18', '5.2.19', '5.2.20', '5.3.1', '5.3.2', '5.3.3', '5.3.4', '5.3.5', '5.3.6', '5.3.7', '5.4.1', '5.4.2', '5.5.1', '5.5.2', '5.5.3', '5.5.4', '5.6.1.1', '5.6.1.2', '5.6.1.3', '5.6.1.4', '5.6.1.5', '5.6.2', '5.6.3', '5.6.4', '5.6.5', '5.6.6', '2.1.1', '2.1.2', '2.2.1', '2.2.2', '2.2.3', '2.2.4', '2.2.5', '2.2.6', '2.2.7', '2.2.8', '2.2.9', '2.2.10', '2.2.11', '2.2.12', '2.2.13', '2.2.14', '2.2.15', '2.2.16', '2.2.17', '2.2.18', '2.3.1', '2.3.2', '2.3.3', '2.3.4', '2.4', '4.1.1.2', '4.1.1.3', '4.1.1.4', '4.1.2.1', '4.1.2.2', '4.1.2.3', '4.1.3.1', '4.1.3.2', '4.1.3.3', '4.1.3.4', '4.1.3.5', '4.1.3.6', '3.4.2.3', '3.4.2.3', '3.4.2.4', '3.4.2.5', '3.4.2.6', '3.4.2.7', '4.2.1.1', '4.2.1.2', '4.2.1.3', '4.2.1.4', '4.2.1.5', '4.2.1.6', '4.2.1.7', '4.2.2.1.1', '4.2.2.1.2', '4.2.2.1.3', '4.2.2.1.4', '4.2.2.2', '4.2.2.3', '4.2.2.4', '4.2.2.5', '4.2.2.6', '4.2.2.7', '4.1.3.7', '4.1.3.8', '4.1.3.9', '4.1.3.10', '4.1.3.11', '4.1.3.12', '4.1.3.13', '4.1.3.14', '4.1.3.15', '4.1.3.16', '4.1.3.17', '4.1.3.18', '4.1.3.19', '4.1.3.20', '4.1.3.21', '4.1.4.1', '4.1.4.2', '4.1.4.3', '4.1.4.4', '4.1.4.5', '4.1.4.6', '4.1.4.7', '4.1.4.8', '4.1.4.9', '4.1.4.10']
title = ['Ensure IPv6 status is identified', 'Ensure wireless interfaces are disabled', ' Ensure TIPC is disabled', 'Ensure IP forwarding is disabled', 'Ensure packet redirect sending is disabled', 'Ensure mounting of squashfs filesystems is disabled', 'Ensure mounting of udf filesystems is disabled', 'Ensure source routed packets are not accepted', 'Ensure /tmp is a separate partition', 'Ensure nodev option set on /tmp partition', 'Ensure ICMP redirects are not accepted', 'Ensure noexec option set on /tmp partition', 'Ensure nosuid option set on /tmp partition', 'Ensure separate partition exists for /var', 'Ensure nodev option set on /var partition', 'Ensure nosuid option set on /var partition', 'Ensure separate partition exists for /var/tmp', 'Ensure noexec option set on /var/tmp partition', 'Ensure nosuid option set on /var/tmp partition', 'Ensure nodev option set on /var/tmp partition', 'Ensure separate partition exists for /var/log', 'Ensure nodev option set on /var/log partition', 'Ensure noexec option set on /var/log partition', 'Ensure nosuid option set on /var/log partition', 'Ensure separate partition exists for /var/log/audit', 'Ensure noexec option set on /var/log/audit partition', 'Ensure nodev option set on /var/log/audit partition', 'Ensure nosuid option set on /var/log/audit partition', 'Ensure separate partition exists for /home', 'Ensure nodev option set on /home partition', 'Ensure nosuid option set on /home partition', 'Ensure /dev/shm is a separate partition', 'Ensure nodev option set on /dev/shm partition', 'Ensure noexec option set on /dev/shm partition', 'Ensure nosuid option set on /dev/shm partition', 'Disable USB Storage', 'Ensure GPG keys are configured', 'Ensure gpgcheck is globally activated', 'Ensure package manager repositories are configured', 'Ensure repo_gpgcheck is globally activated', 'Ensure AIDE is installed', 'Ensure filesystem integrity is regularly checked', 'Ensure cryptographic mechanisms are used to protect the integrity of audit tools', 'Ensure bootloader password is set', 'Ensure permissions on bootloader config are configured', ' Ensure core dump storage is disabled', 'Ensure core dump backtraces are disabled', 'Ensure address space layout randomization (ASLR) is enabled', 'Ensure SELinux is installed', 'Ensure SELinux is not disabled in bootloader configuration', 'Ensure SELinux policy is configured', 'Ensure the SELinux mode is not disabled', 'Ensure the SELinux mode is enforcing', 'Ensure no unconfined services exist', 'Ensure SETroubleshoot is not installed', 'Ensure the MCS Translation Service (mcstrans) is not installed', 'Ensure secure ICMP redirects are not accepted', 'Ensure suspicious packets are logged', 'Ensure broadcast ICMP requests are ignored', 'Ensure bogus ICMP responses are ignored', 'Ensure Reverse Path Filtering is enabled', 'Ensure TCP SYN Cookies is enabled', 'Ensure IPv6 router advertisements are not accepted', 'Ensure nftables is installed', 'Ensure a single firewall configuration utility is in use', 'Ensure firewalld default zone is set', 'Ensure at least one nftables table exists', 'Ensure message of the day is configured properly', 'Ensure local login warning banner is configured properly', 'Ensure remote login warning banner is configured properly', 'Ensure permissions on /etc/motd are configured', 'Ensure permissions on /etc/issue are configured', 'Ensure permissions on /etc/issue.net are configured', 'Ensure GNOME Display Manager is removed', 'Ensure GDM login banner is configured', 'Ensure GDM disable-user-list option is enabled', 'Ensure GDM screen locks when the user is idle', 'Ensure GDM screen locks cannot be overridden', 'Ensure GDM automatic mounting of removable media is disabled', 'Ensure GDM disabling automatic mounting of removable media is not overridden', 'Ensure GDM autorun-never is enabled', 'Ensure GDM autorun-never is not overridden', 'Ensure XDCMP is not enabled', ' Ensure system-wide crypto policy is not legacy', 'Ensure permissions on /etc/passwd are configured', 'Ensure permissions on /etc/passwd- are configured', 'Ensure permissions on /etc/group are configured', 'Ensure permissions on /etc/group- are configured', 'Ensure permissions on /etc/shadow are configured', 'Ensure permissions on /etc/shadow- are configured', 'Ensure permissions on /etc/gshadow are configured', 'Ensure permissions on /etc/gshadow- are configured', 'Ensure no world writable files exist', 'Ensure no unowned files or directories exist', 'Ensure no ungrouped files or directories exist', 'Ensure sticky bit is set on all world-writable directories', 'Audit SUID executables', 'Audit SGID executables', 'Audit system file permissions', 'Ensure accounts in /etc/passwd use shadowed passwords', 'Ensure /etc/shadow password fields are not empty', 'Ensure all groups in /etc/passwd exist in /etc/group', 'Ensure no duplicate UIDs exist', 'Ensure no duplicate GIDs exist', 'Ensure no duplicate user names exist', 'Ensure no duplicate group names exist', 'Ensure root PATH Integrity', 'Ensure root is the only UID 0 account', 'Ensure local interactive user home directories exist', 'Ensure local interactive users own their home directories', 'Ensure local interactive user home directories are mode 750 or more restrictive', 'Ensure no local interactive user has .netrc files', 'Ensure no local interactive user has .forward files', 'Ensure no local interactive user has .rhosts files', 'Ensure local interactive user dot files are not group or world writable', 'Ensure cron daemon is enabled', 'Ensure permissions on /etc/crontab are configured', 'Ensure permissions on /etc/cron.hourly are configured', 'Ensure permissions on /etc/cron.daily are configured', 'Ensure permissions on /etc/cron.weekly are configured', 'Ensure permissions on /etc/cron.monthly are configured', 'Ensure permissions on /etc/cron.d are configured', 'Ensure cron is restricted to authorized users', 'Ensure at is restricted to authorized users', 'Ensure permissions on /etc/ssh/sshd_config are configured', 'Ensure permissions on SSH private host key files are configured', 'Ensure permissions on SSH public host key files are configured', 'Ensure SSH access is limited', 'Ensure SSH LogLevel is appropriate', 'Ensure SSH PAM is enabled', 'Ensure SSH root login is disabled', 'Ensure SSH HostbasedAuthentication is disabled', 'Ensure SSH PermitEmptyPasswords is disabled', 'Ensure SSH PermitUserEnvironment is disabled', 'Ensure SSH IgnoreRhosts is enabled', 'Ensure SSH X11 forwarding is disabled', 'Ensure SSH AllowTcpForwarding is disabled', 'Ensure system-wide crypto policy is not over-ridden', 'Ensure SSH warning banner is configured', 'Ensure SSH MaxAuthTries is set to 4 or less', 'Ensure SSH MaxStartups is configured', 'Ensure SSH MaxSessions is set to 10 or less', 'Ensure SSH LoginGraceTime is set to one minute or less', 'Ensure SSH Idle Timeout Interval is configured', 'Ensure sudo is installed', 'Ensure sudo commands use pty', 'Ensure sudo log file exists', 'Ensure users must provide password for escalation', 'Ensure re-authentication for privilege escalation is not disabled globally', 'Ensure sudo authentication timeout is configured correctly', 'Ensure access to the su command is restricted', 'Ensure custom authselect profile is used', 'Ensure authselect includes with-faillock', 'Ensure password creation requirements are configured', 'Ensure lockout for failed password attempts is configured', ' Ensure password reuse is limited', 'Ensure password hashing algorithm is SHA-512 or yescrypt', 'Ensure password expiration is 365 days or less', 'Ensure minimum days between password changes is configured', 'Ensure password expiration warning days is 7 or more', 'Ensure inactive password lock is 30 days or less', ' Ensure all users last password change date is in the past', 'Ensure system accounts are secured', 'Ensure default user shell timeout is 900 seconds or less', 'Ensure default group for the root account is GID 0', 'Ensure default user umask is 027 or more restrictive', 'Ensure root password is set', 'Ensure time synchronization is in use', 'Ensure chrony is configured', 'Ensure xorg-x11-server-common is not installed', 'Ensure Avahi Server is not installed', 'Ensure CUPS is not installed', 'Ensure DHCP Server is not installed', 'Ensure DNS Server is not installed', 'Ensure VSFTP Server is not installed', 'Ensure TFTP Server is not installed', 'Ensure a web server is not installed', 'Ensure IMAP and POP3 server is not installed', 'Ensure Samba is not installed', 'Ensure HTTP Proxy Server is not installed', 'Ensure net-snmp is not installed', ' Ensure telnet-server is not installed', 'Ensure dnsmasq is not installed', 'Ensure mail transfer agent is configured for local-only mode', 'Ensure nfs-utils is not installed or the nfs-server service is masked', 'Ensure rpcbind is not installed or the rpcbind services are masked', 'Ensure rsync-daemon is not installed or the rsyncd service is masked', 'Ensure telnet client is not installed', 'Ensure LDAP client is not installed', 'Ensure TFTP client is not installed', 'Ensure FTP client is not installed', 'Ensure nonessential services listening on the system are removed or masked', 'Ensure auditing for processes that start prior to auditd is enabled', 'Ensure audit_backlog_limit is sufficient', 'Ensure auditd service is enabled', 'Ensure audit log storage size is configured', 'Ensure audit logs are not automatically deleted', 'Ensure system is disabled when audit logs are full', 'Ensure changes to system administration scope (sudoers) is collected', 'Ensure actions as another user are always logged', 'Ensure events that modify the sudo log file are collected', 'Ensure events that modify date and time information are collected', "Ensure events that modify the system's network environment are collected", 'Ensure use of privileged commands are collected', 'Ensure nftables base chains exist', 'Ensure nftables base chains exist', 'Ensure host based firewall loopback traffic is configured', 'Ensure firewalld drops unnecessary services and ports', 'Ensure nftables established connections are configured', 'Ensure nftables default deny firewall policy', 'Ensure rsyslog is installed', 'Ensure rsyslog service is enabled', 'Ensure journald is configured to send logs to rsyslog', 'Ensure rsyslog default file permissions are configured', 'Ensure logging is configured', 'Ensure rsyslog is configured to send logs to a remote log host', 'Ensure rsyslog is not configured to receive logs from a remote client', 'Ensure systemd-journal-remote is installed', 'Ensure systemd-journal-remote is configured', 'Ensure systemd-journal-remote is enabled', 'Ensure journald is not configured to receive logs from a remote client', 'Ensure journald service is enabled', 'Ensure journald is configured to compress large log files', 'Ensure journald is configured to write logfiles to persistent disk', 'Ensure journald is not configured to send logs to rsyslog', 'Ensure journald log rotation is configured per site policy', 'Ensure journald default file permissions configured', 'Ensure unsuccessful file access attempts are collected', 'Ensure events that modify user/group information are collected', 'Ensure discretionary access control permission modification events are collected', 'Ensure successful file system mounts are collected', 'Ensure session initiation information is collected', 'Ensure login and logout events are collected', 'Ensure file deletion events by users are collected', "Ensure events that modify the system's Mandatory Access Controls are collected", 'Ensure successful and unsuccessful attempts to use the chcon command are recorded', 'Ensure successful and unsuccessful attempts to use the setfacl command are recorded', 'Ensure successful and unsuccessful attempts to use the chacl command are recorded', 'Ensure successful and unsuccessful attempts to use the usermod command are recorded', 'Ensure kernel module loading unloading and modification is collected', 'Ensure the audit configuration is immutable', 'Ensure the running and on disk configuration is the same', 'Ensure audit log files are mode 0640 or less permissive', 'Ensure only authorized users own audit log files', 'Ensure only authorized groups are assigned ownership of audit log files', 'Ensure the audit log directory is 0750 or more restrictive', 'Ensure audit configuration files are 640 or more restrictive', 'Ensure audit configuration files are owned by root', 'Ensure audit configuration files belong to group root', 'Ensure audit tools are 755 or more restrictive', 'Ensure audit tools are owned by root', 'Ensure audit tools belong to group root']
code = ['#!/bin/bash\n\n# Check if IPv6 is enabled\nipv6_status=$(sysctl net.ipv6.conf.all.disable_ipv6)\n\nif [[ "$ipv6_status" == "net.ipv6.conf.all.disable_ipv6 = 0" ]]; then\n    echo "Check: Ensure IPv6 status is identified"\n    echo "Status: Pass"\n    echo "Current Value: IPv6 is enabled"\n    echo "Recommendation: No action needed."\nelse\n    echo "Check: Ensure IPv6 status is identified"\n    echo "Status: Fail"\n    echo "Current Value: IPv6 is disabled"\n    echo "Recommendation: If IPv6 is required, enable it."\n    echo "Remediation Steps:"\n    echo "1. To enable IPv6, run the following command:"\n    echo "   sudo sysctl -w net.ipv6.conf.all.disable_ipv6=0"\n    echo "2. To make this change persistent, edit /etc/sysctl.conf and add the following line:"\n    echo "   net.ipv6.conf.all.disable_ipv6 = 0"\n    echo "3. Run \'sudo sysctl -p\' to apply the changes."\nfi', '#!/bin/bash\n\n# List of wireless interfaces to check\nwireless_interfaces=$(iw dev 2>/dev/null)\n\nif [[ -n "$wireless_interfaces" ]]; then\n    echo "Check: Ensure wireless interfaces are disabled"\n    echo "Status: Fail"\n    echo "Current Value: Wireless interfaces are enabled"\n    echo "Recommendation: Disable wireless interfaces."\n    echo "Remediation Steps:"\n    echo "1. To disable wireless interfaces, run the following command:"\n    echo "   sudo ifconfig wlan0 down"\n    echo "2. To prevent wireless interfaces from being enabled on boot, disable the service (if applicable):"\n    echo "   sudo systemctl stop NetworkManager"\n    echo "   sudo systemctl disable NetworkManager"\nelse\n    echo "Check: Ensure wireless interfaces are disabled"\n    echo "Status: Pass"\n    echo "Current Value: No wireless interfaces found"\n    echo "Recommendation: No action needed."\nfi', '#!/bin/bash\n\n# Check if TIPC is loaded\ntipc_status=$(lsmod | grep tipc)\n\nif [[ -n "$tipc_status" ]]; then\n    echo "Check: Ensure TIPC is disabled"\n    echo "Status: Fail"\n    echo "Current Value: TIPC is loaded"\n    echo "Recommendation: Disable TIPC."\n    echo "Remediation Steps:"\n    echo "1. To disable TIPC, run the following command:"\n    echo "   sudo modprobe -r tipc"\n    echo "2. To prevent TIPC from loading at boot, add it to blacklist:"\n    echo "   echo \'blacklist tipc\' | sudo tee -a /etc/modprobe.d/blacklist.conf"\n    echo "3. Run the following command to apply the changes:"\n    echo "   sudo update-initramfs -u"\nelse\n    echo "Check: Ensure TIPC is disabled"\n    echo "Status: Pass"\n    echo "Current Value: TIPC is not loaded"\n    echo "Recommendation: No action needed."\nfi', '#!/bin/bash\n\n# Check if IP forwarding is disabled\nip_forwarding=$(sysctl net.ipv4.ip_forward)\n\nif [[ "$ip_forwarding" == "net.ipv4.ip_forward = 0" ]]; then\n    echo "Check: Ensure IP forwarding is disabled"\n    echo "Status: Pass"\n    echo "Current Value: IP forwarding is disabled"\n    echo "Recommendation: No action needed."\nelse\n    echo "Check: Ensure IP forwarding is disabled"\n    echo "Status: Fail"\n    echo "Current Value: IP forwarding is enabled"\n    echo "Recommendation: Disable IP forwarding."\n    echo "Remediation Steps:"\n    echo "1. To disable IP forwarding, run the following command:"\n    echo "   sudo sysctl -w net.ipv4.ip_forward=0"\n    echo "2. To make this change persistent, edit /etc/sysctl.conf and add the following line:"\n    echo "   net.ipv4.ip_forward = 0"\n    echo "3. Run \'sudo sysctl -p\' to apply the changes."\nfi', '#!/bin/bash\n\n# Check if packet redirect sending is disabled\nredirect_send=$(sysctl net.ipv4.conf.all.accept_redirects)\n\nif [[ "$redirect_send" == "net.ipv4.conf.all.accept_redirects = 0" ]]; then\n    echo "Check: Ensure packet redirect sending is disabled"\n    echo "Status: Pass"\n    echo "Current Value: Packet redirect sending is disabled"\n    echo "Recommendation: No action needed."\nelse\n    echo "Check: Ensure packet redirect sending is disabled"\n    echo "Status: Fail"\n    echo "Current Value: Packet redirect sending is enabled"\n    echo "Recommendation: Disable packet redirect sending."\n    echo "Remediation Steps:"\n    echo "1. To disable packet redirect sending, run the following command:"\n    echo "   sudo sysctl -w net.ipv4.conf.all.accept_redirects=0"\n    echo "2. To make this change persistent, edit /etc/sysctl.conf and add the following line:"\n    echo "   net.ipv4.conf.all.accept_redirects = 0"\n    echo "3. Run \'sudo sysctl -p\' to apply the changes."\nfi', '#!/bin/bash\n\n# Function to check if mounting of squashfs filesystems is disabled\ncheck_squashfs() {\n    local squashfs_conf="/etc/modprobe.d/squashfs.conf"\n    local expected_line="install squashfs /bin/true"\n\n    # Check if squashfs is disabled in modprobe configuration\n    if grep -Fxq "$expected_line" "$squashfs_conf" 2>/dev/null; then\n        echo "Check: Ensure mounting of squashfs filesystems is disabled"\n        echo "Status: Pass"\n        echo "Current Value: Mounting of squashfs filesystems is disabled."\n        echo "Expected Value: Mounting of squashfs filesystems should be disabled."\n        echo "Recommendation: No action needed."\n    else\n        echo "Check: Ensure mounting of squashfs filesystems is disabled"\n        echo "Status: Fail"\n        echo "Current Value: Mounting of squashfs filesystems is not disabled."\n        echo "Expected Value: Mounting of squashfs filesystems should be disabled."\n        echo "Recommendation: Disable the ability to mount squashfs filesystems."\n        echo "Remediation Steps:"\n        echo "1. Create or update the $squashfs_conf file with the following line:"\n        echo "   $expected_line"\n        echo "2. Remove the squashfs module from the system if already loaded:"\n        echo "   # rmmod squashfs"\n    fi\n}\n\n# Execute the check\ncheck_squashfs', '#!/bin/bash\n\n# Check if mounting of udf filesystems is disabled\ncheck_udf() {\nudf_disabled=$(grep -E "^\\\\s*install\\\\s+udf\\\\s+/bin/true" /etc/modprobe.d/*.conf 2>/dev/null)\n\nif [[ -n "$udf_disabled" ]]; then\necho "Check: Ensure mounting of udf filesystems is disabled"\necho "Status: Pass"\necho "Current Value: Mounting of udf filesystems is disabled."\necho "Expected Value: Mounting of udf filesystems should be disabled."\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure mounting of udf filesystems is disabled"\necho "Status: Fail"\necho "Current Value: Mounting of udf filesystems is not disabled."\necho "Expected Value: Mounting of udf filesystems should be disabled."\necho "Recommendation: Ensure udf filesystems cannot be mounted."\necho "Remediation Steps:"\necho "1. Create or update the /etc/modprobe.d/udf.conf file with the following line:"\necho "   install udf /bin/true"\necho "2. Remove udf module from the system if already loaded:"\necho "   # rmmod udf"\nfi\n}\n\n# Execute check\ncheck_udf\n', '#!/bin/bash  # Check if source routed packets are accepted source_routed=$(sysctl net.ipv4.conf.all.accept_source_route)  if [[ "$source_routed" == "net.ipv4.conf.all.accept_source_route = 0" ]]; then     echo "Check: Ensure source routed packets are not accepted"     echo "Status: Pass"     echo "Current Value: Source routed packets are not accepted"     echo "Recommendation: No action needed." else     echo "Check: Ensure source routed packets are not accepted"     echo "Status: Fail"     echo "Current Value: Source routed packets are accepted"     echo "Recommendation: Disable source routed packet acceptance."     echo "Remediation Steps:"     echo "1. To disable source routed packets acceptance, run the following command:"     echo "   sudo sysctl -w net.ipv4.conf.all.accept_source_route=0"     echo "2. To make this change persistent, edit /etc/sysctl.conf and add the following line:"     echo "   net.ipv4.conf.all.accept_source_route = 0"     echo "3. Run \'sudo sysctl -p\' to apply the changes." fi', '#!/bin/bash\n\n# Check if /tmp is a separate partition\ncheck_tmp_partition() {\ntmp_partition=$(grep -E "\\\\s+/tmp\\\\s+" /etc/fstab)\n\nif [[ -n "$tmp_partition" ]]; then\necho "Check: Ensure /tmp is a separate partition"\necho "Status: Pass"\necho "Current Value: /tmp is a separate partition."\necho "Expected Value: /tmp should be a separate partition."\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure /tmp is a separate partition"\necho "Status: Fail"\necho "Current Value: /tmp is not a separate partition."\necho "Expected Value: /tmp should be a separate partition."\necho "Recommendation: Create a separate partition for /tmp."\necho "Remediation Steps:"\necho "1. Update /etc/fstab to include a separate partition for /tmp."\necho "2. Remount the /tmp partition if necessary."\nfi\n}\n\n# Execute check\ncheck_tmp_partition\n', '#!/bin/bash\n\n# Check if nodev option is set on /tmp partition\ncheck_tmp_nodev() {\ntmp_nodev=$(grep -E "\\\\s+/tmp\\\\s+" /etc/fstab | grep -E "nodev")\n\nif [[ -n "$tmp_nodev" ]]; then\necho "Check: Ensure nodev option set on /tmp partition"\necho "Status: Pass"\necho "Current Value: nodev option is set on /tmp."\necho "Expected Value: nodev option should be set on /tmp."\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure nodev option set on /tmp partition"\necho "Status: Fail"\necho "Current Value: nodev option is not set on /tmp."\necho "Expected Value: nodev option should be set on /tmp."\necho "Recommendation: Set nodev option on /tmp."\necho "Remediation Steps:"\necho "1. Edit /etc/fstab to include \\\'nodev\\\' option for /tmp."\necho "2. Remount the /tmp partition if necessary."\nfi\n}\n\n# Execute check\ncheck_tmp_nodev\n', '#!/bin/bash  # Check if ICMP redirects are accepted icmp_redirects=$(sysctl net.ipv4.conf.all.accept_redirects)  if [[ "$icmp_redirects" == "net.ipv4.conf.all.accept_redirects = 0" ]]; then     echo "Check: Ensure ICMP redirects are not accepted"     echo "Status: Pass"     echo "Current Value: ICMP redirects are not accepted"     echo "Recommendation: No action needed." else     echo "Check: Ensure ICMP redirects are not accepted"     echo "Status: Fail"     echo "Current Value: ICMP redirects are accepted"     echo "Recommendation: Disable ICMP redirects acceptance."     echo "Remediation Steps:"     echo "1. To disable ICMP redirects acceptance, run the following command:"     echo "   sudo sysctl -w net.ipv4.conf.all.accept_redirects=0"     echo "2. To make this change persistent, edit /etc/sysctl.conf and add the following line:"     echo "   net.ipv4.conf.all.accept_redirects = 0"     echo "3. Run \'sudo sysctl -p\' to apply the changes." fi', '#!/bin/bash\n\n# Check if noexec option is set on /tmp partition\ncheck_tmp_noexec() {\ntmp_noexec=$(grep -E "\\\\s+/tmp\\\\s+" /etc/fstab | grep -E "noexec")\n\nif [[ -n "$tmp_noexec" ]]; then\necho "Check: Ensure noexec option set on /tmp partition"\necho "Status: Pass"\necho "Current Value: noexec option is set on /tmp."\necho "Expected Value: noexec option should be set on /tmp."\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure noexec option set on /tmp partition"\necho "Status: Fail"\necho "Current Value: noexec option is not set on /tmp."\necho "Expected Value: noexec option should be set on /tmp."\necho "Recommendation: Set noexec option on /tmp."\necho "Remediation Steps:"\necho "1. Edit /etc/fstab to include \\\'noexec\\\' option for /tmp."\necho "2. Remount the /tmp partition if necessary."\nfi\n}\n\n# Execute check\ncheck_tmp_noexec\n', '#!/bin/bash\n\n# Check if nosuid option is set on /tmp partition\ncheck_tmp_nosuid() {\ntmp_nosuid=$(grep -E "\\\\s+/tmp\\\\s+" /etc/fstab | grep -E "nosuid")\n\nif [[ -n "$tmp_nosuid" ]]; then\necho "Check: Ensure nosuid option set on /tmp partition"\necho "Status: Pass"\necho "Current Value: nosuid option is set on /tmp."\necho "Expected Value: nosuid option should be set on /tmp."\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure nosuid option set on /tmp partition"\necho "Status: Fail"\necho "Current Value: nosuid option is not set on /tmp."\necho "Expected Value: nosuid option should be set on /tmp."\necho "Recommendation: Set nosuid option on /tmp."\necho "Remediation Steps:"\necho "1. Edit /etc/fstab to include \\\'nosuid\\\' option for /tmp."\necho "2. Remount the /tmp partition if necessary."\nfi\n}\n\n# Execute check\ncheck_tmp_nosuid\n', '#!/bin/bash\n\n# Check if /var is a separate partition\ncheck_var_partition() {\nvar_partition=$(grep -E "\\\\s+/var\\\\s+" /etc/fstab)\n\nif [[ -n "$var_partition" ]]; then\necho "Check: Ensure separate partition exists for /var"\necho "Status: Pass"\necho "Current Value: /var is a separate partition."\necho "Expected Value: /var should be a separate partition."\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure separate partition exists for /var"\necho "Status: Fail"\necho "Current Value: /var is not a separate partition."\necho "Expected Value: /var should be a separate partition."\necho "Recommendation: Create a separate partition for /var."\necho "Remediation Steps:"\necho "1. Update /etc/fstab to include a separate partition for /var."\necho "2. Remount the /var partition if necessary."\nfi\n}\n\n# Execute check\ncheck_var_partition\n', '#!/bin/bash\n\n# Check if nodev option is set on /var partition\ncheck_var_nodev() {\nvar_nodev=$(grep -E "\\\\s+/var\\\\s+" /etc/fstab | grep -E "nodev")\n\nif [[ -n "$var_nodev" ]]; then\necho "Check: Ensure nodev option set on /var partition"\necho "Status: Pass"\necho "Current Value: nodev option is set on /var."\necho "Expected Value: nodev option should be set on /var."\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure nodev option set on /var partition"\necho "Status: Fail"\necho "Current Value: nodev option is not set on /var."\necho "Expected Value: nodev option should be set on /var."\necho "Recommendation: Set nodev option on /var."\necho "Remediation Steps:"\necho "1. Edit /etc/fstab to include \\\'nodev\\\' option for /var."\necho "2. Remount the /var partition if necessary."\nfi\n}\n\n# Execute check\ncheck_var_nodev\n', '#!/bin/bash\n\n# Check if nosuid option is set on /var partition\ncheck_var_nosuid() {\nvar_nosuid=$(grep -E "\\\\s+/var\\\\s+" /etc/fstab | grep -E "nosuid")\n\nif [[ -n "$var_nosuid" ]]; then\necho "Check: Ensure nosuid option set on /var partition"\necho "Status: Pass"\necho "Current Value: nosuid option is set on /var."\necho "Expected Value: nosuid option should be set on /var."\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure nosuid option set on /var partition"\necho "Status: Fail"\necho "Current Value: nosuid option is not set on /var."\necho "Expected Value: nosuid option should be set on /var."\necho "Recommendation: Set nosuid option on /var."\necho "Remediation Steps:"\necho "1. Edit /etc/fstab to include \\\'nosuid\\\' option for /var."\necho "2. Remount the /var partition if necessary."\nfi\n}\n\n# Execute check\ncheck_var_nosuid\n', '#!/bin/bash\n\n# Check if /var/tmp is a separate partition\ncheck_var_tmp_partition() {\nvar_tmp_partition=$(grep -E "\\\\s+/var/tmp\\\\s+" /etc/fstab)\n\nif [[ -n "$var_tmp_partition" ]]; then\necho "Check: Ensure separate partition exists for /var/tmp"\necho "Status: Pass"\necho "Current Value: /var/tmp is a separate partition."\necho "Expected Value: /var/tmp should be a separate partition."\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure separate partition exists for /var/tmp"\necho "Status: Fail"\necho "Current Value: /var/tmp is not a separate partition."\necho "Expected Value: /var/tmp should be a separate partition."\necho "Recommendation: Create a separate partition for /var/tmp."\necho "Remediation Steps:"\necho "1. Update /etc/fstab to include a separate partition for /var/tmp."\necho "2. Remount the /var/tmp partition if necessary."\nfi\n}\n\n# Execute check\ncheck_var_tmp_partition\n', '#!/bin/bash\n\n# Check if nodev option is set on /tmp partition\ncheck_tmp_nodev() {\ntmp_nodev=$(grep -E "\\\\s+/tmp\\\\s+" /etc/fstab | grep -E "nodev")\n\nif [[ -n "$tmp_nodev" ]]; then\necho "Check: Ensure nodev option set on /tmp partition"\necho "Status: Pass"\necho "Current Value: nodev option is set on /tmp."\necho "Expected Value: nodev option should be set on /tmp."\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure nodev option set on /tmp partition"\necho "Status: Fail"\necho "Current Value: nodev option is not set on /tmp."\necho "Expected Value: nodev option should be set on /tmp."\necho "Recommendation: Set nodev option on /tmp."\necho "Remediation Steps:"\necho "1. Edit /etc/fstab to include \\\'nodev\\\' option for /tmp."\necho "2. Remount the /tmp partition if necessary."\nfi\n}\n\n# Execute check\ncheck_tmp_nodev\n', '#!/bin/bash\n\n# Check if noexec option is set on /tmp partition\ncheck_tmp_noexec() {\ntmp_noexec=$(grep -E "\\\\s+/tmp\\\\s+" /etc/fstab | grep -E "noexec")\n\nif [[ -n "$tmp_noexec" ]]; then\necho "Check: Ensure noexec option set on /tmp partition"\necho "Status: Pass"\necho "Current Value: noexec option is set on /tmp."\necho "Expected Value: noexec option should be set on /tmp."\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure noexec option set on /tmp partition"\necho "Status: Fail"\necho "Current Value: noexec option is not set on /tmp."\necho "Expected Value: noexec option should be set on /tmp."\necho "Recommendation: Set noexec option on /tmp."\necho "Remediation Steps:"\necho "1. Edit /etc/fstab to include \\\'noexec\\\' option for /tmp."\necho "2. Remount the /tmp partition if necessary."\nfi\n}\n\n# Execute check\ncheck_tmp_noexec\n', '#!/bin/bash\n\n# Check if nosuid option is set on /tmp partition\ncheck_tmp_nosuid() {\ntmp_nosuid=$(grep -E "\\\\s+/tmp\\\\s+" /etc/fstab | grep -E "nosuid")\n\nif [[ -n "$tmp_nosuid" ]]; then\necho "Check: Ensure nosuid option set on /tmp partition"\necho "Status: Pass"\necho "Current Value: nosuid option is set on /tmp."\necho "Expected Value: nosuid option should be set on /tmp."\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure nosuid option set on /tmp partition"\necho "Status: Fail"\necho "Current Value: nosuid option is not set on /tmp."\necho "Expected Value: nosuid option should be set on /tmp."\necho "Recommendation: Set nosuid option on /tmp."\necho "Remediation Steps:"\necho "1. Edit /etc/fstab to include \\\'nosuid\\\' option for /tmp."\necho "2. Remount the /tmp partition if necessary."\nfi\n}\n\n# Execute check\ncheck_tmp_nosuid\n', '#!/bin/bash\n\n# Check if /var/log is a separate partition\ncheck_var_log_partition() {\nvar_log_partition=$(grep -E "\\\\s+/var/log\\\\s+" /etc/fstab)\n\nif [[ -n "$var_log_partition" ]]; then\necho "Check: Ensure separate partition exists for /var/log"\necho "Status: Pass"\necho "Current Value: /var/log is a separate partition."\necho "Expected Value: /var/log should be a separate partition."\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure separate partition exists for /var/log"\necho "Status: Fail"\necho "Current Value: /var/log is not a separate partition."\necho "Expected Value: /var/log should be a separate partition."\necho "Recommendation: Create a separate partition for /var/log."\necho "Remediation Steps:"\necho "1. Update /etc/fstab to include a separate partition for /var/log."\necho "2. Remount the /var/log partition if necessary."\nfi\n}\n\n# Execute check\ncheck_var_log_partition\n', '#!/bin/bash\n\n# Check if nodev option is set on /var/log partition\ncheck_var_log_nodev() {\nvar_log_nodev=$(grep -E "\\\\s+/var/log\\\\s+" /etc/fstab | grep -E "nodev")\n\nif [[ -n "$var_log_nodev" ]]; then\necho "Check: Ensure nodev option set on /var/log partition"\necho "Status: Pass"\necho "Current Value: nodev option is set on /var/log."\necho "Expected Value: nodev option should be set on /var/log."\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure nodev option set on /var/log partition"\necho "Status: Fail"\necho "Current Value: nodev option is not set on /var/log."\necho "Expected Value: nodev option should be set on /var/log."\necho "Recommendation: Set nodev option on /var/log."\necho "Remediation Steps:"\necho "1. Edit /etc/fstab to include \\\'nodev\\\' option for /var/log."\necho "2. Remount the /var/log partition if necessary."\nfi\n}\n\n# Execute check\ncheck_var_log_nodev\n', '#!/bin/bash\n\n# Check if noexec option is set on /var/log partition\ncheck_var_log_noexec() {\nvar_log_noexec=$(grep -E "\\\\s+/var/log\\\\s+" /etc/fstab | grep -E "noexec")\n\nif [[ -n "$var_log_noexec" ]]; then\necho "Check: Ensure noexec option set on /var/log partition"\necho "Status: Pass"\necho "Current Value: noexec option is set on /var/log."\necho "Expected Value: noexec option should be set on /var/log."\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure noexec option set on /var/log partition"\necho "Status: Fail"\necho "Current Value: noexec option is not set on /var/log."\necho "Expected Value: noexec option should be set on /var/log."\necho "Recommendation: Set noexec option on /var/log."\necho "Remediation Steps:"\necho "1. Edit /etc/fstab to include \\\'noexec\\\' option for /var/log."\necho "2. Remount the /var/log partition if necessary."\nfi\n}\n\n# Execute check\ncheck_var_log_noexec\n', '#!/bin/bash\n\n# Check if nosuid option is set on /var/log partition\ncheck_var_log_nosuid() {\nvar_log_nosuid=$(grep -E "\\\\s+/var/log\\\\s+" /etc/fstab | grep -E "nosuid")\n\nif [[ -n "$var_log_nosuid" ]]; then\necho "Check: Ensure nosuid option set on /var/log partition"\necho "Status: Pass"\necho "Current Value: nosuid option is set on /var/log."\necho "Expected Value: nosuid option should be set on /var/log."\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure nosuid option set on /var/log partition"\necho "Status: Fail"\necho "Current Value: nosuid option is not set on /var/log."\necho "Expected Value: nosuid option should be set on /var/log."\necho "Recommendation: Set nosuid option on /var/log."\necho "Remediation Steps:"\necho "1. Edit /etc/fstab to include \\\'nosuid\\\' option for /var/log."\necho "2. Remount the /var/log partition if necessary."\nfi\n}\n\n# Execute check\ncheck_var_log_nosuid\n', '#!/bin/bash\n\n# Check if /var/log/audit is a separate partition\ncheck_var_log_audit_partition() {\nvar_log_audit_partition=$(grep -E "\\\\s+/var/log/audit\\\\s+" /etc/fstab)\n\nif [[ -n "$var_log_audit_partition" ]]; then\necho "Check: Ensure separate partition exists for /var/log/audit"\necho "Status: Pass"\necho "Current Value: /var/log/audit is a separate partition."\necho "Expected Value: /var/log/audit should be a separate partition."\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure separate partition exists for /var/log/audit"\necho "Status: Fail"\necho "Current Value: /var/log/audit is not a separate partition."\necho "Expected Value: /var/log/audit should be a separate partition."\necho "Recommendation: Create a separate partition for /var/log/audit."\necho "Remediation Steps:"\necho "1. Update /etc/fstab to include a separate partition for /var/log/audit."\necho "2. Remount the /var/log/audit partition if necessary."\nfi\n}\n\n# Execute check\ncheck_var_log_audit_partition\n', '#!/bin/bash\n\n# Check if noexec option is set on /var/log/audit partition\ncheck_var_log_audit_noexec() {\nvar_log_audit_noexec=$(grep -E "\\\\s+/var/log/audit\\\\s+" /etc/fstab | grep -E "noexec")\n\nif [[ -n "$var_log_audit_noexec" ]]; then\necho "Check: Ensure noexec option set on /var/log/audit partition"\necho "Status: Pass"\necho "Current Value: noexec option is set on /var/log/audit."\necho "Expected Value: noexec option should be set on /var/log/audit."\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure noexec option set on /var/log/audit partition"\necho "Status: Fail"\necho "Current Value: noexec option is not set on /var/log/audit."\necho "Expected Value: noexec option should be set on /var/log/audit."\necho "Recommendation: Set noexec option on /var/log/audit."\necho "Remediation Steps:"\necho "1. Edit /etc/fstab to include \\\'noexec\\\' option for /var/log/audit."\necho "2. Remount the /var/log/audit partition if necessary."\nfi\n}\n\n# Execute check\ncheck_var_log_audit_noexec\n', '#!/bin/bash\n\n# Check if nodev option is set on /var/log/audit partition\ncheck_var_log_audit_nodev() {\nvar_log_audit_nodev=$(grep -E "\\\\s+/var/log/audit\\\\s+" /etc/fstab | grep -E "nodev")\n\nif [[ -n "$var_log_audit_nodev" ]]; then\necho "Check: Ensure nodev option set on /var/log/audit partition"\necho "Status: Pass"\necho "Current Value: nodev option is set on /var/log/audit."\necho "Expected Value: nodev option should be set on /var/log/audit."\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure nodev option set on /var/log/audit partition"\necho "Status: Fail"\necho "Current Value: nodev option is not set on /var/log/audit."\necho "Expected Value: nodev option should be set on /var/log/audit."\necho "Recommendation: Set nodev option on /var/log/audit."\necho "Remediation Steps:"\necho "1. Edit /etc/fstab to include \\\'nodev\\\' option for /var/log/audit."\necho "2. Remount the /var/log/audit partition if necessary."\nfi\n}\n\n# Execute check\ncheck_var_log_audit_nodev\n', '#!/bin/bash\n\n# Check if nosuid option is set on /var/log/audit partition\ncheck_var_log_audit_nosuid() {\nvar_log_audit_nosuid=$(grep -E "\\\\s+/var/log/audit\\\\s+" /etc/fstab | grep -E "nosuid")\n\nif [[ -n "$var_log_audit_nosuid" ]]; then\necho "Check: Ensure nosuid option set on /var/log/audit partition"\necho "Status: Pass"\necho "Current Value: nosuid option is set on /var/log/audit."\necho "Expected Value: nosuid option should be set on /var/log/audit."\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure nosuid option set on /var/log/audit partition"\necho "Status: Fail"\necho "Current Value: nosuid option is not set on /var/log/audit."\necho "Expected Value: nosuid option should be set on /var/log/audit."\necho "Recommendation: Set nosuid option on /var/log/audit."\necho "Remediation Steps:"\necho "1. Edit /etc/fstab to include \\\'nosuid\\\' option for /var/log/audit."\necho "2. Remount the /var/log/audit partition if necessary."\nfi\n}\n\n# Execute check\ncheck_var_log_audit_nosuid\n', '#!/bin/bash\n\n# Check if /home is a separate partition\ncheck_home_partition() {\nhome_partition=$(grep -E "\\\\s+/home\\\\s+" /etc/fstab)\n\nif [[ -n "$home_partition" ]]; then\necho "Check: Ensure separate partition exists for /home"\necho "Status: Pass"\necho "Current Value: /home is a separate partition."\necho "Expected Value: /home should be a separate partition."\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure separate partition exists for /home"\necho "Status: Fail"\necho "Current Value: /home is not a separate partition."\necho "Expected Value: /home should be a separate partition."\necho "Recommendation: Create a separate partition for /home."\necho "Remediation Steps:"\necho "1. Update /etc/fstab to include a separate partition for /home."\necho "2. Remount the /home partition if necessary."\nfi\n}\n\n# Execute check\ncheck_home_partition\n', '#!/bin/bash\n\n# Check if nodev option is set on /home partition\ncheck_home_nodev() {\nhome_nodev=$(grep -E "\\\\s+/home\\\\s+" /etc/fstab | grep -E "nodev")\n\nif [[ -n "$home_nodev" ]]; then\necho "Check: Ensure nodev option set on /home partition"\necho "Status: Pass"\necho "Current Value: nodev option is set on /home."\necho "Expected Value: nodev option should be set on /home."\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure nodev option set on /home partition"\necho "Status: Fail"\necho "Current Value: nodev option is not set on /home."\necho "Expected Value: nodev option should be set on /home."\necho "Recommendation: Set nodev option on /home."\necho "Remediation Steps:"\necho "1. Edit /etc/fstab to include \\\'nodev\\\' option for /home."\necho "2. Remount the /home partition if necessary."\nfi\n}\n\n# Execute check\ncheck_home_nodev\n', '#!/bin/bash\n\n# Check if nosuid option is set on /home partition\ncheck_home_nosuid() {\nhome_nosuid=$(grep -E "\\\\s+/home\\\\s+" /etc/fstab | grep -E "nosuid")\n\nif [[ -n "$home_nosuid" ]]; then\necho "Check: Ensure nosuid option set on /home partition"\necho "Status: Pass"\necho "Current Value: nosuid option is set on /home."\necho "Expected Value: nosuid option should be set on /home."\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure nosuid option set on /home partition"\necho "Status: Fail"\necho "Current Value: nosuid option is not set on /home."\necho "Expected Value: nosuid option should be set on /home."\necho "Recommendation: Set nosuid option on /home."\necho "Remediation Steps:"\necho "1. Edit /etc/fstab to include \\\'nosuid\\\' option for /home."\necho "2. Remount the /home partition if necessary."\nfi\n}\n\n# Execute check\ncheck_home_nosuid\n', '#!/bin/bash\n\n# Check if /dev/shm is a separate partition\ncheck_dev_shm_partition() {\ndev_shm_partition=$(grep -E "\\\\s+/dev/shm\\\\s+" /etc/fstab)\n\nif [[ -n "$dev_shm_partition" ]]; then\necho "Check: Ensure /dev/shm is a separate partition"\necho "Status: Pass"\necho "Current Value: /dev/shm is a separate partition."\necho "Expected Value: /dev/shm should be a separate partition."\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure /dev/shm is a separate partition"\necho "Status: Fail"\necho "Current Value: /dev/shm is not a separate partition."\necho "Expected Value: /dev/shm should be a separate partition."\necho "Recommendation: Create a separate partition for /dev/shm."\necho "Remediation Steps:"\necho "1. Update /etc/fstab to include a separate partition for /dev/shm."\necho "2. Remount the /dev/shm partition if necessary."\nfi\n}\n\n# Execute check\ncheck_dev_shm_partition\n', '#!/bin/bash\n\n# Check if nodev option is set on /dev/shm partition\ncheck_dev_shm_nodev() {\ndev_shm_nodev=$(grep -E "\\\\s+/dev/shm\\\\s+" /etc/fstab | grep -E "nodev")\n\nif [[ -n "$dev_shm_nodev" ]]; then\necho "Check: Ensure nodev option set on /dev/shm partition"\necho "Status: Pass"\necho "Current Value: nodev option is set on /dev/shm."\necho "Expected Value: nodev option should be set on /dev/shm."\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure nodev option set on /dev/shm partition"\necho "Status: Fail"\necho "Current Value: nodev option is not set on /dev/shm."\necho "Expected Value: nodev option should be set on /dev/shm."\necho "Recommendation: Set nodev option on /dev/shm."\necho "Remediation Steps:"\necho "1. Edit /etc/fstab to include \\\'nodev\\\' option for /dev/shm."\necho "2. Remount the /dev/shm partition if necessary."\nfi\n}\n\n# Execute check\ncheck_dev_shm_nodev\n', '#!/bin/bash\n\n# Check if noexec option is set on /dev/shm partition\ncheck_dev_shm_noexec() {\ndev_shm_noexec=$(grep -E "\\\\s+/dev/shm\\\\s+" /etc/fstab | grep -E "noexec")\n\nif [[ -n "$dev_shm_noexec" ]]; then\necho "Check: Ensure noexec option set on /dev/shm partition"\necho "Status: Pass"\necho "Current Value: noexec option is set on /dev/shm."\necho "Expected Value: noexec option should be set on /dev/shm."\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure noexec option set on /dev/shm partition"\necho "Status: Fail"\necho "Current Value: noexec option is not set on /dev/shm."\necho "Expected Value: noexec option should be set on /dev/shm."\necho "Recommendation: Set noexec option on /dev/shm."\necho "Remediation Steps:"\necho "1. Edit /etc/fstab to include \\\'noexec\\\' option for /dev/shm."\necho "2. Remount the /dev/shm partition if necessary."\nfi\n}\n\n# Execute check\ncheck_dev_shm_noexec\n', '#!/bin/bash\n\n# Check if nosuid option is set on /dev/shm partition\ncheck_dev_shm_nosuid() {\ndev_shm_nosuid=$(grep -E "\\\\s+/dev/shm\\\\s+" /etc/fstab | grep -E "nosuid")\n\nif [[ -n "$dev_shm_nosuid" ]]; then\necho "Check: Ensure nosuid option set on /dev/shm partition"\necho "Status: Pass"\necho "Current Value: nosuid option is set on /dev/shm."\necho "Expected Value: nosuid option should be set on /dev/shm."\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure nosuid option set on /dev/shm partition"\necho "Status: Fail"\necho "Current Value: nosuid option is not set on /dev/shm."\necho "Expected Value: nosuid option should be set on /dev/shm."\necho "Recommendation: Set nosuid option on /dev/shm."\necho "Remediation Steps:"\necho "1. Edit /etc/fstab to include \\\'nosuid\\\' option for /dev/shm."\necho "2. Remount the /dev/shm partition if necessary."\nfi\n}\n\n# Execute check\ncheck_dev_shm_nosuid\n', '#!/bin/bash\n\n# Check if USB storage is currently enabled\nusb_storage_enabled=$(lsmod | grep usb_storage)\n\nif [[ -n "$usb_storage_enabled" ]]; then\necho "Check: Ensure USB Storage is disabled"\necho "Status: Fail"\necho "Current Value: USB Storage is currently enabled."\necho "Expected Value: USB Storage should be disabled."\necho "Recommendation: Disable USB storage and blacklist the module."\necho "Remediation:"\necho "# sudo modprobe -r usb_storage"\necho "# echo \\\'blacklist usb_storage\\\' | sudo tee -a /etc/modprobe.d/blacklist.conf"\necho "USB Storage has been disabled and blacklisted."\nelse\necho "Check: Ensure USB Storage is disabled"\necho "Status: Pass"\necho "Current Value: USB Storage is already disabled."\necho "Expected Value: USB Storage should be disabled."\necho "Recommendation: No remediation required."\nfi\n', '#!/bin/bash\n\n# Define the GPG key directory\ngpg_dir="/etc/pki/rpm-gpg/"\n\n# Check if the directory exists and contains GPG key files\nif [[ -d "$gpg_dir" && -n $(find "$gpg_dir" -type f \\( -iname ".gpg" -o -iname ".asc" \\)) ]]; then\n    echo "Check: Ensure GPG keys are configured"\n    echo "Status: Pass"\n    echo "Current Value: GPG keys are configured in $gpg_dir"\n    echo "Recommendation: No action needed."\nelse\n    echo "Check: Ensure GPG keys are configured"\n    echo "Status: Fail"\n    echo "Current Value: No GPG keys found in $gpg_dir"\n    echo "Recommendation: Ensure GPG keys are configured to verify package authenticity."\n    echo "Remediation Steps:"\n    echo "1. Ensure that the necessary GPG key files are present in $gpg_dir."\n    echo "2. Example: Download or import the necessary GPG keys for your package manager."\n    echo "3. To import a GPG key: sudo rpm --import /path/to/keyfile"\nfi\n', '#!/bin/bash\n\n# Define the yum configuration file\nyum_conf="/etc/yum.conf"\n\n# Check if the yum.conf file exists\nif [[ -f "$yum_conf" ]]; then\n# Check if gpgcheck is enabled in the yum.conf file\ngpgcheck_status=$(grep -i "^gpgcheck" "$yum_conf")\n\nif [[ "$gpgcheck_status" =~ ^gpgcheck[[:space:]]*=[[:space:]]*1 ]]; then\necho "Check: Ensure gpgcheck is globally activated"\necho "Status: Pass"\necho "Current Value: gpgcheck is enabled in $yum_conf"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure gpgcheck is globally activated"\necho "Status: Fail"\necho "Current Value: gpgcheck is not enabled in $yum_conf"\necho "Recommendation: Ensure that gpgcheck is enabled to verify package authenticity."\necho "Remediation Steps:"\necho "1. To enable gpgcheck globally, add the following line in $yum_conf:"\necho "   gpgcheck=1"\necho "2. Save the file and run \\\'sudo yum update\\\' to check if the configuration is working."\nfi\nelse\necho "Check: Ensure gpgcheck is globally activated"\necho "Status: Fail"\necho "Current Value: $yum_conf does not exist"\necho "Recommendation: Ensure that the $yum_conf file exists and contains the appropriate configurations."\necho "Remediation Steps:"\necho "1. Create the $yum_conf file if it does not exist."\necho "2. Add the following line to enable gpgcheck globally:"\necho "   gpgcheck=1"\necho "3. Save the file and run \\\'sudo yum update\\\' to verify the changes."\nfi\n', '#!/bin/bash\n\n# Define the directory where repo files are located\nrepo_dir="/etc/yum.repos.d/"\n\n# Check if the directory exists\nif [[ -d "$repo_dir" ]]; then\n# Check if the directory contains any files\nrepo_check=$(ls "$repo_dir")\n\nif [[ -n "$repo_check" ]]; then\necho "Check: Ensure package manager repositories are configured"\necho "Status: Pass"\necho "Current Value: Repositories are configured in $repo_dir"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure package manager repositories are configured"\necho "Status: Fail"\necho "Current Value: No repositories found in $repo_dir"\necho "Recommendation: Ensure that the necessary .repo files are present."\necho "Remediation Steps:"\necho "1. Add necessary repository files in $repo_dir."\necho "2. Example: Copy the repo files or configure the repositories as needed."\nfi\nelse\necho "Check: Ensure package manager repositories are configured"\necho "Status: Fail"\necho "Current Value: Directory $repo_dir does not exist"\necho "Recommendation: Ensure that the $repo_dir directory exists and contains repository files."\necho "Remediation Steps:"\necho "1. Create the directory $repo_dir if it does not exist."\necho "2. Add the necessary repository files in $repo_dir."\necho "3. Example: Use \\\'yum-config-manager\\\' or manually create .repo files."\nfi\n', '#!/bin/bash\n\n# Define the yum configuration file\nyum_conf="/etc/yum.conf"\n\n# Check if the yum.conf file exists\nif [[ -f "$yum_conf" ]]; then\n# Check if repo_gpgcheck is enabled in the yum.conf file\nrepo_gpgcheck_status=$(grep -i "^repo_gpgcheck" "$yum_conf")\n\nif [[ "$repo_gpgcheck_status" =~ ^repo_gpgcheck[[:space:]]*=[[:space:]]*1 ]]; then\necho "Check: Ensure repo_gpgcheck is globally activated"\necho "Status: Pass"\necho "Current Value: repo_gpgcheck is enabled in $yum_conf"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure repo_gpgcheck is globally activated"\necho "Status: Fail"\necho "Current Value: repo_gpgcheck is not enabled in $yum_conf"\necho "Recommendation: Ensure that repo_gpgcheck is enabled to verify repository authenticity."\necho "Remediation Steps:"\necho "1. To enable repo_gpgcheck globally, add the following line in $yum_conf:"\necho "   repo_gpgcheck=1"\necho "2. Save the file and run \\\'sudo yum update\\\' to check if the configuration is working."\nfi\nelse\necho "Check: Ensure repo_gpgcheck is globally activated"\necho "Status: Fail"\necho "Current Value: $yum_conf does not exist"\necho "Recommendation: Ensure that the $yum_conf file exists and contains the appropriate configurations."\necho "Remediation Steps:"\necho "1. Create the $yum_conf file if it does not exist."\necho "2. Add the following line to enable repo_gpgcheck globally:"\necho "   repo_gpgcheck=1"\necho "3. Save the file and run \\\'sudo yum update\\\' to verify the changes."\nfi\n', '#!/bin/bash\n\n# Check if rpm or dpkg command is available\nif command -v rpm &> /dev/null; then\n# For Red Hat-based systems\naide_installed=$(rpm -q aide)\nelif command -v dpkg &> /dev/null; then\n# For Debian-based systems\naide_installed=$(dpkg-query -l aide 2>/dev/null)\nelse\necho "Error: No supported package manager found (rpm or dpkg). Please install a supported package manager."\nexit 1\nfi\n\nif [[ "$aide_installed" == *"is not installed"* || "$aide_installed" == "" ]]; then\necho "Check: Ensure AIDE is installed"\necho "Status: Fail"\necho "Current Value: AIDE is not installed"\necho "Recommendation: Install AIDE to monitor file system integrity."\necho "Remediation Steps:"\nif command -v rpm &> /dev/null; then\necho "1. Install AIDE using the following command:"\necho "   sudo yum install aide"\nelif command -v dpkg &> /dev/null; then\n# Check if AIDE is available in the repository\necho "1. Install AIDE using the following command:"\necho "   sudo apt-get install aide"\necho "   (If the package is not found, ensure your package list is updated using: sudo apt-get update)"\nfi\nelse\necho "Check: Ensure AIDE is installed"\necho "Status: Pass"\necho "Current Value: AIDE is installed ($aide_installed)"\necho "Recommendation: No action needed."\nfi\n', '#!/bin/bash\n\n# Check if rpm or dpkg command is available\nif command -v rpm &> /dev/null; then\n# For Red Hat-based systems\naide_installed=$(rpm -q aide)\naide_cron_check=$(crontab -l 2>/dev/null | grep aide)\nelif command -v dpkg &> /dev/null; then\n# For Debian-based systems\naide_installed=$(dpkg-query -l aide 2>/dev/null)\naide_cron_check=$(crontab -l 2>/dev/null | grep aide)\nelse\nexit 1\nfi\n\n# Check if AIDE is installed\nif [[ -z "$aide_installed" || "$aide_installed" == *"is not installed"* ]]; then\necho "Check: Ensure filesystem integrity is regularly checked"\necho "Status: Fail"\necho "Current Value: AIDE is not installed"\necho "Recommendation: Install AIDE and set up regular filesystem integrity checks."\necho "Remediation Steps:"\nif command -v rpm &> /dev/null; then\necho "1. Install AIDE using the following command:"\necho "   sudo yum install aide"\nelif command -v dpkg &> /dev/null; then\necho "1. Install AIDE using the following command:"\necho "   sudo apt-get install aide"\necho "   (If the package is not found, ensure your package list is updated using: sudo apt-get update)"\nfi\necho "2. After installation, set up a cron job to check filesystem integrity regularly."\necho "   Run the following command to add a cron job:"\necho "   sudo crontab -e"\necho "   Add the following line to run AIDE daily:"\necho "   0 3 * * * /usr/sbin/aide --check"\nelse\n# Check if the cron job is set up\nif [[ -n "$aide_cron_check" ]]; then\necho "Check: Ensure filesystem integrity is regularly checked"\necho "Status: Pass"\necho "Current Value: AIDE cron job exists"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure filesystem integrity is regularly checked"\necho "Status: Fail"\necho "Current Value: No AIDE cron job found"\necho "Recommendation: Set up a cron job to regularly check filesystem integrity."\necho "Remediation Steps:"\necho "1. Edit the crontab with the following command:"\necho "   sudo crontab -e"\necho "2. Add the following cron job to run AIDE daily (or modify frequency as needed):"\necho "   0 3 * * * /usr/sbin/aide --check"\necho "3. Save and exit the crontab."\nfi\nfi\n', '#!/bin/bash\n\n# Check if rpm or dpkg command is available\nif command -v rpm &> /dev/null; then\n# For Red Hat-based systems\nauditd_installed=$(rpm -q audit)\nauditd_check=$(grep "CRYPTO" /etc/audit/auditd.conf 2>/dev/null)\nelif command -v dpkg &> /dev/null; then\n# For Debian-based systems\nauditd_installed=$(dpkg-query -l auditd 2>/dev/null)\nauditd_check=$(grep "CRYPTO" /etc/audit/auditd.conf 2>/dev/null)\nelse\nexit 1\nfi\n\n# Check if auditd is installed\nif [[ -z "$auditd_installed" || "$auditd_installed" == *"is not installed"* ]]; then\necho "Check: Ensure cryptographic mechanisms are used to protect the integrity of audit tools"\necho "Status: Fail"\necho "Current Value: Auditd is not installed"\necho "Recommendation: Install auditd and configure cryptographic protection."\necho "Remediation Steps:"\nif command -v rpm &> /dev/null; then\necho "1. Install auditd using the following command:"\necho "   sudo yum install audit"\nelif command -v dpkg &> /dev/null; then\necho "1. Install auditd using the following command:"\necho "   sudo apt-get install auditd"\necho "   (If the package is not found, ensure your package list is updated using: sudo apt-get update)"\nfi\necho "2. After installation, ensure cryptographic mechanisms are configured in /etc/audit/auditd.conf."\nelse\n# Check if CRYPTO option is configured\nif [[ -n "$auditd_check" && "$auditd_check" == *"CRYPTO"* ]]; then\necho "Check: Ensure cryptographic mechanisms are used to protect the integrity of audit tools"\necho "Status: Pass"\necho "Current Value: Cryptographic protection enabled"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure cryptographic mechanisms are used to protect the integrity of audit tools"\necho "Status: Fail"\necho "Current Value: Cryptographic protection not enabled"\necho "Recommendation: Enable cryptographic protection in /etc/audit/auditd.conf"\necho "Remediation Steps:"\necho "1. Edit /etc/audit/auditd.conf and ensure the CRYPTO option is enabled."\necho "2. Example: Add or modify the following line in /etc/audit/auditd.conf:"\necho "   CRYPTO = yes"\necho "3. Restart auditd service to apply changes:"\necho "   sudo systemctl restart auditd"\nfi\nfi\n', '#!/bin/bash\n\n# Check if grub configuration exists\nif [[ -f /etc/default/grub ]]; then\n# Check if GRUB_PASSWORD is set\ngrub_password_check=$(grep "GRUB_PASSWORD" /etc/default/grub 2>/dev/null)\n\nif [[ -n "$grub_password_check" ]]; then\necho "Check: Ensure bootloader password is set"\necho "Status: Pass"\necho "Current Value: Bootloader password is configured"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure bootloader password is set"\necho "Status: Fail"\necho "Current Value: Bootloader password is not configured"\necho "Recommendation: Set a bootloader password in /etc/default/grub"\necho "Remediation Steps:"\necho "1. Edit the /etc/default/grub file and set the GRUB_PASSWORD variable."\necho "   Example: GRUB_PASSWORD=\\\'your_encrypted_password\\\'"\necho "2. Generate an encrypted password using the grub-mkpasswd-pbkdf2 command:"\necho "   sudo grub-mkpasswd-pbkdf2"\necho "3. Add the generated password to the GRUB_PASSWORD variable."\necho "4. After making changes, update the grub configuration:"\necho "   sudo grub2-mkconfig -o /boot/grub2/grub.cfg"\necho "5. Reboot the system for the changes to take effect."\nfi\nelse\necho "Check: Ensure bootloader password is set"\necho "Status: Fail"\necho "Current Value: /etc/default/grub not found"\necho "Recommendation: Ensure the system uses GRUB as the bootloader and the /etc/default/grub file exists."\necho "Remediation Steps:"\necho "1. Verify the system\\\'s bootloader is GRUB and the file /etc/default/grub exists."\necho "2. If using a different bootloader, refer to its documentation for setting a password."\nfi\n', '#!/bin/bash\n\n# Check if grub configuration exists\nif [[ -f /etc/default/grub ]]; then\n# Get the permissions of the bootloader config file\ngrub_permissions=$(stat -c "%a %U %G" /etc/default/grub)\n\n# Check if permissions are set to 600 and owner is root\nif [[ "$grub_permissions" == "600 root root" ]]; then\necho "Check: Ensure permissions on bootloader config are configured"\necho "Status: Pass"\necho "Current Value: Permissions are set to 600 and owned by root"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure permissions on bootloader config are configured"\necho "Status: Fail"\necho "Current Value: Permissions are not set to 600 or ownership is incorrect"\necho "Recommendation: Set the correct permissions and ownership"\necho "Remediation Steps:"\necho "1. Run the following command to set the correct permissions:"\necho "   sudo chmod 600 /etc/default/grub"\necho "2. Run the following command to set the correct ownership:"\necho "   sudo chown root:root /etc/default/grub"\nfi\nelse\necho "Check: Ensure permissions on bootloader config are configured"\necho "Status: Fail"\necho "Current Value: /etc/default/grub not found"\necho "Recommendation: Ensure the system uses GRUB as the bootloader and the /etc/default/grub file exists."\necho "Remediation Steps:"\necho "1. Verify the system\\\'s bootloader is GRUB and the file /etc/default/grub exists."\necho "2. If using a different bootloader, refer to its documentation for configuring file permissions."\nfi\n', '#!/bin/bash\n\n# Check if core dumps are disabled by checking /etc/security/limits.conf\nif grep -q "hard core 0" /etc/security/limits.conf 2>/dev/null; then\necho "Check: Ensure core dump storage is disabled"\necho "Status: Pass"\necho "Current Value: Core dumps are disabled"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure core dump storage is disabled"\necho "Status: Fail"\necho "Current Value: Core dump storage is enabled"\necho "Recommendation: Disable core dump storage"\necho "Remediation Steps:"\necho "1. Open /etc/security/limits.conf for editing:"\necho "   sudo nano /etc/security/limits.conf"\necho "2. Add or update the following line to disable core dumps:"\necho "   * hard core 0"\necho "3. Save and close the file."\necho "4. Reboot the system or restart the service for changes to take effect."\nfi\n', '#!/bin/bash\n\n# Check if core dump backtraces are disabled by verifying /proc/sys/kernel/core_pattern\ncore_pattern_check=$(cat /proc/sys/kernel/core_pattern)\n\nif [[ "$core_pattern_check" == "|/bin/false" ]]; then\necho "Check: Ensure core dump backtraces are disabled"\necho "Status: Pass"\necho "Current Value: Core dump backtraces are disabled"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure core dump backtraces are disabled"\necho "Status: Fail"\necho "Current Value: Core dump backtraces are enabled"\necho "Recommendation: Disable core dump backtraces"\necho "Remediation Steps:"\necho "1. Open /etc/sysctl.conf for editing:"\necho "   sudo nano /etc/sysctl.conf"\necho "2. Add the following line to disable core dump backtraces:"\necho "   kernel.core_pattern = |/bin/false"\necho "3. Save and close the file."\necho "4. Apply the changes by running the following command:"\necho "   sudo sysctl -p"\necho "5. Reboot the system for changes to take effect."\nfi\n', '#!/bin/bash\n\n# Check if ASLR is enabled\nasl_status=$(cat /proc/sys/kernel/randomize_va_space)\n\nif [[ "$asl_status" -eq 2 ]]; then\necho "Check: Ensure address space layout randomization (ASLR) is enabled"\necho "Status: Pass"\necho "Current Value: ASLR is enabled"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure address space layout randomization (ASLR) is enabled"\necho "Status: Fail"\necho "Current Value: ASLR is disabled"\necho "Recommendation: Enable ASLR"\necho "Remediation Steps:"\necho "1. Edit /etc/sysctl.conf to enable ASLR:"\necho "   sudo nano /etc/sysctl.conf"\necho "2. Add the following line to enable ASLR:"\necho "   kernel.randomize_va_space = 2"\necho "3. Save and close the file."\necho "4. Apply the changes by running the following command:"\necho "   sudo sysctl -p"\necho "5. Reboot the system for changes to take effect."\nfi\n', '#!/bin/bash\n\n# Check if SELinux is installed\nif rpm -q selinux-policy &>/dev/null; then\necho "Check: Ensure SELinux is installed"\necho "Status: Pass"\necho "Current Value: SELinux is installed"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure SELinux is installed"\necho "Status: Fail"\necho "Current Value: SELinux is not installed"\necho "Recommendation: Install SELinux"\necho "Remediation Steps:"\necho "1. Install SELinux package by running the following command:"\necho "   sudo yum install selinux-policy"\necho "2. Reboot the system or restart the service for changes to take effect."\nfi\n', '#!/bin/bash\n\n# Check if SELinux is disabled in the bootloader configuration\nselinux_bootloader_check=$(grep -i \\\'selinux=0\\\' /etc/grub.conf /etc/default/grub 2>/dev/null)\n\nif [[ -z "$selinux_bootloader_check" ]]; then\necho "Check: Ensure SELinux is not disabled in bootloader configuration"\necho "Status: Pass"\necho "Current Value: SELinux is not disabled in bootloader configuration"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure SELinux is not disabled in bootloader configuration"\necho "Status: Fail"\necho "Current Value: SELinux is disabled in bootloader configuration"\necho "Recommendation: Enable SELinux in bootloader configuration"\necho "Remediation Steps:"\necho "1. Edit the GRUB configuration file:"\necho "   sudo nano /etc/default/grub"\necho "2. Ensure that \\\'selinux=0\\\' is removed or commented out."\necho "3. Rebuild the GRUB config by running the following command:"\necho "   sudo grub2-mkconfig -o /boot/grub2/grub.cfg"\necho "4. Reboot the system for changes to take effect."\nfi\n', '#!/bin/bash\n\n# Check if SELinux policy is configured\nselinux_policy_check=$(getenforce)\n\nif [[ "$selinux_policy_check" != "Disabled" ]]; then\necho "Check: Ensure SELinux policy is configured"\necho "Status: Pass"\necho "Current Value: SELinux policy is configured"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure SELinux policy is configured"\necho "Status: Fail"\necho "Current Value: SELinux policy is not configured"\necho "Recommendation: Configure SELinux policy"\necho "Remediation Steps:"\necho "1. Edit the SELinux configuration file:"\necho "   sudo nano /etc/selinux/config"\necho "2. Set SELINUX=enforcing or SELINUX=permissive."\necho "3. Reboot the system for changes to take effect."\nfi\n', '#!/bin/bash\n\n# Check if the SELinux mode is disabled\nselinux_mode_check=$(getenforce)\n\nif [[ "$selinux_mode_check" != "Disabled" ]]; then\necho "Check: Ensure the SELinux mode is not disabled"\necho "Status: Pass"\necho "Current Value: SELinux mode is not disabled"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure the SELinux mode is not disabled"\necho "Status: Fail"\necho "Current Value: SELinux mode is disabled"\necho "Recommendation: Enable SELinux"\necho "Remediation Steps:"\necho "1. Edit the SELinux configuration file:"\necho "   sudo nano /etc/selinux/config"\necho "2. Set SELINUX=enforcing."\necho "3. Reboot the system for changes to take effect."\nfi\n', '#!/bin/bash\n\n# Check if the SELinux mode is enforcing\nselinux_enforcing_check=$(getenforce)\n\nif [[ "$selinux_enforcing_check" == "Enforcing" ]]; then\necho "Check: Ensure the SELinux mode is enforcing"\necho "Status: Pass"\necho "Current Value: SELinux mode is enforcing"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure the SELinux mode is enforcing"\necho "Status: Fail"\necho "Current Value: SELinux mode is not enforcing"\necho "Recommendation: Set SELinux mode to enforcing"\necho "Remediation Steps:"\necho "1. Edit the SELinux configuration file:"\necho "   sudo nano /etc/selinux/config"\necho "2. Set SELINUX=enforcing."\necho "3. Reboot the system for changes to take effect."\nfi\n', '#!/bin/bash\n\n# Check for unconfined services\nunconfined_services=$(ps -eZ | grep unconfined)\n\nif [[ -z "$unconfined_services" ]]; then\necho "Check: Ensure no unconfined services exist"\necho "Status: Pass"\necho "Current Value: No unconfined services found"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure no unconfined services exist"\necho "Status: Fail"\necho "Current Value: Unconfined services exist"\necho "Recommendation: Restrict unconfined services"\necho "Remediation Steps:"\necho "1. Review and configure the services running without confinement."\necho "2. Modify the SELinux policy or service configuration to enforce confinement."\nfi\n', '#!/bin/bash\n\n# Check if SETroubleshoot is installed\nsetroubleshoot_check=$(rpm -q setroubleshoot)\n\nif [[ "$setroubleshoot_check" == "package setroubleshoot is not installed" ]]; then\necho "Check: Ensure SETroubleshoot is not installed"\necho "Status: Pass"\necho "Current Value: SETroubleshoot is not installed"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure SETroubleshoot is not installed"\necho "Status: Fail"\necho "Current Value: SETroubleshoot is installed"\necho "Recommendation: Uninstall SETroubleshoot"\necho "Remediation Steps:"\necho "1. Uninstall SETroubleshoot by running the following command:"\necho "   sudo yum remove setroubleshoot"\necho "2. Reboot the system for changes to take effect."\nfi\n', '#!/bin/bash\n\n# Check if mcstrans is installed\nmcstrans_check=$(rpm -q mcstrans)\n\nif [[ "$mcstrans_check" == "package mcstrans is not installed" ]]; then\necho "Check: Ensure the MCS Translation Service (mcstrans) is not installed"\necho "Status: Pass"\necho "Current Value: mcstrans is not installed"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure the MCS Translation Service (mcstrans) is not installed"\necho "Status: Fail"\necho "Current Value: mcstrans is installed"\necho "Recommendation: Uninstall mcstrans"\necho "Remediation Steps:"\necho "1. Uninstall mcstrans by running the following command:"\necho "   sudo yum remove mcstrans"\necho "2. Reboot the system for changes to take effect."\nfi\n', '#!/bin/bash\n\n# Check if secure ICMP redirects are accepted\nsecure_icmp_redirects=$(sysctl net.ipv4.conf.all.secure_redirects)\n\nif [[ "$secure_icmp_redirects" == "net.ipv4.conf.all.secure_redirects = 0" ]]; then\necho "Check: Ensure secure ICMP redirects are not accepted"\necho "Status: Pass"\necho "Current Value: Secure ICMP redirects are not accepted"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure secure ICMP redirects are not accepted"\necho "Status: Fail"\necho "Current Value: Secure ICMP redirects are accepted"\necho "Recommendation: Disable secure ICMP redirects acceptance."\necho "Remediation Steps:"\necho "1. To disable secure ICMP redirects acceptance, run the following command:"\necho "   sudo sysctl -w net.ipv4.conf.all.secure_redirects=0"\necho "2. To make this change persistent, edit /etc/sysctl.conf and add the following line:"\necho "   net.ipv4.conf.all.secure_redirects = 0"\necho "3. Run \\\'sudo sysctl -p\\\' to apply the changes."\nfi\n', '#!/bin/bash\n\n# Check if suspicious packets are logged\nlog_suspicious=$(sysctl net.ipv4.conf.all.log_martians)\n\nif [[ "$log_suspicious" == "net.ipv4.conf.all.log_martians = 1" ]]; then\necho "Check: Ensure suspicious packets are logged"\necho "Status: Pass"\necho "Current Value: Suspicious packets are logged"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure suspicious packets are logged"\necho "Status: Fail"\necho "Current Value: Suspicious packets are not logged"\necho "Recommendation: Enable logging of suspicious packets."\necho "Remediation Steps:"\necho "1. To enable logging of suspicious packets, run the following command:"\necho "   sudo sysctl -w net.ipv4.conf.all.log_martians=1"\necho "2. To make this change persistent, edit /etc/sysctl.conf and add the following line:"\necho "   net.ipv4.conf.all.log_martians = 1"\necho "3. Run \\\'sudo sysctl -p\\\' to apply the changes."\nfi\n', '#!/bin/bash\n\n# Check if broadcast ICMP requests are ignored\nicmp_broadcast=$(sysctl net.ipv4.icmp_echo_ignore_broadcasts)\n\nif [[ "$icmp_broadcast" == "net.ipv4.icmp_echo_ignore_broadcasts = 1" ]]; then\necho "Check: Ensure broadcast ICMP requests are ignored"\necho "Status: Pass"\necho "Current Value: Broadcast ICMP requests are ignored"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure broadcast ICMP requests are ignored"\necho "Status: Fail"\necho "Current Value: Broadcast ICMP requests are not ignored"\necho "Recommendation: Ignore broadcast ICMP requests."\necho "Remediation Steps:"\necho "1. To ignore broadcast ICMP requests, run the following command:"\necho "   sudo sysctl -w net.ipv4.icmp_echo_ignore_broadcasts=1"\necho "2. To make this change persistent, edit /etc/sysctl.conf and add the following line:"\necho "   net.ipv4.icmp_echo_ignore_broadcasts = 1"\necho "3. Run \\\'sudo sysctl -p\\\' to apply the changes."\nfi\n', '#!/bin/bash\n\n# Check if bogus ICMP responses are ignored\nicmp_ignore_bogus=$(sysctl net.ipv4.icmp_ignore_bogus_error_responses)\n\nif [[ "$icmp_ignore_bogus" == "net.ipv4.icmp_ignore_bogus_error_responses = 1" ]]; then\necho "Check: Ensure bogus ICMP responses are ignored"\necho "Status: Pass"\necho "Current Value: Bogus ICMP responses are ignored"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure bogus ICMP responses are ignored"\necho "Status: Fail"\necho "Current Value: Bogus ICMP responses are not ignored"\necho "Recommendation: Ignore bogus ICMP responses."\necho "Remediation Steps:"\necho "1. To ignore bogus ICMP responses, run the following command:"\necho "   sudo sysctl -w net.ipv4.icmp_ignore_bogus_error_responses=1"\necho "2. To make this change persistent, edit /etc/sysctl.conf and add the following line:"\necho "   net.ipv4.icmp_ignore_bogus_error_responses = 1"\necho "3. Run \\\'sudo sysctl -p\\\' to apply the changes."\nfi\n', '#!/bin/bash\n\n# Check if Reverse Path Filtering is enabled\nreverse_path=$(sysctl net.ipv4.conf.all.rp_filter)\n\nif [[ "$reverse_path" == "net.ipv4.conf.all.rp_filter = 1" ]]; then\necho "Check: Ensure Reverse Path Filtering is enabled"\necho "Status: Pass"\necho "Current Value: Reverse Path Filtering is enabled"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure Reverse Path Filtering is enabled"\necho "Status: Fail"\necho "Current Value: Reverse Path Filtering is not enabled"\necho "Recommendation: Enable Reverse Path Filtering."\necho "Remediation Steps:"\necho "1. To enable Reverse Path Filtering, run the following command:"\necho "   sudo sysctl -w net.ipv4.conf.all.rp_filter=1"\necho "2. To make this change persistent, edit /etc/sysctl.conf and add the following line:"\necho "   net.ipv4.conf.all.rp_filter = 1"\necho "3. Run \\\'sudo sysctl -p\\\' to apply the changes."\nfi\n', '#!/bin/bash\n\n# Check if TCP SYN Cookies are enabled\nsyn_cookies=$(sysctl net.ipv4.tcp_syncookies)\n\nif [[ "$syn_cookies" == "net.ipv4.tcp_syncookies = 1" ]]; then\necho "Check: Ensure TCP SYN Cookies is enabled"\necho "Status: Pass"\necho "Current Value: TCP SYN Cookies are enabled"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure TCP SYN Cookies is enabled"\necho "Status: Fail"\necho "Current Value: TCP SYN Cookies are not enabled"\necho "Recommendation: Enable TCP SYN Cookies."\necho "Remediation Steps:"\necho "1. To enable TCP SYN Cookies, run the following command:"\necho "   sudo sysctl -w net.ipv4.tcp_syncookies=1"\necho "2. To make this change persistent, edit /etc/sysctl.conf and add the following line:"\necho "   net.ipv4.tcp_syncookies = 1"\necho "3. Run \\\'sudo sysctl -p\\\' to apply the changes."\nfi\n', '#!/bin/bash\n\n# Check if IPv6 router advertisements are accepted\nipv6_router_advertisements=$(sysctl net.ipv6.conf.all.accept_ra)\n\nif [[ "$ipv6_router_advertisements" == "net.ipv6.conf.all.accept_ra = 0" ]]; then\necho "Check: Ensure IPv6 router advertisements are not accepted"\necho "Status: Pass"\necho "Current Value: IPv6 router advertisements are not accepted"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure IPv6 router advertisements are not accepted"\necho "Status: Fail"\necho "Current Value: IPv6 router advertisements are accepted"\necho "Recommendation: Disable IPv6 router advertisements."\necho "Remediation Steps:"\necho "1. To disable IPv6 router advertisements, run the following command:"\necho "   sudo sysctl -w net.ipv6.conf.all.accept_ra=0"\necho "2. To make this change persistent, edit /etc/sysctl.conf and add the following line:"\necho "   net.ipv6.conf.all.accept_ra = 0"\necho "3. Run \\\'sudo sysctl -p\\\' to apply the changes."\nfi\n', '#!/bin/bash\n\n# Check if firewalld is installed\nif ! rpm -q firewalld; then\necho "Firewalld is not installed. Installing..."\nsudo yum install -y firewalld\nelse\necho "Firewalld is already installed."\nfi\n\n# Check if firewalld is running\nif systemctl is-active --quiet firewalld; then\necho "Firewalld is active."\nelse\necho "Firewalld is not active. Starting firewalld..."\nsudo systemctl start firewalld\nsudo systemctl enable firewalld\necho "Firewalld has been started and enabled."\nfi\n', '#!/bin/bash\n\n# Check if firewalld is installed and running\nif ! systemctl is-active --quiet firewalld; then\necho "Firewalld is not active. Please ensure firewalld is installed and running."\nexit 1\nfi\n\n# Allow SSH (port 22)\nsudo firewall-cmd --permanent --add-service=ssh\necho "SSH port (22) allowed."\n\n# Allow HTTP (port 80)\nsudo firewall-cmd --permanent --add-service=http\necho "HTTP port (80) allowed."\n\n# Allow HTTPS (port 443)\nsudo firewall-cmd --permanent --add-service=https\necho "HTTPS port (443) allowed."\n\n# Deny all incoming by default\nsudo firewall-cmd --permanent --set-default-zone=drop\necho "All incoming connections are blocked by default."\n\n# Reload firewalld to apply changes\nsudo firewall-cmd --reload\necho "Firewall rules updated and reloaded."\n', '#!/bin/bash\n\n# Check if firewalld is installed and running\nif ! systemctl is-active --quiet firewalld; then\necho "Check: Ensure firewalld is installed and running"\necho "Status: Fail"\necho "Current Value: Firewalld is not active."\necho "Expected Value: Firewalld should be installed and running."\necho "Recommendation: Install and start firewalld."\necho "Remediation:"\necho "# sudo yum install firewalld -y (on RHEL-based systems)"\necho "# sudo apt install firewalld -y (on Debian-based systems)"\necho "# sudo systemctl enable --now firewalld"\nexit 1\nelse\necho "Check: Ensure firewalld is installed and running"\necho "Status: Pass"\necho "Current Value: Firewalld is active and running."\necho "Expected Value: Firewalld should be installed and running."\necho "Recommendation: No remediation required."\nfi\n\n# Allow SSH (port 22)\nif sudo firewall-cmd --permanent --add-service=ssh; then\necho "Check: Ensure SSH port (22) is allowed"\necho "Status: Pass"\necho "Current Value: SSH port (22) is allowed."\necho "Expected Value: SSH port (22) should be allowed."\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure SSH port (22) is allowed"\necho "Status: Fail"\necho "Current Value: SSH port (22) is not allowed."\necho "Expected Value: SSH port (22) should be allowed."\necho "Recommendation: Allow SSH port (22)."\necho "Remediation:"\necho "# sudo firewall-cmd --permanent --add-service=ssh"\nfi\n\n# Allow HTTP (port 80)\nif sudo firewall-cmd --permanent --add-service=http; then\necho "Check: Ensure HTTP port (80) is allowed"\necho "Status: Pass"\necho "Current Value: HTTP port (80) is allowed."\necho "Expected Value: HTTP port (80) should be allowed."\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure HTTP port (80) is allowed"\necho "Status: Fail"\necho "Current Value: HTTP port (80) is not allowed."\necho "Expected Value: HTTP port (80) should be allowed."\necho "Recommendation: Allow HTTP port (80)."\necho "Remediation:"\necho "# sudo firewall-cmd --permanent --add-service=http"\nfi\n\n# Allow HTTPS (port 443)\nif sudo firewall-cmd --permanent --add-service=https; then\necho "Check: Ensure HTTPS port (443) is allowed"\necho "Status: Pass"\necho "Current Value: HTTPS port (443) is allowed."\necho "Expected Value: HTTPS port (443) should be allowed."\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure HTTPS port (443) is allowed"\necho "Status: Fail"\necho "Current Value: HTTPS port (443) is not allowed."\necho "Expected Value: HTTPS port (443) should be allowed."\necho "Recommendation: Allow HTTPS port (443)."\necho "Remediation:"\necho "# sudo firewall-cmd --permanent --add-service=https"\nfi\n\n# Deny all incoming by default\nif sudo firewall-cmd --permanent --set-default-zone=drop; then\necho "Check: Ensure all incoming connections are denied by default"\necho "Status: Pass"\necho "Current Value: Default zone is set to drop."\necho "Expected Value: Default zone should block all incoming connections."\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure all incoming connections are denied by default"\necho "Status: Fail"\necho "Current Value: Default zone is not set to drop."\necho "Expected Value: Default zone should block all incoming connections."\necho "Recommendation: Set default zone to drop."\necho "Remediation:"\necho "# sudo firewall-cmd --permanent --set-default-zone=drop"\nfi\n\n# Reload firewalld to apply changes\nif sudo firewall-cmd --reload; then\necho "Check: Ensure firewall rules are reloaded"\necho "Status: Pass"\necho "Current Value: Firewall rules are successfully reloaded."\necho "Expected Value: Firewall rules should be reloaded after changes."\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure firewall rules are reloaded"\necho "Status: Fail"\necho "Current Value: Firewall rules are not reloaded."\necho "Expected Value: Firewall rules should be reloaded after changes."\necho "Recommendation: Reload firewall rules."\necho "Remediation:"\necho "# sudo firewall-cmd --reload"\nfi\n', '#!/bin/bash\n\n# Check if nftables is installed\nif ! command -v nft &>/dev/null; then\necho "Check: Ensure nftables is installed"\necho "Status: Fail"\necho "Current Value: nftables is not installed."\necho "Expected Value: nftables should be installed."\necho "Recommendation: Install nftables package."\necho "Remediation:"\necho "For CentOS/RHEL: sudo yum install -y nftables"\necho "For Ubuntu/Debian: sudo apt install -y nftables"\nexit 1\nelse\necho "Check: Ensure nftables is installed"\necho "Status: Pass"\necho "Current Value: nftables is installed."\necho "Recommendation: No remediation required."\nfi\n\n# Check if default \\\'filter\\\' table exists\nif ! sudo nft list tables | grep -q \\\'filter\\\'; then\necho "Check: Ensure default nftables table \\\'filter\\\' exists"\necho "Status: Fail"\necho "Current Value: No \\\'filter\\\' table found."\necho "Expected Value: Default \\\'filter\\\' table should exist."\necho "Recommendation: Create the default nftables table \\\'filter\\\'."\necho "Remediation:"\necho "# sudo nft add table inet filter"\nsudo nft add table inet filter\nif [[ $? -eq 0 ]]; then\necho "Default \\\'filter\\\' table created successfully."\nelse\necho "Failed to create the \\\'filter\\\' table. Please check your nftables configuration."\nexit 1\nfi\nelse\necho "Check: Ensure default nftables table \\\'filter\\\' exists"\necho "Status: Pass"\necho "Current Value: \\\'filter\\\' table exists."\necho "Recommendation: No remediation required."\nfi\n', '#!/bin/bash\n\n# Check if MOTD is configured\nmotd_check=$(cat /etc/motd)\n\nif [[ -n "$motd_check" ]]; then\necho "Check: Ensure message of the day is configured properly"\necho "Status: Pass"\necho "Current Value: MOTD is configured"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure message of the day is configured properly"\necho "Status: Fail"\necho "Current Value: MOTD is not configured"\necho "Recommendation: Set a valid MOTD"\necho "Remediation Steps:"\necho "1. Edit the /etc/motd file to include the desired message."\necho "2. Ensure that the file has appropriate content to notify users."\nfi\n', '#!/bin/bash\n\n# Check if local login warning banner is configured\nlogin_banner_check=$(cat /etc/issue)\n\nif [[ -n "$login_banner_check" ]]; then\necho "Check: Ensure local login warning banner is configured properly"\necho "Status: Pass"\necho "Current Value: Local login warning banner is configured"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure local login warning banner is configured properly"\necho "Status: Fail"\necho "Current Value: Local login warning banner is not configured"\necho "Recommendation: Set a local login warning banner"\necho "Remediation Steps:"\necho "1. Edit the /etc/issue file to include the desired warning message."\necho "2. Ensure that the file has a clear and appropriate warning for users."\nfi\n', '#!/bin/bash\n\n# Check if remote login warning banner is configured\nremote_banner_check=$(cat /etc/issue.net)\n\nif [[ -n "$remote_banner_check" ]]; then\necho "Check: Ensure remote login warning banner is configured properly"\necho "Status: Pass"\necho "Current Value: Remote login warning banner is configured"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure remote login warning banner is configured properly"\necho "Status: Fail"\necho "Current Value: Remote login warning banner is not configured"\necho "Recommendation: Set a remote login warning banner"\necho "Remediation Steps:"\necho "1. Edit the /etc/issue.net file to include the desired warning message."\necho "2. Ensure that the file contains a clear and appropriate warning for remote users."\nfi\n', '#!/bin/bash\n\n# Check if /etc/motd has proper permissions\nmotd_permissions=$(ls -l /etc/motd)\n\n# Expected permissions: -rw-r--r--\nif [[ "$motd_permissions" == *"-rw-r--r--"* ]]; then\necho "Check: Ensure permissions on /etc/motd are configured"\necho "Status: Pass"\necho "Current Value: /etc/motd has correct permissions"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure permissions on /etc/motd are configured"\necho "Status: Fail"\necho "Current Value: Incorrect permissions on /etc/motd"\necho "Recommendation: Correct permissions on /etc/motd"\necho "Remediation Steps:"\necho "1. Set the correct permissions by running the following command:"\necho "   sudo chmod 644 /etc/motd"\necho "2. Verify permissions with: ls -l /etc/motd"\nfi\n', '#!/bin/bash\n\n# Check if /etc/issue has proper permissions\nissue_permissions=$(ls -l /etc/issue)\n\n# Expected permissions: -rw-r--r--\nif [[ "$issue_permissions" == *"-rw-r--r--"* ]]; then\necho "Check: Ensure permissions on /etc/issue are configured"\necho "Status: Pass"\necho "Current Value: /etc/issue has correct permissions"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure permissions on /etc/issue are configured"\necho "Status: Fail"\necho "Current Value: Incorrect permissions on /etc/issue"\necho "Recommendation: Correct permissions on /etc/issue"\necho "Remediation Steps:"\necho "1. Set the correct permissions by running the following command:"\necho "   sudo chmod 644 /etc/issue"\necho "2. Verify permissions with: ls -l /etc/issue"\nfi\n', '#!/bin/bash\n\n# Check if /etc/issue.net has proper permissions\nissue_net_permissions=$(ls -l /etc/issue.net)\n\n# Expected permissions: -rw-r--r--\nif [[ "$issue_net_permissions" == *"-rw-r--r--"* ]]; then\necho "Check: Ensure permissions on /etc/issue.net are configured"\necho "Status: Pass"\necho "Current Value: /etc/issue.net has correct permissions"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure permissions on /etc/issue.net are configured"\necho "Status: Fail"\necho "Current Value: Incorrect permissions on /etc/issue.net"\necho "Recommendation: Correct permissions on /etc/issue.net"\necho "Remediation Steps:"\necho "1. Set the correct permissions by running the following command:"\necho "   sudo chmod 644 /etc/issue.net"\necho "2. Verify permissions with: ls -l /etc/issue.net"\nfi\n', '#!/bin/bash\n\n# Check if GDM is installed\ngdm_check=$(dpkg-query -l | grep gdm)\n\nif [[ -z "$gdm_check" ]]; then\necho "Check: Ensure GNOME Display Manager is removed"\necho "Status: Pass"\necho "Current Value: GDM is not installed"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure GNOME Display Manager is removed"\necho "Status: Fail"\necho "Current Value: GDM is installed"\necho "Recommendation: Remove GDM from the system."\necho "Remediation Steps:"\necho "1. Run the following command to remove GDM:"\necho "   sudo apt-get purge gdm"\necho "2. Verify GDM is removed by running: dpkg-query -l | grep gdm"\nfi\n', '#!/bin/bash\n\n# Check if GDM login banner is configured\ngdm_banner_check=$(cat /etc/gdm3/greeter.dconf-defaults | grep "banner-message-enable")\n\nif [[ -n "$gdm_banner_check" ]]; then\necho "Check: Ensure GDM login banner is configured"\necho "Status: Pass"\necho "Current Value: GDM login banner is configured"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure GDM login banner is configured"\necho "Status: Fail"\necho "Current Value: GDM login banner is not configured"\necho "Recommendation: Set up a login banner for GDM."\necho "Remediation Steps:"\necho "1. Edit the /etc/gdm3/greeter.dconf-defaults file."\necho "2. Ensure the banner-message-enable option is set to true."\necho "3. Set the banner-message-text option with the desired banner message."\nfi\n', '#!/bin/bash\n\n# Check if GDM disable-user-list is enabled\ndisable_user_list_check=$(cat /etc/gdm3/greeter.dconf-defaults | grep "disable-user-list=true")\n\nif [[ -n "$disable_user_list_check" ]]; then\necho "Check: Ensure GDM disable-user-list option is enabled"\necho "Status: Pass"\necho "Current Value: GDM disable-user-list option is enabled"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure GDM disable-user-list option is enabled"\necho "Status: Fail"\necho "Current Value: GDM disable-user-list option is not enabled"\necho "Recommendation: Enable the disable-user-list option in GDM."\necho "Remediation Steps:"\necho "1. Edit the /etc/gdm3/greeter.dconf-defaults file."\necho "2. Ensure the disable-user-list option is set to true."\nfi\n', '#!/bin/bash\n\n# Check if GDM screen locks on idle\ngdm_idle_check=$(cat /etc/gdm3/greeter.dconf-defaults | grep "lock-delay=0")\n\nif [[ -n "$gdm_idle_check" ]]; then\necho "Check: Ensure GDM screen locks when the user is idle"\necho "Status: Pass"\necho "Current Value: GDM screen lock is enabled"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure GDM screen locks when the user is idle"\necho "Status: Fail"\necho "Current Value: GDM screen lock is not configured"\necho "Recommendation: Enable screen lock for GDM when idle."\necho "Remediation Steps:"\necho "1. Edit the /etc/gdm3/greeter.dconf-defaults file."\necho "2. Ensure the lock-delay is set to 0 to lock immediately when idle."\nfi\n', '#!/bin/bash\n\n# Check if GDM screen lock cannot be overridden\ngdm_lock_override_check=$(cat /etc/gdm3/greeter.dconf-defaults | grep "lock-enabled=true")\n\nif [[ -n "$gdm_lock_override_check" ]]; then\necho "Check: Ensure GDM screen locks cannot be overridden"\necho "Status: Pass"\necho "Current Value: GDM screen lock cannot be overridden"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure GDM screen locks cannot be overridden"\necho "Status: Fail"\necho "Current Value: GDM screen lock can be overridden"\necho "Recommendation: Ensure the screen lock cannot be overridden."\necho "Remediation Steps:"\necho "1. Edit the /etc/gdm3/greeter.dconf-defaults file."\necho "2. Ensure lock-enabled is set to true."\necho "3. Save the changes."\nfi\n', '#!/bin/bash\n\n# Check if automatic mounting of removable media is disabled\ngdm_auto_mount_check=$(cat /etc/gdm3/greeter.dconf-defaults | grep "automount=false")\n\nif [[ -n "$gdm_auto_mount_check" ]]; then\necho "Check: Ensure GDM automatic mounting of removable media is disabled"\necho "Status: Pass"\necho "Current Value: GDM automatic mounting is disabled"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure GDM automatic mounting of removable media is disabled"\necho "Status: Fail"\necho "Current Value: GDM automatic mounting is enabled"\necho "Recommendation: Disable automatic mounting of removable media."\necho "Remediation Steps:"\necho "1. Edit the /etc/gdm3/greeter.dconf-defaults file."\necho "2. Ensure automount is set to false."\necho "3. Save the changes."\nfi\n', '#!/bin/bash\n\n# Check if GDM disables automatic mounting of removable media and cannot be overridden\ngdm_auto_mount_override_check=$(cat /etc/gdm3/greeter.dconf-defaults | grep "automount=false")\n\nif [[ -n "$gdm_auto_mount_override_check" ]]; then\necho "Check: Ensure GDM disabling automatic mounting of removable media is not overridden"\necho "Status: Pass"\necho "Current Value: GDM automatic mounting is not overridden"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure GDM disabling automatic mounting of removable media is not overridden"\necho "Status: Fail"\necho "Current Value: GDM automatic mounting can be overridden"\necho "Recommendation: Ensure the automount setting cannot be overridden."\necho "Remediation Steps:"\necho "1. Edit the /etc/gdm3/greeter.dconf-defaults file."\necho "2. Ensure automount is set to false and cannot be overridden."\necho "3. Save the changes."\nfi\n', '#!/bin/bash\n\n# Check if GDM autorun-never is enabled\ngdm_autorun_check=$(cat /etc/gdm3/greeter.dconf-defaults | grep "autorun-never=true")\n\nif [[ -n "$gdm_autorun_check" ]]; then\necho "Check: Ensure GDM autorun-never is enabled"\necho "Status: Pass"\necho "Current Value: GDM autorun-never is enabled"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure GDM autorun-never is enabled"\necho "Status: Fail"\necho "Current Value: GDM autorun-never is not enabled"\necho "Recommendation: Enable autorun-never in GDM."\necho "Remediation Steps:"\necho "1. Edit the /etc/gdm3/greeter.dconf-defaults file."\necho "2. Ensure autorun-never is set to true."\necho "3. Save the changes."\nfi\n', '#!/bin/bash\n\n# Check if GDM autorun-never cannot be overridden\ngdm_autorun_override_check=$(cat /etc/gdm3/greeter.dconf-defaults | grep "autorun-never=true")\n\nif [[ -n "$gdm_autorun_override_check" ]]; then\necho "Check: Ensure GDM autorun-never is not overridden"\necho "Status: Pass"\necho "Current Value: GDM autorun-never cannot be overridden"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure GDM autorun-never is not overridden"\necho "Status: Fail"\necho "Current Value: GDM autorun-never can be overridden"\necho "Recommendation: Ensure autorun-never is set and cannot be overridden."\necho "Remediation Steps:"\necho "1. Edit the /etc/gdm3/greeter.dconf-defaults file."\necho "2. Ensure autorun-never is set to true and cannot be overridden."\necho "3. Save the changes."\nfi\n', '#!/bin/bash\n\n# Check if XDCMP is enabled\nxdm_check=$(cat /etc/gdm3/custom.conf | grep "Enable=false")\n\nif [[ -n "$xdm_check" ]]; then\necho "Check: Ensure XDCMP is not enabled"\necho "Status: Pass"\necho "Current Value: XDCMP is not enabled"\necho "Recommendation: No action needed."\nelse\necho "Check: Ensure XDCMP is not enabled"\necho "Status: Fail"\necho "Current Value: XDCMP is enabled"\necho "Recommendation: Disable XDCMP."\necho "Remediation Steps:"\necho "1. Edit the /etc/gdm3/custom.conf file."\necho "2. Set Enable=false to disable XDCMP."\necho "3. Save the changes."\nfi\n', '#!/bin/bash\n\n# Check if the crypto-policies command is available\nif command -v update-crypto-policies &> /dev/null; then\n# For Red Hat-based systems (RHEL/CentOS/Fedora)\ncurrent_policy=$(update-crypto-policies --show)\n\nif [[ "$current_policy" == "LEGACY" ]]; then\necho "Check: Ensure system-wide crypto policy is not legacy"\necho "Status: Fail"\necho "Current Value: Crypto policy is set to LEGACY"\necho "Recommendation: Change the crypto policy to DEFAULT."\necho "Remediation Steps:"\necho "1. Run the following command to set the crypto policy to DEFAULT:"\necho "   sudo update-crypto-policies --set DEFAULT"\necho "2. Verify that the policy is now set to DEFAULT:"\necho "   sudo update-crypto-policies --show"\nelse\necho "Check: Ensure system-wide crypto policy is not legacy"\necho "Status: Pass"\necho "Current Value: Crypto policy is set to $current_policy"\necho "Recommendation: No action needed."\nfi\n\nelif command -v dpkg-query &> /dev/null; then\n# For Debian-based systems (Ubuntu/Debian) - using OpenSSL configuration for crypto policies\ncrypto_policy_file="/etc/ssl/openssl.cnf"\n\n# Check for legacy policy by inspecting the openssl configuration\nif grep -q "CipherString = LEGACY" "$crypto_policy_file"; then\necho "Check: Ensure system-wide crypto policy is not legacy"\necho "Status: Fail"\necho "Current Value: Crypto policy is set to LEGACY"\necho "Recommendation: Change the crypto policy to DEFAULT."\necho "Remediation Steps:"\necho "1. Edit the /etc/ssl/openssl.cnf file."\necho "2. Remove or comment out the line \\\'CipherString = LEGACY\\\'."\necho "3. Add or ensure that \\\'CipherString = DEFAULT\\\' is present."\necho "4. Save the file and restart any services using OpenSSL."\nelse\necho "Check: Ensure system-wide crypto policy is not legacy"\necho "Status: Pass"\necho "Current Value: No legacy crypto policy found"\necho "Recommendation: No action needed."\nfi\n\nelse\necho "Error: No supported package manager found. Please install \\\'update-crypto-policies\\\' or configure the system manually."\nexit 1\nfi\n', '#!/bin/bash\n\n# Function to check the permissions on /etc/passwd\ncheck_passwd_permissions() {\npasswd_permissions=$(stat -c "%a" /etc/passwd)\n\nif [[ "$passwd_permissions" == "644" ]]; then\necho "Check: Ensure permissions on /etc/passwd are configured"\necho "Status: Pass"\necho "Current Value: Permissions on /etc/passwd are 644."\necho "Expected Value: Permissions on /etc/passwd should be 644."\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure permissions on /etc/passwd are configured"\necho "Status: Fail"\necho "Current Value: Permissions on /etc/passwd are $passwd_permissions."\necho "Expected Value: Permissions on /etc/passwd should be 644."\necho "Recommendation: Set the correct permissions on /etc/passwd."\necho "Remediation:"\necho "# sudo chmod 644 /etc/passwd"\nfi\n}\n\n# Execute the check\ncheck_passwd_permissions\n', '#!/bin/bash\n\n# Function to check the permissions on /etc/passwd-\ncheck_passwd_dash_permissions() {\npasswd_dash_permissions=$(stat -c "%a" /etc/passwd-)\n\nif [[ "$passwd_dash_permissions" == "644" ]]; then\necho "Check: Ensure permissions on /etc/passwd- are configured"\necho "Status: Pass"\necho "Current Value: Permissions on /etc/passwd- are 644."\necho "Expected Value: Permissions on /etc/passwd- should be 644."\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure permissions on /etc/passwd- are configured"\necho "Status: Fail"\necho "Current Value: Permissions on /etc/passwd- are $passwd_dash_permissions."\necho "Expected Value: Permissions on /etc/passwd- should be 644."\necho "Recommendation: Set the correct permissions on /etc/passwd-."\necho "Remediation:"\necho "# sudo chmod 644 /etc/passwd-"\nfi\n}\n\n# Execute the check\ncheck_passwd_dash_permissions\n', '#!/bin/bash\n\n# Function to check the permissions on /etc/group\ncheck_group_permissions() {\ngroup_permissions=$(stat -c "%a" /etc/group)\n\nif [[ "$group_permissions" == "644" ]]; then\necho "Check: Ensure permissions on /etc/group are configured"\necho "Status: Pass"\necho "Current Value: Permissions on /etc/group are 644."\necho "Expected Value: Permissions on /etc/group should be 644."\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure permissions on /etc/group are configured"\necho "Status: Fail"\necho "Current Value: Permissions on /etc/group are $group_permissions."\necho "Expected Value: Permissions on /etc/group should be 644."\necho "Recommendation: Set the correct permissions on /etc/group."\necho "Remediation:"\necho "# sudo chmod 644 /etc/group"\nfi\n}\n\n# Execute the check\ncheck_group_permissions\n', '#!/bin/bash\n\n# Function to check the permissions on /etc/group-\ncheck_group_dash_permissions() {\ngroup_dash_permissions=$(stat -c "%a" /etc/group-)\n\nif [[ "$group_dash_permissions" == "644" ]]; then\necho "Check: Ensure permissions on /etc/group- are configured"\necho "Status: Pass"\necho "Current Value: Permissions on /etc/group- are 644."\necho "Expected Value: Permissions on /etc/group- should be 644."\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure permissions on /etc/group- are configured"\necho "Status: Fail"\necho "Current Value: Permissions on /etc/group- are $group_dash_permissions."\necho "Expected Value: Permissions on /etc/group- should be 644."\necho "Recommendation: Set the correct permissions on /etc/group-."\necho "Remediation:"\necho "# sudo chmod 644 /etc/group-"\nfi\n}\n\n# Execute the check\ncheck_group_dash_permissions\n', '#!/bin/bash\n\n# Function to check the permissions on /etc/shadow\ncheck_shadow_permissions() {\nshadow_permissions=$(stat -c "%a" /etc/shadow)\n\nif [[ "$shadow_permissions" == "0000" ]]; then\necho "Check: Ensure permissions on /etc/shadow are configured"\necho "Status: Pass"\necho "Current Value: Permissions on /etc/shadow are 0000."\necho "Expected Value: Permissions on /etc/shadow should be 0000."\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure permissions on /etc/shadow are configured"\necho "Status: Fail"\necho "Current Value: Permissions on /etc/shadow are $shadow_permissions."\necho "Expected Value: Permissions on /etc/shadow should be 0000."\necho "Recommendation: Set the correct permissions on /etc/shadow."\necho "Remediation:"\necho "# sudo chmod 0000 /etc/shadow"\nfi\n}\n\n# Execute the check\ncheck_shadow_permissions\n', '#!/bin/bash\n\n# Function to check permissions on /etc/shadow-\ncheck_permissions_shadow_minus() {\nlocal file="/etc/shadow-"\nlocal expected_permissions="600"\nlocal expected_owner="root"\nlocal expected_group="root"\n\n# Get the current permissions, owner, and group\ncurrent_permissions=$(stat -c "%a" "$file" 2>/dev/null)\ncurrent_owner=$(stat -c "%U" "$file")\ncurrent_group=$(stat -c "%G" "$file")\n\n# Check if the permissions and ownership are correct\nif [[ "$current_permissions" == "$expected_permissions" && "$current_owner" == "$expected_owner" && "$current_group" == "$expected_group" ]]; then\necho "Check: Ensure permissions on $file are configured"\necho "Status: Pass"\necho "Current Value: Permissions on $file are $current_permissions, owned by $current_owner:$current_group."\necho "Expected Value: Permissions should be $expected_permissions with owner $expected_owner and group $expected_group."\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure permissions on $file are configured"\necho "Status: Fail"\necho "Current Value: Permissions on $file are $current_permissions, owned by $current_owner:$current_group."\necho "Expected Value: Permissions should be $expected_permissions with owner $expected_owner and group $expected_group."\necho "Recommendation: Correct the permissions and ownership."\necho "Remediation:"\necho "# sudo chmod $expected_permissions $file"\necho "# sudo chown $expected_owner:$expected_group $file"\nfi\n}\n\n# Execute the check for /etc/shadow-\ncheck_permissions_shadow_minus\n', '#!/bin/bash\n\n# Function to check permissions on /etc/shadow-\ncheck_permissions_shadow_minus() {\nlocal file="/etc/shadow-"\nlocal expected_permissions="600"\nlocal expected_owner="root"\nlocal expected_group="root"\n\n# Get the current permissions, owner, and group\ncurrent_permissions=$(stat -c "%a" "$file" 2>/dev/null)\ncurrent_owner=$(stat -c "%U" "$file")\ncurrent_group=$(stat -c "%G" "$file")\n\n# Check if the permissions and ownership are correct\nif [[ "$current_permissions" == "$expected_permissions" && "$current_owner" == "$expected_owner" && "$current_group" == "$expected_group" ]]; then\necho "Check: Ensure permissions on $file are configured"\necho "Status: Pass"\necho "Current Value: Permissions on $file are $current_permissions, owned by $current_owner:$current_group."\necho "Expected Value: Permissions should be $expected_permissions with owner $expected_owner and group $expected_group."\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure permissions on $file are configured"\necho "Status: Fail"\necho "Current Value: Permissions on $file are $current_permissions, owned by $current_owner:$current_group."\necho "Expected Value: Permissions should be $expected_permissions with owner $expected_owner and group $expected_group."\necho "Recommendation: Correct the permissions and ownership."\necho "Remediation:"\necho "# sudo chmod $expected_permissions $file"\necho "# sudo chown $expected_owner:$expected_group $file"\nfi\n}\n\n# Execute the check for /etc/shadow-\ncheck_permissions_shadow_minus\n', '#!/bin/bash\n\n# Function to check permissions on /etc/shadow-\ncheck_permissions_shadow_minus() {\nlocal file="/etc/shadow-"\nlocal expected_permissions="600"\nlocal expected_owner="root"\nlocal expected_group="root"\n\n# Get the current permissions, owner, and group\ncurrent_permissions=$(stat -c "%a" "$file" 2>/dev/null)\ncurrent_owner=$(stat -c "%U" "$file")\ncurrent_group=$(stat -c "%G" "$file")\n\n# Check if the permissions and ownership are correct\nif [[ "$current_permissions" == "$expected_permissions" && "$current_owner" == "$expected_owner" && "$current_group" == "$expected_group" ]]; then\necho "Check: Ensure permissions on $file are configured"\necho "Status: Pass"\necho "Current Value: Permissions on $file are $current_permissions, owned by $current_owner:$current_group."\necho "Expected Value: Permissions should be $expected_permissions with owner $expected_owner and group $expected_group."\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure permissions on $file are configured"\necho "Status: Fail"\necho "Current Value: Permissions on $file are $current_permissions, owned by $current_owner:$current_group."\necho "Expected Value: Permissions should be $expected_permissions with owner $expected_owner and group $expected_group."\necho "Recommendation: Correct the permissions and ownership."\necho "Remediation:"\necho "# sudo chmod $expected_permissions $file"\necho "# sudo chown $expected_owner:$expected_group $file"\nfi\n}\n\n# Execute the check for /etc/shadow-\ncheck_permissions_shadow_minus\n', '#!/bin/bash\n\n# Function to check if any world writable files exist\ncheck_world_writable_files() {\nlocal directory="/"\nlocal expected_permissions="777"\nlocal expected_owner="root"\nlocal expected_group="root"\n\n# Check for world writable files\nworld_writable_files=$(find "$directory" -type f -perm -0002 -exec stat -c "%a %U %G %n" {} \\\\;)\n\nif [[ -z "$world_writable_files" ]]; then\necho "Check: Ensure no world writable files exist"\necho "Status: Pass"\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure no world writable files exist"\necho "Status: Fail"\necho "Recommendation: Correct the permissions on world writable files."\necho "Remediation:"\necho "# sudo chmod o-w <file>"\nfi\n}\n\n# Execute the check for world writable files\ncheck_world_writable_files\n', '#!/bin/bash\n\n# Function to check for unowned files or directories\ncheck_unowned_files() {\nlocal directory="/"\n\n# Find unowned files or directories\nunowned_files=$(find "$directory" -nouser)\n\nif [[ -z "$unowned_files" ]]; then\necho "Check: Ensure no unowned files or directories exist"\necho "Status: Pass"\necho "Current Value: No unowned files or directories found."\necho "Expected Value: No unowned files or directories should exist."\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure no unowned files or directories exist"\necho "Status: Fail"\necho "Current Value: Unowned files or directories found."\necho "Expected Value: No unowned files or directories should exist."\necho "Recommendation: Assign proper ownership to unowned files."\necho "Remediation:"\necho "# sudo chown <owner> <file>"\nfi\n}\n\n# Execute the check for unowned files\ncheck_unowned_files\n', '#!/bin/bash\n\n# Function to check for ungrouped files or directories\ncheck_ungrouped_files() {\nlocal directory="/"\n\n# Find ungrouped files or directories\nungrouped_files=$(find "$directory" -nogroup)\n\nif [[ -z "$ungrouped_files" ]]; then\necho "Check: Ensure no ungrouped files or directories exist"\necho "Status: Pass"\necho "Current Value: No ungrouped files or directories found."\necho "Expected Value: No ungrouped files or directories should exist."\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure no ungrouped files or directories exist"\necho "Status: Fail"\necho "Current Value: Ungrouped files or directories found."\necho "Expected Value: No ungrouped files or directories should exist."\necho "Recommendation: Assign proper group to ungrouped files."\necho "Remediation:"\necho "# sudo chgrp <group> <file>"\nfi\n}\n\n# Execute the check for ungrouped files\ncheck_ungrouped_files\n', '#!/bin/bash\n\n# Function to check if sticky bit is set on world-writable directories\ncheck_sticky_bit() {\nlocal directory="/"\n\n# Find world-writable directories without sticky bit\nnon_sticky_world_writable_dirs=$(find "$directory" -type d -perm -0002 ! -perm -1000)\n\nif [[ -z "$non_sticky_world_writable_dirs" ]]; then\necho "Check: Ensure sticky bit is set on all world-writable directories"\necho "Status: Pass"\necho "Current Value: Sticky bit set on all world-writable directories."\necho "Expected Value: Sticky bit should be set on all world-writable directories."\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure sticky bit is set on all world-writable directories"\necho "Status: Fail"\necho "Current Value: Sticky bit not set on some world-writable directories."\necho "Expected Value: Sticky bit should be set on all world-writable directories."\necho "Recommendation: Set sticky bit on world-writable directories."\necho "Remediation:"\necho "# sudo chmod +t <directory>"\nfi\n}\n\n# Execute the check for sticky bit\ncheck_sticky_bit\n', '#!/bin/bash\n\n# Function to audit SUID executables\naudit_suid_executables() {\nlocal directory="/"\n\n# Find SUID executables\nsuid_executables=$(find "$directory" -type f -perm -4000 -exec stat -c "%a %U %G %n" {} \\\\;)\n\nif [[ -z "$suid_executables" ]]; then\necho "Check: Audit SUID executables"\necho "Status: Pass"\necho "Current Value: No SUID executables found."\necho "Expected Value: No unnecessary SUID executables should exist."\necho "Recommendation: No remediation required."\nelse\necho "Check: Audit SUID executables"\necho "Status: Fail"\necho "Current Value: SUID executables found."\necho "Expected Value: No unnecessary SUID executables should exist."\necho "Recommendation: Review and remove unnecessary SUID executables."\necho "Remediation:"\necho "# sudo chmod u-s <file>"\nfi\n}\n\n# Execute the check for SUID executables\naudit_suid_executables\n', '#!/bin/bash\n\n# Function to audit SGID executables\naudit_sgid_executables() {\nlocal directory="/"\n\n# Find SGID executables\nsgid_executables=$(find "$directory" -type f -perm -2000 -exec stat -c "%a %U %G %n" {} \\\\;)\n\nif [[ -z "$sgid_executables" ]]; then\necho "Check: Audit SGID executables"\necho "Status: Pass"\necho "Current Value: No SGID executables found."\necho "Expected Value: No unnecessary SGID executables should exist."\necho "Recommendation: No remediation required."\nelse\necho "Check: Audit SGID executables"\necho "Status: Fail"\necho "Current Value: SGID executables found."\necho "Expected Value: No unnecessary SGID executables should exist."\necho "Recommendation: Review and remove unnecessary SGID executables."\necho "Remediation:"\necho "# sudo chmod g-s <file>"\nfi\n}\n\n# Execute the check for SGID executables\naudit_sgid_executables\n', '#!/bin/bash\n\n# Function to audit system file permissions\naudit_system_file_permissions() {\nlocal system_files=("/etc/passwd" "/etc/shadow" "/etc/group")\nlocal overall_status="Pass" # Start assuming pass\nlocal failure_message=""\n\n# Check permissions of system files\nfor file in "${system_files[@]}"; do\ncurrent_permissions=$(stat -c "%a" "$file")\nexpected_permissions="644"\n\nif [[ "$current_permissions" != "$expected_permissions" ]]; then\n# If any file fails, update status and store failure message\noverall_status="Fail"\nfailure_message+="$file has permissions $current_permissions. Expected permissions: $expected_permissions.\\\n"\nfi\ndone\n\n# Print results once\necho "Check: Audit system file permissions"\necho "Status: $overall_status"\n\n# If any failure occurred, print the current and expected values, and the recommendation\nif [[ "$overall_status" == "Fail" ]]; then\necho -e "Current Value: $failure_message"\necho "Expected Value: Permissions should be $expected_permissions."\necho "Recommendation: Correct the permissions of the above files."\necho "Remediation:"\necho "# sudo chmod $expected_permissions <file>"\nelse\necho "Current Value: All files have correct permissions."\necho "Expected Value: Permissions should be $expected_permissions."\necho "Recommendation: No remediation required."\nfi\n}\n\n# Execute the check for system file permissions\naudit_system_file_permissions\n', '#!/bin/bash\n\n# Function to check if accounts in /etc/passwd use shadowed passwords\ncheck_shadowed_passwords() {\n    # Use awk to find accounts without shadowed passwords\n    local non_shadowed_accounts\n    non_shadowed_accounts=$(awk -F: \'($2 == "") {print $1}\' /etc/passwd)\n\n    if [[ -z "$non_shadowed_accounts" ]]; then\n        echo "Check: Ensure accounts in /etc/passwd use shadowed passwords"\n        echo "Status: Pass"\n        echo "Current Value: All accounts have shadowed passwords."\n        echo "Expected Value: All accounts should use shadowed passwords."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure accounts in /etc/passwd use shadowed passwords"\n        echo "Status: Fail"\n        echo "Current Value: Found accounts without shadowed passwords: $non_shadowed_accounts"\n        echo "Expected Value: All accounts should use shadowed passwords."\n        echo "Recommendation: Use the shadowed password file for these accounts."\n        echo "Remediation:"\n        echo "# sudo passwd -l $non_shadowed_accounts"\n    fi\n}\n\n# Execute the check\ncheck_shadowed_passwords\n', '#!/bin/bash\n\n# Function to check if /etc/shadow password fields are empty\ncheck_shadow_password_fields() {\n# Check if /etc/shadow exists and is readable\nif [[ ! -r /etc/shadow ]]; then\necho "Check: Ensure /etc/shadow password fields are not empty"\necho "Status: Fail"\necho "Current Value: Unable to access /etc/shadow."\necho "Expected Value: /etc/shadow should be readable."\necho "Recommendation: Check file permissions or ensure the file exists."\necho "Remediation:"\necho "# sudo chmod 640 /etc/shadow"\necho "# sudo chown root:shadow /etc/shadow"\nexit 1\nfi\n\n# Check for empty password fields in /etc/shadow\nlocal empty_shadow_passwords=$(awk -F: \\\'($2 == "") {print $1}\\\' /etc/shadow)\n\nif [[ -z "$empty_shadow_passwords" ]]; then\necho "Check: Ensure /etc/shadow password fields are not empty"\necho "Status: Pass"\necho "Current Value: No empty password fields in /etc/shadow."\necho "Expected Value: All accounts should have a non-empty password field in /etc/shadow."\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure /etc/shadow password fields are not empty"\necho "Status: Fail"\necho "Current Value: Found empty password fields for users: $empty_shadow_passwords"\necho "Expected Value: All accounts should have a non-empty password field in /etc/shadow."\necho "Recommendation: Set a password for these accounts."\necho "Remediation:"\nwhile read -r user; do\necho "# sudo passwd $user"\ndone <<< "$empty_shadow_passwords"\nfi\n}\n\n# Execute the check\ncheck_shadow_password_fields\n', '#!/bin/bash\n\n# Function to ensure all groups in /etc/passwd exist in /etc/group\ncheck_groups_in_passwd_exist_in_group() {\n# Check if /etc/passwd and /etc/group are readable\nif [[ ! -r /etc/passwd || ! -r /etc/group ]]; then\necho "Check: Ensure all groups in /etc/passwd exist in /etc/group"\necho "Status: Fail"\necho "Current Value: Unable to read /etc/passwd or /etc/group."\necho "Expected Value: Both /etc/passwd and /etc/group should be readable."\necho "Recommendation: Check file permissions."\nexit 1\nfi\n\n# Get the list of groups from /etc/passwd that are not in /etc/group\nlocal missing_groups=$(awk -F: \\\'{print $4}\\\' /etc/passwd | sort -u | while read group; do\ngrep -q "^$group:" /etc/group || echo $group\ndone)\n\nif [[ -z "$missing_groups" ]]; then\necho "Check: Ensure all groups in /etc/passwd exist in /etc/group"\necho "Status: Pass"\necho "Current Value: All groups in /etc/passwd exist in /etc/group."\necho "Expected Value: All groups in /etc/passwd should exist in /etc/group."\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure all groups in /etc/passwd exist in /etc/group"\necho "Status: Fail"\necho "Current Value: Missing groups in /etc/group: $missing_groups"\necho "Expected Value: All groups in /etc/passwd should exist in /etc/group."\necho "Recommendation: Add the missing groups to /etc/group."\necho "Remediation:"\necho "# sudo groupadd <group_name>"\nfi\n}\n\n# Execute the check\ncheck_groups_in_passwd_exist_in_group\n', '#!/bin/bash\n\n# Function to ensure no duplicate UIDs exist in /etc/passwd\ncheck_duplicate_uids() {\n# Check if /etc/passwd is readable\nif [[ ! -r /etc/passwd ]]; then\necho "Check: Ensure no duplicate UIDs exist"\necho "Status: Fail"\necho "Current Value: Unable to read /etc/passwd."\necho "Expected Value: /etc/passwd should be readable."\necho "Recommendation: Check file permissions."\nexit 1\nfi\n\n# Check for duplicate UIDs\nlocal duplicate_uids=$(awk -F: \\\'{print $3}\\\' /etc/passwd | sort | uniq -d)\n\nif [[ -z "$duplicate_uids" ]]; then\necho "Check: Ensure no duplicate UIDs exist"\necho "Status: Pass"\necho "Current Value: No duplicate UIDs found in /etc/passwd."\necho "Expected Value: No duplicate UIDs should exist."\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure no duplicate UIDs exist"\necho "Status: Fail"\necho "Current Value: Found duplicate UIDs: $duplicate_uids"\necho "Expected Value: No duplicate UIDs should exist."\necho "Recommendation: Resolve the duplicate UIDs by changing them to unique values."\necho "Remediation:"\necho "# sudo usermod -u <new_uid> <username>"\nfi\n}\n\n# Execute the check\ncheck_duplicate_uids\n', '#!/bin/bash\n\n# Function to ensure no duplicate GIDs exist in /etc/group\ncheck_duplicate_gids() {\n# Check if /etc/group is readable\nif [[ ! -r /etc/group ]]; then\necho "Check: Ensure no duplicate GIDs exist"\necho "Status: Fail"\necho "Current Value: Unable to read /etc/group."\necho "Expected Value: /etc/group should be readable."\necho "Recommendation: Check file permissions."\nexit 1\nfi\n\n# Check for duplicate GIDs\nlocal duplicate_gids=$(awk -F: \\\'{print $3}\\\' /etc/group | sort | uniq -d)\n\nif [[ -z "$duplicate_gids" ]]; then\necho "Check: Ensure no duplicate GIDs exist"\necho "Status: Pass"\necho "Current Value: No duplicate GIDs found in /etc/group."\necho "Expected Value: No duplicate GIDs should exist."\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure no duplicate GIDs exist"\necho "Status: Fail"\necho "Current Value: Found duplicate GIDs: $duplicate_gids"\necho "Expected Value: No duplicate GIDs should exist."\necho "Recommendation: Resolve the duplicate GIDs by changing them to unique values."\necho "Remediation:"\necho "# sudo groupmod -g <new_gid> <groupname>"\nfi\n}\n\n# Execute the check\ncheck_duplicate_gids\n', '#!/bin/bash\n\n# Function to ensure no duplicate usernames exist in /etc/passwd\ncheck_duplicate_usernames() {\n# Check if /etc/passwd is readable\nif [[ ! -r /etc/passwd ]]; then\necho "Check: Ensure no duplicate usernames exist"\necho "Status: Fail"\necho "Current Value: Unable to read /etc/passwd."\necho "Expected Value: /etc/passwd should be readable."\necho "Recommendation: Check file permissions."\nexit 1\nfi\n\n# Check for duplicate usernames\nlocal duplicate_usernames=$(awk -F: \\\'{print $1}\\\' /etc/passwd | sort | uniq -d)\n\nif [[ -z "$duplicate_usernames" ]]; then\necho "Check: Ensure no duplicate usernames exist"\necho "Status: Pass"\necho "Current Value: No duplicate usernames found in /etc/passwd."\necho "Expected Value: No duplicate usernames should exist."\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure no duplicate usernames exist"\necho "Status: Fail"\necho "Current Value: Found duplicate usernames: $duplicate_usernames"\necho "Expected Value: No duplicate usernames should exist."\necho "Recommendation: Resolve the duplicate usernames by changing them to unique names."\necho "Remediation:"\necho "# sudo usermod -l <new_username> <old_username>"\nfi\n}\n\n# Execute the check\ncheck_duplicate_usernames\n', '#!/bin/bash\n\n# Function to ensure no duplicate group names exist in /etc/group\ncheck_duplicate_groupnames() {\n# Check if /etc/group is readable\nif [[ ! -r /etc/group ]]; then\necho "Check: Ensure no duplicate group names exist"\necho "Status: Fail"\necho "Current Value: Unable to read /etc/group."\necho "Expected Value: /etc/group should be readable."\necho "Recommendation: Check file permissions."\nexit 1\nfi\n\n# Check for duplicate group names\nlocal duplicate_groupnames=$(awk -F: \\\'{print $1}\\\' /etc/group | sort | uniq -d)\n\nif [[ -z "$duplicate_groupnames" ]]; then\necho "Check: Ensure no duplicate group names exist"\necho "Status: Pass"\necho "Current Value: No duplicate group names found in /etc/group."\necho "Expected Value: No duplicate group names should exist."\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure no duplicate group names exist"\necho "Status: Fail"\necho "Current Value: Found duplicate group names: $duplicate_groupnames"\necho "Expected Value: No duplicate group names should exist."\necho "Recommendation: Resolve the duplicate group names by changing them to unique names."\necho "Remediation:"\necho "# sudo groupmod -n <new_group_name> <old_group_name>"\nfi\n}\n\n# Execute the check\ncheck_duplicate_groupnames\n', '#!/bin/bash\n\n# Function to ensure root PATH integrity\ncheck_root_path_integrity() {\n# Check if the user is root\nif [[ $(id -u) -ne 0 ]]; then\necho "Check: Ensure root PATH Integrity"\necho "Status: Fail"\necho "Current Value: This script must be run as root."\necho "Expected Value: The script should be run by root."\necho "Recommendation: Run the script as root."\nexit 1\nfi\n\n# Get the current root PATH\nlocal root_path=$(echo $PATH)\n\n# Define the expected root PATH (you may modify this to fit your system)\nlocal expected_path="/usr/sbin:/usr/bin:/sbin:/bin"\n\n# Check if the root PATH matches the expected integrity\nif [[ "$root_path" == "$expected_path" ]]; then\necho "Check: Ensure root PATH Integrity"\necho "Status: Pass"\necho "Current Value: Root PATH integrity is intact."\necho "Expected Value: Root PATH should only contain trusted directories."\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure root PATH Integrity"\necho "Status: Fail"\necho "Current Value: Root PATH is not secure: $root_path"\necho "Expected Value: Root PATH should only contain trusted directories."\necho "Recommendation: Modify the PATH variable to ensure root\\\'s PATH is secure."\necho "Remediation:"\necho "# sudo echo \\\'export PATH=/usr/sbin:/usr/bin:/sbin:/bin\\\' >> /etc/profile"\nfi\n}\n\n# Execute the check\ncheck_root_path_integrity\n', '#!/bin/bash\n\n# Function to ensure root is the only UID 0 account\ncheck_root_only_uid_0() {\n# Check if /etc/passwd is readable\nif [[ ! -r /etc/passwd ]]; then\necho "Check: Ensure root is the only UID 0 account"\necho "Status: Fail"\necho "Current Value: Unable to read /etc/passwd."\necho "Expected Value: /etc/passwd should be readable."\necho "Recommendation: Check file permissions."\nexit 1\nfi\n\n# Check for UID 0 accounts other than root\nlocal non_root_uid_0=$(awk -F: \\\'$3 == 0 && $1 != "root" {print $1}\\\' /etc/passwd)\n\nif [[ -z "$non_root_uid_0" ]]; then\necho "Check: Ensure root is the only UID 0 account"\necho "Status: Pass"\necho "Current Value: Only root has UID 0."\necho "Expected Value: Only root should have UID 0."\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure root is the only UID 0 account"\necho "Status: Fail"\necho "Current Value: Found non-root users with UID 0: $non_root_uid_0"\necho "Expected Value: Only root should have UID 0."\necho "Recommendation: Change the UID for non-root users to another value."\necho "Remediation:"\necho "# sudo usermod -u <new_uid> <username>"\nfi\n}\n\n# Execute the check\ncheck_root_only_uid_0\n', '#!/bin/bash\n\n# Function to ensure local interactive user home directories exist\ncheck_user_home_directories() {\n    # Check if /etc/passwd is readable\n    if [[ ! -r /etc/passwd ]]; then\n        echo "Check: Ensure local interactive user home directories exist"\n        echo "Status: Fail"\n        echo "Current Value: Unable to read /etc/passwd."\n        echo "Expected Value: /etc/passwd should be readable."\n        echo "Recommendation: Check file permissions."\n        exit 1\n    fi\n\n    # Check for users with missing home directories\n    local missing_home_dirs\n    missing_home_dirs=$(awk -F: \'\n    $7 == "/bin/bash" && $6 == "" {\n        print $1\n    }\' /etc/passwd)\n\n    if [[ -z "$missing_home_dirs" ]]; then\n        echo "Check: Ensure local interactive user home directories exist"\n        echo "Status: Pass"\n        echo "Current Value: All local interactive users have home directories."\n        echo "Expected Value: All local interactive users should have home directories."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure local interactive user home directories exist"\n        echo "Status: Fail"\n        echo "Current Value: Found local interactive users without home directories:"\n        echo "$missing_home_dirs"\n        echo "Expected Value: Local interactive users should have home directories."\n        echo "Recommendation: Create home directories for these users."\n        echo "Remediation:"\n        while read -r user; do\n            echo "# sudo usermod -m -d /home/$user $user"\n        done <<< "$missing_home_dirs"\n    fi\n}\n\n# Execute the check\ncheck_user_home_directories\n', '#!/bin/bash\n\n# Function to ensure local interactive users own their home directories\ncheck_user_home_ownership() {\n    # Check if /etc/passwd is readable\n    if [[ ! -r /etc/passwd ]]; then\n        echo "Check: Ensure local interactive users own their home directories"\n        echo "Status: Fail"\n        echo "Current Value: Unable to read /etc/passwd."\n        echo "Expected Value: /etc/passwd should be readable."\n        echo "Recommendation: Check file permissions."\n        exit 1\n    fi\n\n    # Check for home directory ownership\n    local misowned_dirs\n    misowned_dirs=$(awk -F: \'\n    $7 == "/bin/bash" {\n        if ($6 != "" && $6 != ("/home/" $1)) {\n            print $1, $6\n        }\n    }\' /etc/passwd)\n\n    if [[ -z "$misowned_dirs" ]]; then\n        echo "Check: Ensure local interactive users own their home directories"\n        echo "Status: Pass"\n        echo "Current Value: All local interactive users own their home directories."\n        echo "Expected Value: Local interactive users should own their home directories."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure local interactive users own their home directories"\n        echo "Status: Fail"\n        echo "Current Value: Found misowned home directories:"\n        echo "$misowned_dirs"\n        echo "Expected Value: Local interactive users should own their home directories."\n        echo "Recommendation: Change the ownership to the respective user."\n        echo "Remediation:"\n        while read -r user dir; do\n            echo "# sudo chown $user:$user $dir"\n        done <<< "$misowned_dirs"\n    fi\n}\n\n# Execute the check\ncheck_user_home_ownership\n', '#!/bin/bash\n\n# Function to ensure local interactive user home directories are mode 750 or more restrictive\ncheck_home_directory_permissions() {\n# Check if /etc/passwd is readable\nif [[ ! -r /etc/passwd ]]; then\necho "Check: Ensure local interactive user home directories are mode 750 or more restrictive"\necho "Status: Fail"\necho "Current Value: Unable to read /etc/passwd."\necho "Expected Value: /etc/passwd should be readable."\necho "Recommendation: Check file permissions."\nexit 1\nfi\n\n# Iterate over each interactive user and check their home directory permissions\nlocal insecure_home_dirs=""\nwhile IFS=: read -r username _ _ _ _ home_dir shell; do\nif [[ "$shell" == "/bin/bash" && -d "$home_dir" ]]; then\ndir_permissions=$(stat -c "%a" "$home_dir")\nif [[ "$dir_permissions" -lt 750 ]]; then\ninsecure_home_dirs+="$username\\\'s home directory ($home_dir) has permissions: $dir_permissions\\\n"\nfi\nfi\ndone < /etc/passwd\n\nif [[ -z "$insecure_home_dirs" ]]; then\necho "Check: Ensure local interactive user home directories are mode 750 or more restrictive"\necho "Status: Pass"\necho "Current Value: All local interactive user home directories have mode 750 or more restrictive."\necho "Expected Value: Local interactive user home directories should have mode 750 or more restrictive."\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure local interactive user home directories are mode 750 or more restrictive"\necho "Status: Fail"\necho -e "Current Value: Found home directories with insecure permissions:\\\n$insecure_home_dirs"\necho "Expected Value: Home directories should be mode 750 or more restrictive."\necho "Recommendation: Set home directory permissions to 750 or more restrictive."\necho "Remediation:"\necho "# sudo chmod 750 <home_directory>"\nfi\n}\n\n# Execute the check\ncheck_home_directory_permissions\n', '#!/bin/bash\n\n# Function to check if any local interactive user has .netrc files\ncheck_netrc_files() {\nlocal users_with_netrc=$(find /home -type f -name ".netrc" 2>/dev/null)\n\nif [[ -z "$users_with_netrc" ]]; then\necho "Check: Ensure no local interactive user has .netrc files"\necho "Status: Pass"\necho "Current Value: No .netrc files found."\necho "Expected Value: Local interactive users should not have .netrc files."\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure no local interactive user has .netrc files"\necho "Status: Fail"\necho "Current Value: Found .netrc files: $users_with_netrc"\necho "Expected Value: Local interactive users should not have .netrc files."\necho "Recommendation: Remove the .netrc files."\necho "Remediation:"\necho "# sudo rm -f $users_with_netrc"\nfi\n}\n\n# Execute the check\ncheck_netrc_files\n', '#!/bin/bash\n\n# Function to check if any local interactive user has .forward files\ncheck_forward_files() {\nlocal users_with_forward=$(find /home -type f -name ".forward" 2>/dev/null)\n\nif [[ -z "$users_with_forward" ]]; then\necho "Check: Ensure no local interactive user has .forward files"\necho "Status: Pass"\necho "Current Value: No .forward files found."\necho "Expected Value: Local interactive users should not have .forward files."\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure no local interactive user has .forward files"\necho "Status: Fail"\necho "Current Value: Found .forward files: $users_with_forward"\necho "Expected Value: Local interactive users should not have .forward files."\necho "Recommendation: Remove the .forward files."\necho "Remediation:"\necho "# sudo rm -f $users_with_forward"\nfi\n}\n\n# Execute the check\ncheck_forward_files\n', '#!/bin/bash\n\n# Function to check if any local interactive user has .rhosts files\ncheck_rhosts_files() {\nlocal users_with_rhosts=$(find /home -type f -name ".rhosts" 2>/dev/null)\n\nif [[ -z "$users_with_rhosts" ]]; then\necho "Check: Ensure no local interactive user has .rhosts files"\necho "Status: Pass"\necho "Current Value: No .rhosts files found."\necho "Expected Value: Local interactive users should not have .rhosts files."\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure no local interactive user has .rhosts files"\necho "Status: Fail"\necho "Current Value: Found .rhosts files: $users_with_rhosts"\necho "Expected Value: Local interactive users should not have .rhosts files."\necho "Recommendation: Remove the .rhosts files."\necho "Remediation:"\necho "# sudo rm -f $users_with_rhosts"\nfi\n}\n\n# Execute the check\ncheck_rhosts_files\n', '#!/bin/bash\n\n# Function to check if local interactive user dot files are not group or world writable\ncheck_dot_files_permissions() {\nlocal insecure_dot_files=""\n\n# Check for all dot files in user home directories\nwhile IFS=: read -r username _ _ _ _ home_dir shell; do\nif [[ "$shell" == "/bin/bash" && -d "$home_dir" ]]; then\nfor dot_file in "$home_dir"/.*; do\nif [[ -e "$dot_file" && ! -d "$dot_file" ]]; then\nfile_permissions=$(stat -c "%a" "$dot_file")\nif [[ "$file_permissions" -gt 755 ]]; then\ninsecure_dot_files+="$username\\\'s dot file ($dot_file) has permissions: $file_permissions\\\n"\nfi\nfi\ndone\nfi\ndone < /etc/passwd\n\nif [[ -z "$insecure_dot_files" ]]; then\necho "Check: Ensure local interactive user dot files are not group or world writable"\necho "Status: Pass"\necho "Current Value: No dot files are group or world writable."\necho "Expected Value: Dot files should not be group or world writable."\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure local interactive user dot files are not group or world writable"\necho "Status: Fail"\necho -e "Current Value: Found dot files with insecure permissions:\\\n$insecure_dot_files"\necho "Expected Value: Dot files should not be group or world writable."\necho "Recommendation: Set the file permissions to 644 or 600."\necho "Remediation:"\necho "# sudo chmod 644 <dot_file>"\nfi\n}\n\n# Execute the check\ncheck_dot_files_permissions\n', '#!/bin/bash\n\n# Check if the cron service is enabled\nif systemctl is-enabled cron >/dev/null 2>&1; then\necho "Check: Ensure cron daemon is enabled"\necho "Status: Pass"\necho "Current Value: Cron daemon is enabled"\necho "Recommendation: No action needed"\nelse\necho "Check: Ensure cron daemon is enabled"\necho "Status: Fail"\necho "Current Value: Cron daemon is not enabled"\necho "Recommendation: Enable the cron daemon"\necho "Remediation: sudo systemctl enable cron && sudo systemctl start cron"\nfi\n', '#!/bin/bash\n\ncrontab_file="/etc/crontab"\n\n# Check permissions of /etc/crontab\npermissions=$(stat -c "%a" "$crontab_file" 2>/dev/null)\nif [[ "$permissions" == "600" ]]; then\necho "Check: Ensure permissions on /etc/crontab are configured"\necho "Status: Pass"\necho "Current Value: Permissions are set to $permissions"\necho "Recommendation: No action needed"\nelse\necho "Check: Ensure permissions on /etc/crontab are configured"\necho "Status: Fail"\necho "Current Value: Permissions are set to $permissions"\necho "Recommendation: Set permissions to 600"\necho "Remediation: sudo chmod 600 $crontab_file"\nfi\n', '#!/bin/bash\n\n# Define cron directories to check\ncron_dirs=("/etc/cron.hourly" "/etc/cron.daily" "/etc/cron.weekly" "/etc/cron.monthly" "/etc/cron.d")\n\nfor dir in "${cron_dirs[@]}"; do\n# Check permissions of the directory\npermissions=$(stat -c "%a" "$dir" 2>/dev/null)\nif [[ "$permissions" == "700" ]]; then\necho "Check: Ensure permissions on $dir are configured"\necho "Status: Pass"\necho "Current Value: Permissions are set to $permissions"\necho "Recommendation: No action needed"\nelse\necho "Check: Ensure permissions on $dir are configured"\necho "Status: Fail"\necho "Current Value: Permissions are set to $permissions"\necho "Recommendation: Set permissions to 700"\necho "Remediation: sudo chmod 700 $dir"\nfi\ndone\n', '#!/bin/bash\n\n# Define cron directories to check\ncron_dirs=("/etc/cron.hourly" "/etc/cron.daily" "/etc/cron.weekly" "/etc/cron.monthly" "/etc/cron.d")\n\nfor dir in "${cron_dirs[@]}"; do\n# Check permissions of the directory\npermissions=$(stat -c "%a" "$dir" 2>/dev/null)\nif [[ "$permissions" == "700" ]]; then\necho "Check: Ensure permissions on $dir are configured"\necho "Status: Pass"\necho "Current Value: Permissions are set to $permissions"\necho "Recommendation: No action needed"\nelse\necho "Check: Ensure permissions on $dir are configured"\necho "Status: Fail"\necho "Current Value: Permissions are set to $permissions"\necho "Recommendation: Set permissions to 700"\necho "Remediation: sudo chmod 700 $dir"\nfi\ndone\n', '#!/bin/bash\n\n# Define cron directories to check\ncron_dirs=("/etc/cron.hourly" "/etc/cron.daily" "/etc/cron.weekly" "/etc/cron.monthly" "/etc/cron.d")\n\nfor dir in "${cron_dirs[@]}"; do\n# Check permissions of the directory\npermissions=$(stat -c "%a" "$dir" 2>/dev/null)\nif [[ "$permissions" == "700" ]]; then\necho "Check: Ensure permissions on $dir are configured"\necho "Status: Pass"\necho "Current Value: Permissions are set to $permissions"\necho "Recommendation: No action needed"\nelse\necho "Check: Ensure permissions on $dir are configured"\necho "Status: Fail"\necho "Current Value: Permissions are set to $permissions"\necho "Recommendation: Set permissions to 700"\necho "Remediation: sudo chmod 700 $dir"\nfi\ndone\n', '#!/bin/bash\n\n# Define cron directories to check\ncron_dirs=("/etc/cron.hourly" "/etc/cron.daily" "/etc/cron.weekly" "/etc/cron.monthly" "/etc/cron.d")\n\nfor dir in "${cron_dirs[@]}"; do\n# Check permissions of the directory\npermissions=$(stat -c "%a" "$dir" 2>/dev/null)\nif [[ "$permissions" == "700" ]]; then\necho "Check: Ensure permissions on $dir are configured"\necho "Status: Pass"\necho "Current Value: Permissions are set to $permissions"\necho "Recommendation: No action needed"\nelse\necho "Check: Ensure permissions on $dir are configured"\necho "Status: Fail"\necho "Current Value: Permissions are set to $permissions"\necho "Recommendation: Set permissions to 700"\necho "Remediation: sudo chmod 700 $dir"\nfi\ndone\n', '#!/bin/bash\n\n# Define cron directories to check\ncron_dirs=("/etc/cron.hourly" "/etc/cron.daily" "/etc/cron.weekly" "/etc/cron.monthly" "/etc/cron.d")\n\nfor dir in "${cron_dirs[@]}"; do\n# Check permissions of the directory\npermissions=$(stat -c "%a" "$dir" 2>/dev/null)\nif [[ "$permissions" == "700" ]]; then\necho "Check: Ensure permissions on $dir are configured"\necho "Status: Pass"\necho "Current Value: Permissions are set to $permissions"\necho "Recommendation: No action needed"\nelse\necho "Check: Ensure permissions on $dir are configured"\necho "Status: Fail"\necho "Current Value: Permissions are set to $permissions"\necho "Recommendation: Set permissions to 700"\necho "Remediation: sudo chmod 700 $dir"\nfi\ndone\n', '#!/bin/bash\n\ncron_allow="/etc/cron.allow"\ncron_deny="/etc/cron.deny"\n\n# Check if cron.allow exists and is configured\nif [[ -f "$cron_allow" ]]; then\necho "Check: Ensure cron is restricted to authorized users"\necho "Status: Pass"\necho "Current Value: $cron_allow exists"\necho "Recommendation: No action needed"\nelse\necho "Check: Ensure cron is restricted to authorized users"\necho "Status: Fail"\necho "Current Value: $cron_allow does not exist"\necho "Recommendation: Create and configure $cron_allow"\necho "Remediation: sudo touch $cron_allow && sudo chmod 600 $cron_allow"\nfi\n\n# Check if cron.deny exists and is empty\nif [[ -f "$cron_deny" && ! -s "$cron_deny" ]]; then\necho "Check: Ensure cron.deny is empty"\necho "Status: Pass"\necho "Current Value: $cron_deny exists and is empty"\necho "Recommendation: No action needed"\nelse\necho "Check: Ensure cron.deny is empty"\necho "Status: Fail"\necho "Current Value: $cron_deny exists and is not empty"\necho "Recommendation: Empty the $cron_deny file"\necho "Remediation: sudo > $cron_deny"\nfi\n', '#!/bin/bash\n\nat_allow="/etc/at.allow"\nat_deny="/etc/at.deny"\n\n# Check if at.allow exists and is configured\nif [[ -f "$at_allow" ]]; then\necho "Check: Ensure at is restricted to authorized users"\necho "Status: Pass"\necho "Current Value: $at_allow exists"\necho "Recommendation: No action needed"\nelse\necho "Check: Ensure at is restricted to authorized users"\necho "Status: Fail"\necho "Current Value: $at_allow does not exist"\necho "Recommendation: Create and configure $at_allow"\necho "Remediation: sudo touch $at_allow && sudo chmod 600 $at_allow"\nfi\n\n# Check if at.deny exists and is empty\nif [[ -f "$at_deny" && ! -s "$at_deny" ]]; then\necho "Check: Ensure at.deny is empty"\necho "Status: Pass"\necho "Current Value: $at_deny exists and is empty"\necho "Recommendation: No action needed"\nelse\necho "Check: Ensure at.deny is empty"\necho "Status: Fail"\necho "Current Value: $at_deny exists and is not empty"\necho "Recommendation: Empty the $at_deny file"\necho "Remediation: sudo > $at_deny"\nfi\n', '#!/bin/bash\n\nfile="/etc/ssh/sshd_config"\n\n# Check permissions\npermissions=$(stat -c "%a" "$file")\nif [[ "$permissions" == "600" ]]; then\necho "Check: Ensure permissions on $file are configured"\necho "Status: Pass"\necho "Current Value: $permissions"\nelse\necho "Check: Ensure permissions on $file are configured"\necho "Status: Fail"\necho "Current Value: $permissions"\necho "Recommendation: Set permissions to 600"\necho "Remediation: sudo chmod 600 $file"\nfi\n', '#!/bin/bash\n\n# List private host key files\nprivate_keys=$(find /etc/ssh -name \\\'ssh_host_*_key\\\')\n\nfor key in $private_keys; do\npermissions=$(stat -c "%a" "$key")\nif [[ "$permissions" == "600" ]]; then\necho "Check: Ensure permissions on $key are configured"\necho "Status: Pass"\necho "Current Value: $permissions"\nelse\necho "Check: Ensure permissions on $key are configured"\necho "Status: Fail"\necho "Current Value: $permissions"\necho "Recommendation: Set permissions to 600"\necho "Remediation: sudo chmod 600 $key"\nfi\ndone\n', '#!/bin/bash\n\n# List public host key files\npublic_keys=$(find /etc/ssh -name \\\'ssh_host_*_key.pub\\\')\n\nfor key in $public_keys; do\npermissions=$(stat -c "%a" "$key")\nif [[ "$permissions" == "644" ]]; then\necho "Check: Ensure permissions on $key are configured"\necho "Status: Pass"\necho "Current Value: $permissions"\necho "Expected Value: 644"\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure permissions on $key are configured"\necho "Status: Fail"\necho "Current Value: $permissions"\necho "Expected Value: 644"\necho "Recommendation: Set permissions to 644"\necho "Remediation: sudo chmod 644 $key"\nfi\ndone\n', '#!/bin/bash\n\nallowed_users=$(grep "^AllowUsers" /etc/ssh/sshd_config)\nallowed_groups=$(grep "^AllowGroups" /etc/ssh/sshd_config)\n\nif [[ -n "$allowed_users" || -n "$allowed_groups" ]]; then\necho "Check: Ensure SSH access is limited"\necho "Status: Pass"\necho "Current Value: $allowed_users $allowed_groups"\necho "Expected Value: AllowUsers or AllowGroups should be configured with valid entries"\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure SSH access is limited"\necho "Status: Fail"\necho "Current Value: No restrictions"\necho "Expected Value: AllowUsers or AllowGroups should be configured with valid entries"\necho "Recommendation: Configure AllowUsers or AllowGroups in /etc/ssh/sshd_config"\necho "Remediation: sudo echo \\\'AllowUsers <user_list>\\\' >> /etc/ssh/sshd_config"\necho "Remediation: sudo echo \\\'AllowGroups <group_list>\\\' >> /etc/ssh/sshd_config"\nfi\n', '#!/bin/bash\n\nlog_level=$(grep "^LogLevel" /etc/ssh/sshd_config | awk \\\'{print $2}\\\')\nif [[ "$log_level" == "INFO" || "$log_level" == "VERBOSE" ]]; then\necho "Check: Ensure SSH LogLevel is appropriate"\necho "Status: Pass"\necho "Current Value: $log_level"\necho "Expected Value: INFO or VERBOSE"\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure SSH LogLevel is appropriate"\necho "Status: Fail"\necho "Current Value: $log_level"\necho "Expected Value: INFO or VERBOSE"\necho "Recommendation: Set LogLevel to INFO or VERBOSE in /etc/ssh/sshd_config"\necho "Remediation: sudo sed -i \\\'/^LogLevel/s/.*/LogLevel INFO/\\\' /etc/ssh/sshd_config"\nfi\n', '#!/bin/bash\n\npam_enabled=$(grep "^UsePAM" /etc/ssh/sshd_config | awk \\\'{print $2}\\\')\nif [[ "$pam_enabled" == "yes" ]]; then\necho "Check: Ensure SSH PAM is enabled"\necho "Status: Pass"\necho "Current Value: UsePAM is $pam_enabled"\necho "Expected Value: yes"\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure SSH PAM is enabled"\necho "Status: Fail"\necho "Current Value: UsePAM is $pam_enabled"\necho "Expected Value: yes"\necho "Recommendation: Set UsePAM to yes in /etc/ssh/sshd_config"\necho "Remediation: sudo sed -i \\\'/^UsePAM/s/.*/UsePAM yes/\\\' /etc/ssh/sshd_config"\nfi\n', '#!/bin/bash\n\nroot_login=$(grep "^PermitRootLogin" /etc/ssh/sshd_config | awk \\\'{print $2}\\\')\nif [[ "$root_login" == "no" ]]; then\necho "Check: Ensure SSH root login is disabled"\necho "Status: Pass"\necho "Current Value: PermitRootLogin is $root_login"\necho "Expected Value: no"\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure SSH root login is disabled"\necho "Status: Fail"\necho "Current Value: PermitRootLogin is $root_login"\necho "Expected Value: no"\necho "Recommendation: Set PermitRootLogin to no in /etc/ssh/sshd_config"\necho "Remediation: sudo sed -i \\\'/^PermitRootLogin/s/.*/PermitRootLogin no/\\\' /etc/ssh/sshd_config"\nfi\n', '#!/bin/bash\n\nhost_based_auth=$(grep "^HostbasedAuthentication" /etc/ssh/sshd_config | awk \\\'{print $2}\\\')\nif [[ "$host_based_auth" == "no" ]]; then\necho "Check: Ensure SSH HostbasedAuthentication is disabled"\necho "Status: Pass"\necho "Current Value: HostbasedAuthentication is $host_based_auth"\necho "Expected Value: no"\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure SSH HostbasedAuthentication is disabled"\necho "Status: Fail"\necho "Current Value: HostbasedAuthentication is $host_based_auth"\necho "Expected Value: no"\necho "Recommendation: Set HostbasedAuthentication to no in /etc/ssh/sshd_config"\necho "Remediation: sudo sed -i \\\'/^HostbasedAuthentication/s/.*/HostbasedAuthentication no/\\\' /etc/ssh/sshd_config"\nfi\n', '#!/bin/bash\n\npermit_empty=$(grep "^PermitEmptyPasswords" /etc/ssh/sshd_config | awk \\\'{print $2}\\\')\nif [[ "$permit_empty" == "no" ]]; then\necho "Check: Ensure SSH PermitEmptyPasswords is disabled"\necho "Status: Pass"\necho "Current Value: PermitEmptyPasswords is $permit_empty"\necho "Expected Value: no"\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure SSH PermitEmptyPasswords is disabled"\necho "Status: Fail"\necho "Current Value: PermitEmptyPasswords is $permit_empty"\necho "Expected Value: no"\necho "Recommendation: Set PermitEmptyPasswords to no in /etc/ssh/sshd_config"\necho "Remediation: sudo sed -i \\\'/^PermitEmptyPasswords/s/.*/PermitEmptyPasswords no/\\\' /etc/ssh/sshd_config"\nfi\n', '#!/bin/bash\n\npermit_user_env=$(grep "^PermitUserEnvironment" /etc/ssh/sshd_config | awk \\\'{print $2}\\\')\nif [[ "$permit_user_env" == "no" ]]; then\necho "Check: Ensure SSH PermitUserEnvironment is disabled"\necho "Status: Pass"\necho "Current Value: PermitUserEnvironment is $permit_user_env"\necho "Expected Value: no"\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure SSH PermitUserEnvironment is disabled"\necho "Status: Fail"\necho "Current Value: PermitUserEnvironment is $permit_user_env"\necho "Expected Value: no"\necho "Recommendation: Set PermitUserEnvironment to no in /etc/ssh/sshd_config"\necho "Remediation: sudo sed -i \\\'/^PermitUserEnvironment/s/.*/PermitUserEnvironment no/\\\' /etc/ssh/sshd_config"\nfi\n', '#!/bin/bash\n\nignore_rhosts=$(grep "^IgnoreRhosts" /etc/ssh/sshd_config | awk \\\'{print $2}\\\')\nif [[ "$ignore_rhosts" == "yes" ]]; then\necho "Check: Ensure SSH IgnoreRhosts is enabled"\necho "Status: Pass"\necho "Current Value: IgnoreRhosts is $ignore_rhosts"\necho "Expected Value: yes"\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure SSH IgnoreRhosts is enabled"\necho "Status: Fail"\necho "Current Value: IgnoreRhosts is $ignore_rhosts"\necho "Expected Value: yes"\necho "Recommendation: Set IgnoreRhosts to yes in /etc/ssh/sshd_config"\necho "Remediation: sudo sed -i \\\'/^IgnoreRhosts/s/.*/IgnoreRhosts yes/\\\' /etc/ssh/sshd_config"\nfi\n', '#!/bin/bash\n\nx11_forwarding=$(grep "^X11Forwarding" /etc/ssh/sshd_config | awk \\\'{print $2}\\\')\nif [[ "$x11_forwarding" == "no" ]]; then\necho "Check: Ensure SSH X11 forwarding is disabled"\necho "Status: Pass"\necho "Current Value: X11Forwarding is $x11_forwarding"\necho "Expected Value: no"\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure SSH X11 forwarding is disabled"\necho "Status: Fail"\necho "Current Value: X11Forwarding is $x11_forwarding"\necho "Expected Value: no"\necho "Recommendation: Set X11Forwarding to no in /etc/ssh/sshd_config"\necho "Remediation: sudo sed -i \\\'/^X11Forwarding/s/.*/X11Forwarding no/\\\' /etc/ssh/sshd_config"\nfi\n', '#!/bin/bash\n\ntcp_forwarding=$(grep "^AllowTcpForwarding" /etc/ssh/sshd_config | awk \\\'{print $2}\\\')\nif [[ "$tcp_forwarding" == "no" ]]; then\necho "Check: Ensure SSH AllowTcpForwarding is disabled"\necho "Status: Pass"\necho "Current Value: AllowTcpForwarding is $tcp_forwarding"\necho "Expected Value: no"\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure SSH AllowTcpForwarding is disabled"\necho "Status: Fail"\necho "Current Value: AllowTcpForwarding is $tcp_forwarding"\necho "Expected Value: no"\necho "Recommendation: Set AllowTcpForwarding to no in /etc/ssh/sshd_config"\necho "Remediation: sudo sed -i \\\'/^AllowTcpForwarding/s/.*/AllowTcpForwarding no/\\\' /etc/ssh/sshd_config"\nfi\n', '#!/bin/bash\n\ncrypto_policy=$(grep "^CryptoPolicy" /etc/ssh/sshd_config | awk \\\'{print $2}\\\')\nif [[ -z "$crypto_policy" ]]; then\necho "Check: Ensure system-wide crypto policy is not over-ridden"\necho "Status: Pass"\necho "Current Value: CryptoPolicy is not set"\necho "Expected Value: Not set"\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure system-wide crypto policy is not over-ridden"\necho "Status: Fail"\necho "Current Value: CryptoPolicy is $crypto_policy"\necho "Expected Value: Not set"\necho "Recommendation: Do not override system-wide crypto policy in /etc/ssh/sshd_config"\necho "Remediation: Remove CryptoPolicy line from /etc/ssh/sshd_config"\necho "Remediation: sudo sed -i \\\'/^CryptoPolicy/d\\\' /etc/ssh/sshd_config"\nfi\n', '#!/bin/bash\n\nbanner=$(grep "^Banner" /etc/ssh/sshd_config | awk \\\'{print $2}\\\')\nif [[ -n "$banner" && -f "$banner" ]]; then\necho "Check: Ensure SSH warning banner is configured"\necho "Status: Pass"\necho "Current Value: Banner is $banner"\nelse\necho "Check: Ensure SSH warning banner is configured"\necho "Status: Fail"\necho "Current Value: Banner is not configured"\necho "Recommendation: Set Banner to /etc/issue.net in /etc/ssh/sshd_config"\necho "Remediation: sudo sed -i \\\'/^Banner/s/.*/Banner /etc/issue.net/\\\' /etc/ssh/sshd_config"\nfi\n', '#!/bin/bash\n\nmax_auth_tries=$(grep "^MaxAuthTries" /etc/ssh/sshd_config | awk \\\'{print $2}\\\')\nif [[ "$max_auth_tries" -le 4 ]]; then\necho "Check: Ensure SSH MaxAuthTries is set to 4 or less"\necho "Status: Pass"\necho "Current Value: MaxAuthTries is $max_auth_tries"\necho "Expected Value: 4 or less"\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure SSH MaxAuthTries is set to 4 or less"\necho "Status: Fail"\necho "Current Value: MaxAuthTries is $max_auth_tries"\necho "Expected Value: 4 or less"\necho "Recommendation: Set MaxAuthTries to 4 or less in /etc/ssh/sshd_config"\necho "Remediation: sudo sed -i \\\'/^MaxAuthTries/s/.*/MaxAuthTries 4/\\\' /etc/ssh/sshd_config"\nfi\n', '#!/bin/bash\n\nmax_startups=$(grep "^MaxStartups" /etc/ssh/sshd_config | awk \\\'{print $2}\\\')\nif [[ -n "$max_startups" ]]; then\necho "Check: Ensure SSH MaxStartups is configured"\necho "Status: Pass"\necho "Current Value: MaxStartups is $max_startups"\necho "Expected Value: 10:30:100"\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure SSH MaxStartups is configured"\necho "Status: Fail"\necho "Current Value: MaxStartups is not configured"\necho "Expected Value: 10:30:100"\necho "Recommendation: Set MaxStartups in /etc/ssh/sshd_config"\necho "Remediation: sudo sed -i \\\'/^MaxStartups/s/.*/MaxStartups 10:30:100/\\\' /etc/ssh/sshd_config"\nfi\n', '#!/bin/bash\n\nmax_sessions=$(grep "^MaxSessions" /etc/ssh/sshd_config | awk \\\'{print $2}\\\')\nif [[ "$max_sessions" -le 10 ]]; then\necho "Check: Ensure SSH MaxSessions is set to 10 or less"\necho "Status: Pass"\necho "Current Value: MaxSessions is $max_sessions"\necho "Expected Value: 10"\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure SSH MaxSessions is set to 10 or less"\necho "Status: Fail"\necho "Current Value: MaxSessions is $max_sessions"\necho "Expected Value: 10"\necho "Recommendation: Set MaxSessions to 10 or less in /etc/ssh/sshd_config"\necho "Remediation: sudo sed -i \\\'/^MaxSessions/s/.*/MaxSessions 10/\\\' /etc/ssh/sshd_config"\nfi\n', '#!/bin/bash\n\nclient_alive_interval=$(grep "^ClientAliveInterval" /etc/ssh/sshd_config | awk \\\'{print $2}\\\')\nif [[ "$client_alive_interval" -ge 300 ]]; then\necho "Check: Ensure SSH ClientAliveInterval is set to 300 or more"\necho "Status: Pass"\necho "Current Value: ClientAliveInterval is $client_alive_interval"\necho "Expected Value: 300 or more"\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure SSH ClientAliveInterval is set to 300 or more"\necho "Status: Fail"\necho "Current Value: ClientAliveInterval is $client_alive_interval"\necho "Expected Value: 300 or more"\necho "Recommendation: Set ClientAliveInterval to 300 or more in /etc/ssh/sshd_config"\necho "Remediation: sudo sed -i \\\'/^ClientAliveInterval/s/.*/ClientAliveInterval 300/\\\' /etc/ssh/sshd_config"\nfi\n', '#!/bin/bash\n\nclient_alive_count=$(grep "^ClientAliveCountMax" /etc/ssh/sshd_config | awk \\\'{print $2}\\\')\nif [[ "$client_alive_count" -eq 0 ]]; then\necho "Check: Ensure SSH ClientAliveCountMax is set to 0"\necho "Status: Pass"\necho "Current Value: ClientAliveCountMax is $client_alive_count"\necho "Expected Value: 0"\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure SSH ClientAliveCountMax is set to 0"\necho "Status: Fail"\necho "Current Value: ClientAliveCountMax is $client_alive_count"\necho "Expected Value: 0"\necho "Recommendation: Set ClientAliveCountMax to 0 in /etc/ssh/sshd_config"\necho "Remediation: sudo sed -i \\\'/^ClientAliveCountMax/s/.*/ClientAliveCountMax 0/\\\' /etc/ssh/sshd_config"\nfi\n', '#!/bin/bash\n\nif command -v sudo &> /dev/null; then\necho "Check: Ensure sudo is installed"\necho "Status: Pass"\necho "Current Value: sudo is installed"\necho "Expected Value: sudo should be installed"\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure sudo is installed"\necho "Status: Fail"\necho "Current Value: sudo is not installed"\necho "Expected Value: sudo should be installed"\necho "Recommendation: Install sudo package"\necho "Remediation: sudo apt install sudo"\nfi\n', '#!/bin/bash\n\nsudo_pty=$(grep "^Defaults.*requiretty" /etc/sudoers)\nif [[ -n "$sudo_pty" ]]; then\necho "Check: Ensure sudo commands use pty"\necho "Status: Pass"\necho "Current Value: $sudo_pty"\necho "Expected Value: Defaults requiretty should be present in /etc/sudoers"\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure sudo commands use pty"\necho "Status: Fail"\necho "Current Value: $sudo_pty"\necho "Expected Value: Defaults requiretty should be present in /etc/sudoers"\necho "Recommendation: Ensure sudo commands use pty"\necho "Remediation: sudo sed -i \\\'/^Defaults/s/.*/Defaults requiretty/\\\' /etc/sudoers"\nfi\n', '#!/bin/bash\n\nsudo_log_file=$(grep "^Defaults.*logfile" /etc/sudoers | awk \\\'{print $2}\\\')\nif [[ -n "$sudo_log_file" && -f "$sudo_log_file" ]]; then\necho "Check: Ensure sudo log file exists"\necho "Status: Pass"\necho "Current Value: sudo log file is $sudo_log_file"\necho "Expected Value: Log file should exist and be correctly configured in /etc/sudoers"\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure sudo log file exists"\necho "Status: Fail"\necho "Current Value: sudo log file is not configured or doesn\\\'t exist"\necho "Expected Value: Log file should exist and be correctly configured in /etc/sudoers"\necho "Recommendation: Set logfile in sudoers configuration"\necho "Remediation: sudo sed -i \\\'/^Defaults/s/.*/Defaults logfile=\\\\"\\\\/var\\\\/log\\\\/sudo.log\\\\"/\\\' /etc/sudoers"\nfi\n', '#!/bin/bash\n\npassword_required=$(grep "^Defaults.*password" /etc/sudoers)\nif [[ -n "$password_required" && "$password_required" == *"authenticate"* ]]; then\necho "Check: Ensure users must provide password for escalation"\necho "Status: Pass"\necho "Current Value: $password_required"\necho "Expected Value: Password authentication must be required for sudo escalation"\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure users must provide password for escalation"\necho "Status: Fail"\necho "Current Value: $password_required"\necho "Expected Value: Password authentication must be required for sudo escalation"\necho "Recommendation: Require users to provide a password"\necho "Remediation: sudo sed -i \\\'/^Defaults/s/.*/Defaults requiretty authenticate/\\\' /etc/sudoers"\nfi\n', '#!/bin/bash\n\nre_authentication=$(grep "^Defaults.*timestamp" /etc/sudoers)\nif [[ -n "$re_authentication" && "$re_authentication" == *"timestamp_timeout=0"* ]]; then\necho "Check: Ensure re-authentication for privilege escalation is not disabled globally"\necho "Status: Pass"\necho "Current Value: Re-authentication timeout is set to 0"\necho "Expected Value: Re-authentication for privilege escalation should not be disabled globally (timestamp_timeout should not be 0)"\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure re-authentication for privilege escalation is not disabled globally"\necho "Status: Fail"\necho "Current Value: $re_authentication"\necho "Expected Value: Re-authentication for privilege escalation should not be disabled globally (timestamp_timeout should not be 0)"\necho "Recommendation: Set timestamp_timeout to a value other than 0"\necho "Remediation: sudo sed -i \\\'/^Defaults/s/.*/Defaults timestamp_timeout=0/\\\' /etc/sudoers"\nfi\n', '#!/bin/bash\n\ntimeout_value=$(sudo grep "^Defaults.*timestamp_timeout" /etc/sudoers | awk \\\'{print $2}\\\')\nif [[ "$timeout_value" -gt 0 && "$timeout_value" -lt 15 ]]; then\necho "Check: Ensure sudo authentication timeout is configured correctly"\necho "Status: Pass"\necho "Current Value: timestamp_timeout is $timeout_value"\necho "Expected Value: timestamp_timeout should be between 1 and 15 minutes"\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure sudo authentication timeout is configured correctly"\necho "Status: Fail"\necho "Current Value: timestamp_timeout is $timeout_value"\necho "Expected Value: timestamp_timeout should be between 1 and 15 minutes"\necho "Recommendation: Set timestamp_timeout to a value between 1 and 15 minutes"\necho "Remediation: sudo sed -i \\\'/^Defaults/s/.*/Defaults timestamp_timeout=5/\\\' /etc/sudoers"\nfi\n', '#!/bin/bash\n\nsu_access=$(grep "^auth.*required.*pam_wheel.so" /etc/pam.d/su)\nif [[ -n "$su_access" ]]; then\necho "Check: Ensure access to the su command is restricted"\necho "Status: Pass"\necho "Current Value: Access to su command is restricted"\necho "Expected Value: Access to su command should be restricted to authorized users"\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure access to the su command is restricted"\necho "Status: Fail"\necho "Current Value: Access to su command is not restricted"\necho "Expected Value: Access to su command should be restricted to authorized users"\necho "Recommendation: Restrict access to the su command to authorized users"\necho "Remediation: sudo sed -i \\\'/^auth/s/.*/auth required pam_wheel.so/\\\' /etc/pam.d/su"\nfi\n', '#!/bin/bash\n\n# Get the current authselect profile\ncurrent_profile=$(authselect current | grep "Selected profile" | awk \\\'{print $3}\\\')\n\n# Specify your custom profile\ncustom_profile="custom"\n\nif [[ "$current_profile" == "$custom_profile" ]]; then\necho "Check: Ensure custom authselect profile is used"\necho "Status: Pass"\necho "Current Profile: $current_profile"\nelse\necho "Check: Ensure custom authselect profile is used"\necho "Status: Fail"\necho "Current Profile: $current_profile"\necho "Recommendation: Use a custom authselect profile"\necho "Remediation: authselect select $custom_profile"\nfi\n', '#!/bin/bash\n\n# Check if the "with-faillock" option is enabled in the current authselect profile\nprofile_file="/etc/authselect/current"\n\nif grep -q "with-faillock" "$profile_file"; then\necho "Check: Ensure authselect includes with-faillock"\necho "Status: Pass"\necho "Current Value: with-faillock is enabled in the current authselect profile"\necho "Expected Value: with-faillock should be enabled in the authselect profile"\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure authselect includes with-faillock"\necho "Status: Fail"\necho "Current Value: with-faillock is not enabled in the current authselect profile"\necho "Expected Value: with-faillock should be enabled in the authselect profile"\necho "Recommendation: Enable faillock in the authselect profile"\necho "Remediation: authselect select sssd with-faillock"\nfi\n', '#!/bin/bash\n\n# Check if password creation requirements are set in /etc/login.defs\ncheck_password_policies() {\n    local required_policies=("PASS_MIN_LEN 8" "PASS_WARN_AGE 7" "PASS_MAX_DAYS 90")\n    local missing_policies=()\n\n    # Loop through required policies and check if each is configured correctly\n    for policy in "${required_policies[@]}"; do\n        key=$(echo "$policy" | awk \'{print $1}\')\n        value=$(echo "$policy" | awk \'{print $2}\')\n        current_value=$(grep -E "^$key" /etc/login.defs | awk \'{print $2}\')\n        \n        if [[ "$current_value" != "$value" ]]; then\n            missing_policies+=("$policy")\n        fi\n    done\n\n    if [[ ${#missing_policies[@]} -eq 0 ]]; then\n        echo "Check: Ensure password creation requirements are configured"\n        echo "Status: Pass"\n        echo "Current Policies:"\n        grep -E \'^PASS_MIN_LEN|^PASS_WARN_AGE|^PASS_MAX_DAYS\' /etc/login.defs\n    else\n        echo "Check: Ensure password creation requirements are configured"\n        echo "Status: Fail"\n        echo "Missing or Incorrect Policies:"\n        printf "%s\\n" "${missing_policies[@]}"\n        echo "Recommendation: Configure the following missing/incorrect policies in /etc/login.defs:"\n        printf "%s\\n" "${missing_policies[@]}"\n        echo "Remediation: Update /etc/login.defs with the missing policies."\n    fi\n}\n\n# Execute the check\ncheck_password_policies\n', '#!/bin/bash\n\n# Check if lockout for failed password attempts is configured\nlockout_config=$(grep "auth required pam_tally2.so" /etc/pam.d/common-auth)\n\nif [[ -z "$lockout_config" ]]; then\necho "Check: Ensure lockout for failed password attempts is configured"\necho "Status: Fail"\necho "Recommendation: Configure lockout for failed login attempts"\necho "Remediation: Add the following line to /etc/pam.d/common-auth:"\necho "auth required pam_tally2.so deny=5 onerr=fail unlock_time=600"\nelse\necho "Check: Ensure lockout for failed password attempts is configured"\necho "Status: Pass"\necho "Current Lockout Configuration:"\necho "$lockout_config"\nfi\n', '#!/bin/bash\n\n# Check if password reuse is limited\npassword_reuse=$(grep "password requisite pam_unix.so remember=" /etc/pam.d/common-password)\n\nif [[ -z "$password_reuse" ]]; then\necho "Check: Ensure password reuse is limited"\necho "Status: Fail"\necho "Recommendation: Limit password reuse"\necho "Remediation: Add the following line to /etc/pam.d/common-password:"\necho "password requisite pam_unix.so remember=5"\nelse\necho "Check: Ensure password reuse is limited"\necho "Status: Pass"\necho "Current Password Reuse Configuration:"\necho "$password_reuse"\nfi\n', '#!/bin/bash\n\n# Check if password hashing algorithm is SHA-512 or yescrypt\nhash_algorithm=$(grep "^ENCRYPT_METHOD" /etc/login.defs)\n\nif [[ "$hash_algorithm" == *"SHA512"* ]] || [[ "$hash_algorithm" == *"yescrypt"* ]]; then\necho "Check: Ensure password hashing algorithm is SHA-512 or yescrypt"\necho "Status: Pass"\necho "Current Hashing Algorithm: $hash_algorithm"\nelse\necho "Check: Ensure password hashing algorithm is SHA-512 or yescrypt"\necho "Status: Fail"\necho "Recommendation: Set ENCRYPT_METHOD to SHA-512 or yescrypt"\necho "Remediation: Add the following line to /etc/login.defs:"\necho "ENCRYPT_METHOD SHA512"\nfi\n', '#!/bin/bash\n\n# Check if password expiration is set to 365 days or less\npassword_expiration=$(grep "^PASS_MAX_DAYS" /etc/login.defs | awk \\\'{print $2}\\\')\n\nif [[ "$password_expiration" -le 365 ]]; then\necho "Check: Ensure password expiration is 365 days or less"\necho "Status: Pass"\necho "Current Value: PASS_MAX_DAYS is $password_expiration"\nelse\necho "Check: Ensure password expiration is 365 days or less"\necho "Status: Fail"\necho "Current Value: PASS_MAX_DAYS is $password_expiration"\necho "Recommendation: Set PASS_MAX_DAYS to 365 or less"\necho "Remediation: Edit /etc/login.defs and set PASS_MAX_DAYS to 365"\nsudo sed -i \\\'s/^PASS_MAX_DAYS.*/PASS_MAX_DAYS 365/\\\' /etc/login.defs\nfi\n', '#!/bin/bash\n\n# Function to ensure minimum days between password changes is configured\ncheck_min_days_between_password_changes() {\n    # Specify the desired minimum number of days\n    local min_days_required=1\n\n    # Check if /etc/shadow is readable\n    if [[ ! -r /etc/shadow ]]; then\n        echo "Check: Ensure minimum days between password changes is configured"\n        echo "Status: Fail"\n        echo "Current Value: Unable to read /etc/shadow."\n        echo "Expected Value: Minimum days between password changes should be $min_days_required."\n        echo "Recommendation: Check file permissions for /etc/shadow."\n        exit 1\n    fi\n\n    # Check users with minimum password age less than the required value\n    local users_with_low_min_days\n    users_with_low_min_days=$(awk -F: -v min_days="$min_days_required" \'\n    ($4 != "" && $4 < min_days) {\n        print $1 ": Minimum days between password changes is " $4\n    }\' /etc/shadow)\n\n    if [[ -z "$users_with_low_min_days" ]]; then\n        echo "Check: Ensure minimum days between password changes is configured"\n        echo "Status: Pass"\n        echo "Current Value: All users have minimum days between password changes set to $min_days_required or higher."\n        echo "Expected Value: Minimum days between password changes should be $min_days_required."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure minimum days between password changes is configured"\n        echo "Status: Fail"\n        echo "Current Value: Users with insufficient minimum days between password changes:"\n        echo "$users_with_low_min_days"\n        echo "Expected Value: Minimum days between password changes should be $min_days_required."\n        echo "Recommendation: Update the minimum password age for affected users."\n        echo "Remediation:"\n        while read -r user_info; do\n            user=$(echo "$user_info" | cut -d: -f1)\n            echo "# sudo chage -m $min_days_required $user"\n        done <<< "$users_with_low_min_days"\n    fi\n}\n\n# Execute the check with sudo (to ensure proper permissions for /etc/shadow)\nsudo bash -c "$(declare -f check_min_days_between_password_changes); check_min_days_between_password_changes"\n', '#!/bin/bash\n\n# Function to ensure password expiration warning days is 7 or more\ncheck_password_expiration_warning_days() {\n    # Specify the minimum expiration warning days\n    local min_warning_days=7\n\n    # Check if /etc/shadow is readable\n    if [[ ! -r /etc/shadow ]]; then\n        echo "Check: Ensure password expiration warning days is 7 or more"\n        echo "Status: Fail"\n        echo "Current Value: Unable to read /etc/shadow."\n        echo "Expected Value: Password expiration warning days should be $min_warning_days or more."\n        echo "Recommendation: Check file permissions for /etc/shadow."\n        exit 1\n    fi\n\n    # Check users with password expiration warning days less than the required value\n    local users_with_low_warning_days\n    users_with_low_warning_days=$(awk -F: -v min_days="$min_warning_days" \'\n    ($5 != "" && $5 < min_days) {\n        print $1 ": Password expiration warning days is " $5\n    }\' /etc/shadow)\n\n    if [[ -z "$users_with_low_warning_days" ]]; then\n        echo "Check: Ensure password expiration warning days is 7 or more"\n        echo "Status: Pass"\n        echo "Current Value: All users have password expiration warning days set to $min_warning_days or higher."\n        echo "Expected Value: Password expiration warning days should be $min_warning_days or more."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure password expiration warning days is 7 or more"\n        echo "Status: Fail"\n        echo "Current Value: Users with insufficient password expiration warning days:"\n        echo "$users_with_low_warning_days"\n        echo "Expected Value: Password expiration warning days should be $min_warning_days or more."\n        echo "Recommendation: Update the password expiration warning days for affected users."\n        echo "Remediation:"\n        while read -r user_info; do\n            user=$(echo "$user_info" | cut -d: -f1)\n            echo "# sudo chage -W $min_warning_days $user"\n        done <<< "$users_with_low_warning_days"\n    fi\n}\n\n# Execute the check with sudo (to ensure proper permissions for /etc/shadow)\nsudo bash -c "$(declare -f check_password_expiration_warning_days); check_password_expiration_warning_days"\n', '#!/bin/bash\n\n# Check if inactive password lock is 30 days or less\ninactive_lock=$(grep "^INACTIVE" /etc/login.defs | awk \\\'{print $2}\\\')\n\nif [[ "$inactive_lock" -le 30 ]]; then\necho "Check: Ensure inactive password lock is 30 days or less"\necho "Status: Pass"\necho "Current Value: INACTIVE is $inactive_lock"\nelse\necho "Check: Ensure inactive password lock is 30 days or less"\necho "Status: Fail"\necho "Current Value: INACTIVE is $inactive_lock"\necho "Recommendation: Set INACTIVE to 30 or less"\necho "Remediation: Edit /etc/login.defs and set INACTIVE to 30"\nsudo sed -i \\\'s/^INACTIVE.*/INACTIVE 30/\\\' /etc/login.defs\nfi\n', '#!/bin/bash\n\n# Check if all users\\\' last password change date is in the past\nfor user in $(cut -f1 -d: /etc/passwd); do\nlast_change_date=$(chage -l $user | grep "Last password change" | awk -F: \\\'{print $2}\\\')\ncurrent_date=$(date +%F)\n\nif [[ "$last_change_date" > "$current_date" ]]; then\necho "Check: Ensure all users\\\' last password change date is in the past"\necho "Status: Fail"\necho "User $user has a future password change date: $last_change_date"\necho "Recommendation: Correct the password change date for user $user"\necho "Remediation: Correct the password change date for user $user using the chage command"\nfi\ndone\n\necho "Check: Ensure all users\\\' last password change date is in the past"\necho "Status: Pass (If no future dates found)"\n', '#!/bin/bash\n\n# Check if system accounts are secured (non-login shells)\nfor user in $(cut -f1 -d: /etc/passwd); do\nshell=$(getent passwd $user | cut -d: -f7)\n\n# Check if the account is a system account (UID less than 1000) and has a valid shell\nif [[ $(getent passwd $user | cut -d: -f3) -lt 1000 && "$shell" != "/usr/sbin/nologin" && "$shell" != "/bin/false" ]]; then\necho "Check: Ensure system accounts are secured"\necho "Status: Fail"\necho "Current Value: System account $user has shell $shell, should be /usr/sbin/nologin or /bin/false"\necho "Expected Value: The shell for system account $user should be /usr/sbin/nologin or /bin/false"\necho "Recommendation: Change shell for system account $user"\necho "Remediation: sudo usermod -s /usr/sbin/nologin $user"\n\n# Apply remediation\nsudo usermod -s /usr/sbin/nologin $user\nelse\necho "Check: Ensure system accounts are secured"\necho "Status: Pass"\necho "Current Value: System account $user has shell $shell"\necho "Expected Value: The shell for system account $user should be /usr/sbin/nologin or /bin/false"\necho "Recommendation: No remediation required."\nfi\ndone\n\necho "Check: Ensure system accounts are secured"\necho "Status: Pass (If no misconfigured system accounts found)"\n', '#!/bin/bash\n\n# Check if default user shell timeout is 900 seconds or less\ntmout_value=$(grep "^TMOUT" /etc/profile /etc/bash.bashrc /etc/profile.d/* | awk -F= \\\'{print $2}\\\' | head -n 1)\n\nif [[ "$tmout_value" -le 900 || -z "$tmout_value" ]]; then\necho "Check: Ensure default user shell timeout is 900 seconds or less"\necho "Status: Pass"\necho "Current Value: TMOUT is $tmout_value"\necho "Expected Value: TMOUT should be 900 seconds or less"\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure default user shell timeout is 900 seconds or less"\necho "Status: Fail"\necho "Current Value: TMOUT is $tmout_value"\necho "Expected Value: TMOUT should be 900 seconds or less"\necho "Recommendation: Set TMOUT to 900 or less"\necho "Remediation: Edit /etc/profile and set TMOUT=900"\n\n# Remediation steps\nsudo sed -i \\\'s/^TMOUT.*/TMOUT=900/\\\' /etc/profile\nsudo sed -i \\\'s/^TMOUT.*/TMOUT=900/\\\' /etc/bash.bashrc\nfi\n', '#!/bin/bash\n\n# Check if the default group for root is GID 0\nroot_group=$(getent passwd root | cut -d: -f4)\n\nif [[ "$root_group" -eq 0 ]]; then\necho "Check: Ensure default group for the root account is GID 0"\necho "Status: Pass"\necho "Current Value: GID for root is $root_group"\necho "Expected Value: GID for root should be 0"\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure default group for the root account is GID 0"\necho "Status: Fail"\necho "Current Value: GID for root is $root_group"\necho "Expected Value: GID for root should be 0"\necho "Recommendation: Set the default group for root to GID 0"\necho "Remediation: sudo usermod -g 0 root"\n\n# Remediation step\nsudo usermod -g 0 root\nfi\n', '#!/bin/bash\n\n# Check if default user umask is 027 or more restrictive\numask_value=$(grep "^umask" /etc/profile /etc/profile.d/* | awk \'{print $2}\' | head -n 1)\n\nif [[ "$umask_value" == "027" || "$umask_value" == "077" ]]; then\n    echo "Check: Ensure default user umask is 027 or more restrictive"\n    echo "Status: Pass"\n    echo "Current Value: umask is $umask_value"\n    echo "Expected Value: umask should be 027 or more restrictive"\n    echo "Recommendation: No remediation required."\nelse\n    echo "Check: Ensure default user umask is 027 or more restrictive"\n    echo "Status: Fail"\n    echo "Current Value: umask is $umask_value"\n    echo "Expected Value: umask should be 027 or more restrictive"\n    echo "Recommendation: Set umask to 027 or more restrictive"\n    echo "Remediation: Edit /etc/profile and set umask 027"\n    \n    # Check if /etc/profile exists before attempting to modify\n    if [ -f /etc/profile ]; then\n        sudo sed -i \'s/^umask.*/umask 027/\' /etc/profile\n    else\n        echo "/etc/profile does not exist"\n    fi\n\n    # Check if /etc/bashrc exists before attempting to modify\n    if [ -f /etc/bashrc ]; then\n        sudo sed -i \'s/^umask.*/umask 027/\' /etc/bashrc\n    else\n        echo "/etc/bashrc does not exist"\n    fi\nfi', '#!/bin/bash\n\n# Check if root password is set\nroot_password=$(sudo passwd -S root | awk \\\'{print $2}\\\')\n\n# Check if the root password is locked or not set\nif [[ "$root_password" == "L" || "$root_password" == "NP" ]]; then\necho "Check: Ensure root password is set"\necho "Status: Fail"\necho "Current Value: Root password status is $root_password"\necho "Expected Value: Root password should be set"\necho "Recommendation: Set a password for the root account"\necho "Remediation: sudo passwd root"\nelse\necho "Check: Ensure root password is set"\necho "Status: Pass"\necho "Current Value: Root password is set"\necho "Expected Value: Root password should be set"\necho "Recommendation: No remediation required"\nfi\n', '#!/bin/bash\n\n# Check if time synchronization is in use\ntime_sync_check=$(timedatectl show --property=NTPSynchronized --value)\n\nif [[ "$time_sync_check" == "yes" ]]; then\n    echo "Check: Ensure time synchronization is in use"\n    echo "Status: Pass"\n    echo "Current Value: Time synchronization is enabled"\n    echo "Recommendation: No action needed."\nelse\n    echo "Check: Ensure time synchronization is in use"\n    echo "Status: Fail"\n    echo "Current Value: Time synchronization is not enabled"\n    echo "Recommendation: Enable time synchronization."\n    echo "Remediation Steps:"\n    echo "1. To enable time synchronization, run the following command:"\n    echo "   sudo timedatectl set-ntp true"\n    echo "2. Verify time synchronization is enabled by running:"\n    echo "   timedatectl show --property=NTPSynchronized --value"\nfi\n', '#!/bin/bash\n\n# Check if chrony is installed and configured\nif command -v chronyc &> /dev/null; then\n    chrony_config_check=$(chronyc tracking)\n\n    if [[ -n "$chrony_config_check" ]]; then\n        echo "Check: Ensure chrony is configured"\n        echo "Status: Pass"\n        echo "Current Value: Chrony is installed and configured"\n        echo "Recommendation: No action needed."\n    else\n        echo "Check: Ensure chrony is configured"\n        echo "Status: Fail"\n        echo "Current Value: Chrony is installed but not properly configured"\n        echo "Recommendation: Ensure Chrony is properly configured."\n        echo "Remediation Steps:"\n        echo "1. Edit the Chrony configuration file:"\n        echo "   sudo vi /etc/chrony.conf"\n        echo "2. Add NTP server entries as needed. Example:"\n        echo "   server 0.centos.pool.ntp.org iburst"\n        echo "3. Restart the chronyd service:"\n        echo "   sudo systemctl restart chronyd"\n        echo "4. Enable the chronyd service to start at boot:"\n        echo "   sudo systemctl enable chronyd"\n        echo "5. Verify the configuration by running:"\n        echo "   chronyc tracking"\n    fi\nelse\n    echo "Check: Ensure chrony is configured"\n    echo "Status: Fail"\n    echo "Current Value: Chrony is not installed"\n    echo "Recommendation: Install and configure Chrony."\n    echo "Remediation Steps:"\n    echo "1. To install Chrony, run the following command:"\n    echo "   sudo yum install chrony    # For RHEL/CentOS"\n    echo "   sudo apt install chrony    # For Ubuntu/Debian"\n    echo "2. After installation, configure Chrony as mentioned above."\nfi\n', '#!/bin/bash\n\n# Check if xorg-x11-server-common is installed\nif rpm -q xorg-x11-server-common &>/dev/null; then\n    echo "Check: Ensure xorg-x11-server-common is not installed"\n    echo "Status: Fail"\n    echo "Current Value: xorg-x11-server-common is installed"\n    echo "Recommendation: Uninstall xorg-x11-server-common if not needed."\n    echo "Remediation Steps:"\n    echo "1. To uninstall xorg-x11-server-common, run the following command:"\n    echo "   sudo yum remove xorg-x11-server-common    # For RHEL/CentOS"\n    echo "   sudo apt remove xorg-x11-server-common    # For Ubuntu/Debian"\nelse\n    echo "Check: Ensure xorg-x11-server-common is not installed"\n    echo "Status: Pass"\n    echo "Current Value: xorg-x11-server-common is not installed"\n    echo "Recommendation: No action needed."\nfi\n', '#!/bin/bash\n\n# Check if Avahi Server is installed\nif rpm -q avahi &>/dev/null; then\n    echo "Check: Ensure Avahi Server is not installed"\n    echo "Status: Fail"\n    echo "Current Value: Avahi Server is installed"\n    echo "Recommendation: Uninstall Avahi Server if not needed."\n    echo "Remediation Steps:"\n    echo "1. To uninstall Avahi Server, run the following command:"\n    echo "   sudo yum remove avahi    # For RHEL/CentOS"\n    echo "   sudo apt remove avahi    # For Ubuntu/Debian"\nelse\n    echo "Check: Ensure Avahi Server is not installed"\n    echo "Status: Pass"\n    echo "Current Value: Avahi Server is not installed"\n    echo "Recommendation: No action needed."\nfi\n', '#!/bin/bash\n\n# Check if CUPS is installed\nif rpm -q cups &>/dev/null; then\n    echo "Check: Ensure CUPS is not installed"\n    echo "Status: Fail"\n    echo "Current Value: CUPS is installed"\n    echo "Recommendation: Uninstall CUPS if not needed."\n    echo "Remediation Steps:"\n    echo "1. To uninstall CUPS, run the following command:"\n    echo "   sudo yum remove cups    # For RHEL/CentOS"\n    echo "   sudo apt remove cups    # For Ubuntu/Debian"\nelse\n    echo "Check: Ensure CUPS is not installed"\n    echo "Status: Pass"\n    echo "Current Value: CUPS is not installed"\n    echo "Recommendation: No action needed."\nfi\n', '#!/bin/bash\n\n# Check if DHCP Server is installed\nif rpm -q dhcp &>/dev/null; then\n    echo "Check: Ensure DHCP Server is not installed"\n    echo "Status: Fail"\n    echo "Current Value: DHCP Server is installed"\n    echo "Recommendation: Uninstall DHCP Server if not needed."\n    echo "Remediation Steps:"\n    echo "1. To uninstall DHCP Server, run the following command:"\n    echo "   sudo yum remove dhcp    # For RHEL/CentOS"\n    echo "   sudo apt remove isc-dhcp-server    # For Ubuntu/Debian"\nelse\n    echo "Check: Ensure DHCP Server is not installed"\n    echo "Status: Pass"\n    echo "Current Value: DHCP Server is not installed"\n    echo "Recommendation: No action needed."\nfi\n', '#!/bin/bash\n\n# Check if DNS Server is installed\nif rpm -q bind &>/dev/null; then\n    echo "Check: Ensure DNS Server is not installed"\n    echo "Status: Fail"\n    echo "Current Value: DNS Server is installed"\n    echo "Recommendation: Uninstall DNS Server if not needed."\n    echo "Remediation Steps:"\n    echo "1. To uninstall DNS Server, run the following command:"\n    echo "   sudo yum remove bind    # For RHEL/CentOS"\n    echo "   sudo apt remove bind9    # For Ubuntu/Debian"\nelse\n    echo "Check: Ensure DNS Server is not installed"\n    echo "Status: Pass"\n    echo "Current Value: DNS Server is not installed"\n    echo "Recommendation: No action needed."\nfi\n', '#!/bin/bash\n\n# Check if VSFTP Server is installed\nif rpm -q vsftpd &>/dev/null; then\n    echo "Check: Ensure VSFTP Server is not installed"\n    echo "Status: Fail"\n    echo "Current Value: VSFTP Server is installed"\n    echo "Recommendation: Uninstall VSFTP Server if not needed."\n    echo "Remediation Steps:"\n    echo "1. To uninstall VSFTP Server, run the following command:"\n    echo "   sudo yum remove vsftpd    # For RHEL/CentOS"\n    echo "   sudo apt remove vsftpd    # For Ubuntu/Debian"\nelse\n    echo "Check: Ensure VSFTP Server is not installed"\n    echo "Status: Pass"\n    echo "Current Value: VSFTP Server is not installed"\n    echo "Recommendation: No action needed."\nfi\n', '#!/bin/bash\n\n# Check if TFTP Server is installed\nif rpm -q tftp-server &>/dev/null; then\n    echo "Check: Ensure TFTP Server is not installed"\n    echo "Status: Fail"\n    echo "Current Value: TFTP Server is installed"\n    echo "Recommendation: Uninstall TFTP Server if not needed."\n    echo "Remediation Steps:"\n    echo "1. To uninstall TFTP Server, run the following command:"\n    echo "   sudo yum remove tftp-server    # For RHEL/CentOS"\n    echo "   sudo apt remove tftpd-hpa    # For Ubuntu/Debian"\nelse\n    echo "Check: Ensure TFTP Server is not installed"\n    echo "Status: Pass"\n    echo "Current Value: TFTP Server is not installed"\n    echo "Recommendation: No action needed."\nfi\n', '#!/bin/bash\n\n# Check if a web server is installed\nif rpm -q httpd &>/dev/null || rpm -q nginx &>/dev/null; then\n    echo "Check: Ensure a web server is not installed"\n    echo "Status: Fail"\n    echo "Current Value: Web server (httpd/nginx) is installed"\n    echo "Recommendation: Uninstall the web server if not needed."\n    echo "Remediation Steps:"\n    echo "1. To uninstall a web server, run the following command:"\n    echo "   sudo yum remove httpd    # For RHEL/CentOS"\n    echo "   sudo apt remove apache2    # For Ubuntu/Debian"\nelse\n    echo "Check: Ensure a web server is not installed"\n    echo "Status: Pass"\n    echo "Current Value: No web server is installed"\n    echo "Recommendation: No action needed."\nfi\n', '#!/bin/bash\n\n# Check if IMAP and POP3 server is installed\nif rpm -q dovecot &>/dev/null; then\n    echo "Check: Ensure IMAP and POP3 server is not installed"\n    echo "Status: Fail"\n    echo "Current Value: IMAP and POP3 server (dovecot) is installed"\n    echo "Recommendation: Uninstall IMAP and POP3 server if not needed."\n    echo "Remediation Steps:"\n    echo "1. To uninstall IMAP and POP3 server, run the following command:"\n    echo "   sudo yum remove dovecot    # For RHEL/CentOS"\n    echo "   sudo apt remove dovecot    # For Ubuntu/Debian"\nelse\n    echo "Check: Ensure IMAP and POP3 server is not installed"\n    echo "Status: Pass"\n    echo "Current Value: IMAP and POP3 server is not installed"\n    echo "Recommendation: No action needed."\nfi\n', '#!/bin/bash\n\n# Check if Samba is installed\nif rpm -q samba &>/dev/null; then\n    echo "Check: Ensure Samba is not installed"\n    echo "Status: Fail"\n    echo "Current Value: Samba is installed"\n    echo "Recommendation: Uninstall Samba if not needed."\n    echo "Remediation Steps:"\n    echo "1. To uninstall Samba, run the following command:"\n    echo "   sudo yum remove samba    # For RHEL/CentOS"\n    echo "   sudo apt remove samba    # For Ubuntu/Debian"\nelse\n    echo "Check: Ensure Samba is not installed"\n    echo "Status: Pass"\n    echo "Current Value: Samba is not installed"\n    echo "Recommendation: No action needed."\nfi\n', '#!/bin/bash\n\n# Check if HTTP Proxy Server is installed\nif rpm -q squid &>/dev/null; then\n    echo "Check: Ensure HTTP Proxy Server is not installed"\n    echo "Status: Fail"\n    echo "Current Value: HTTP Proxy Server (squid) is installed"\n    echo "Recommendation: Uninstall HTTP Proxy Server if not needed."\n    echo "Remediation Steps:"\n    echo "1. To uninstall HTTP Proxy Server, run the following command:"\n    echo "   sudo yum remove squid    # For RHEL/CentOS"\n    echo "   sudo apt remove squid    # For Ubuntu/Debian"\nelse\n    echo "Check: Ensure HTTP Proxy Server is not installed"\n    echo "Status: Pass"\n    echo "Current Value: HTTP Proxy Server is not installed"\n    echo "Recommendation: No action needed."\nfi\n', '#!/bin/bash\n\n# Check if net-snmp is installed\nif rpm -q net-snmp &>/dev/null; then\n    echo "Check: Ensure net-snmp is not installed"\n    echo "Status: Fail"\n    echo "Current Value: net-snmp is installed"\n    echo "Recommendation: Uninstall net-snmp if not needed."\n    echo "Remediation Steps:"\n    echo "1. To uninstall net-snmp, run the following command:"\n    echo "   sudo yum remove net-snmp    # For RHEL/CentOS"\n    echo "   sudo apt remove snmp    # For Ubuntu/Debian"\nelse\n    echo "Check: Ensure net-snmp is not installed"\n    echo "Status: Pass"\n    echo "Current Value: net-snmp is not installed"\n    echo "Recommendation: No action needed."\nfi\n', '#!/bin/bash\n\n# Check if telnet-server is installed\nif rpm -q telnet-server &>/dev/null; then\n    echo "Check: Ensure telnet-server is not installed"\n    echo "Status: Fail"\n    echo "Current Value: telnet-server is installed"\n    echo "Recommendation: Uninstall telnet-server if not needed."\n    echo "Remediation Steps:"\n    echo "1. To uninstall telnet-server, run the following command:"\n    echo "   sudo yum remove telnet-server    # For RHEL/CentOS"\n    echo "   sudo apt remove telnetd    # For Ubuntu/Debian"\nelse\n    echo "Check: Ensure telnet-server is not installed"\n    echo "Status: Pass"\n    echo "Current Value: telnet-server is not installed"\n    echo "Recommendation: No action needed."\nfi\n', '#!/bin/bash\n\n# Check if dnsmasq is installed\nif rpm -q dnsmasq &>/dev/null; then\n    echo "Check: Ensure dnsmasq is not installed"\n    echo "Status: Fail"\n    echo "Current Value: dnsmasq is installed"\n    echo "Recommendation: Uninstall dnsmasq if not needed."\n    echo "Remediation Steps:"\n    echo "1. To uninstall dnsmasq, run the following command:"\n    echo "   sudo yum remove dnsmasq    # For RHEL/CentOS"\n    echo "   sudo apt remove dnsmasq    # For Ubuntu/Debian"\nelse\n    echo "Check: Ensure dnsmasq is not installed"\n    echo "Status: Pass"\n    echo "Current Value: dnsmasq is not installed"\n    echo "Recommendation: No action needed."\nfi\n', '#!/bin/bash\n\n# Check if mail transfer agent is configured for local-only mode\nif rpm -q sendmail &>/dev/null; then\n    echo "Check: Ensure mail transfer agent is configured for local-only mode"\n    echo "Status: Fail"\n    echo "Current Value: sendmail is installed"\n    echo "Recommendation: Configure mail transfer agent for local-only mode."\n    echo "Remediation Steps:"\n    echo "1. Configure sendmail to run in local-only mode by editing the configuration."\n    echo "   Edit /etc/mail/sendmail.mc and ensure the following lines are included:"\n    echo "   FEATURE(local_only)"\n    echo "2. After editing, rebuild the configuration:"\n    echo "   sudo m4 /etc/mail/sendmail.mc > /etc/mail/sendmail.cf"\n    echo "3. Restart sendmail:"\n    echo "   sudo systemctl restart sendmail"\nelse\n    echo "Check: Ensure mail transfer agent is configured for local-only mode"\n    echo "Status: Pass"\n    echo "Current Value: No mail transfer agent (sendmail) is installed"\n    echo "Recommendation: No action needed."\nfi\n', '#!/bin/bash\n\n# Check if nfs-utils is installed\nif rpm -q nfs-utils &>/dev/null; then\n    echo "Check: Ensure nfs-utils is not installed or the nfs-server service is masked"\n    echo "Status: Fail"\n    echo "Current Value: nfs-utils is installed"\n    echo "Recommendation: Uninstall nfs-utils or mask the nfs-server service."\n    echo "Remediation Steps:"\n    echo "1. To uninstall nfs-utils, run the following command:"\n    echo "   sudo yum remove nfs-utils    # For RHEL/CentOS"\n    echo "   sudo apt remove nfs-common    # For Ubuntu/Debian"\n    echo "2. To mask the nfs-server service, run the following command:"\n    echo "   sudo systemctl mask nfs-server"\nelse\n    echo "Check: Ensure nfs-utils is not installed or the nfs-server service is masked"\n    echo "Status: Pass"\n    echo "Current Value: nfs-utils is not installed"\n    echo "Recommendation: No action needed."\nfi\n', '#!/bin/bash\n\n# Check if rpcbind is installed\nif rpm -q rpcbind &>/dev/null; then\n    echo "Check: Ensure rpcbind is not installed or the rpcbind services are masked"\n    echo "Status: Fail"\n    echo "Current Value: rpcbind is installed"\n    echo "Recommendation: Uninstall rpcbind or mask the rpcbind service."\n    echo "Remediation Steps:"\n    echo "1. To uninstall rpcbind, run the following command:"\n    echo "   sudo yum remove rpcbind    # For RHEL/CentOS"\n    echo "   sudo apt remove rpcbind    # For Ubuntu/Debian"\n    echo "2. To mask the rpcbind service, run the following command:"\n    echo "   sudo systemctl mask rpcbind"\nelse\n    echo "Check: Ensure rpcbind is not installed or the rpcbind services are masked"\n    echo "Status: Pass"\n    echo "Current Value: rpcbind is not installed"\n    echo "Recommendation: No action needed."\nfi\n', '#!/bin/bash\n\n# Check if rpcbind is installed\nif rpm -q rpcbind &>/dev/null; then\n    echo "Check: Ensure rpcbind is not installed or the rpcbind services are masked"\n    echo "Status: Fail"\n    echo "Current Value: rpcbind is installed"\n    echo "Recommendation: Uninstall rpcbind or mask the rpcbind service."\n    echo "Remediation Steps:"\n    echo "1. To uninstall rpcbind, run the following command:"\n    echo "   sudo yum remove rpcbind    # For RHEL/CentOS"\n    echo "   sudo apt remove rpcbind    # For Ubuntu/Debian"\n    echo "2. To mask the rpcbind service, run the following command:"\n    echo "   sudo systemctl mask rpcbind"\nelse\n    echo "Check: Ensure rpcbind is not installed or the rpcbind services are masked"\n    echo "Status: Pass"\n    echo "Current Value: rpcbind is not installed"\n    echo "Recommendation: No action needed."\nfi\n', '#!/bin/bash\n\n# Check if telnet client is installed\nif rpm -q telnet &>/dev/null; then\n    echo "Check: Ensure telnet client is not installed"\n    echo "Status: Fail"\n    echo "Current Value: telnet client is installed"\n    echo "Recommendation: Uninstall telnet client if not needed."\n    echo "Remediation Steps:"\n    echo "1. To uninstall telnet client, run the following command:"\n    echo "   sudo yum remove telnet    # For RHEL/CentOS"\n    echo "   sudo apt remove telnet    # For Ubuntu/Debian"\nelse\n    echo "Check: Ensure telnet client is not installed"\n    echo "Status: Pass"\n    echo "Current Value: telnet client is not installed"\n    echo "Recommendation: No action needed."\nfi\n', '#!/bin/bash\n\n# Check if LDAP client is installed\nif rpm -q openldap-clients &>/dev/null; then\n    echo "Check: Ensure LDAP client is not installed"\n    echo "Status: Fail"\n    echo "Current Value: LDAP client is installed"\n    echo "Recommendation: Uninstall LDAP client if not needed."\n    echo "Remediation Steps:"\n    echo "1. To uninstall LDAP client, run the following command:"\n    echo "   sudo yum remove openldap-clients    # For RHEL/CentOS"\n    echo "   sudo apt remove ldap-utils    # For Ubuntu/Debian"\nelse\n    echo "Check: Ensure LDAP client is not installed"\n    echo "Status: Pass"\n    echo "Current Value: LDAP client is not installed"\n    echo "Recommendation: No action needed."\nfi\n', '#!/bin/bash\n\n# Check if TFTP client is installed\nif rpm -q tftp &>/dev/null; then\n    echo "Check: Ensure TFTP client is not installed"\n    echo "Status: Fail"\n    echo "Current Value: TFTP client is installed"\n    echo "Recommendation: Uninstall TFTP client if not needed."\n    echo "Remediation Steps:"\n    echo "1. To uninstall TFTP client, run the following command:"\n    echo "   sudo yum remove tftp    # For RHEL/CentOS"\n    echo "   sudo apt remove tftp    # For Ubuntu/Debian"\nelse\n    echo "Check: Ensure TFTP client is not installed"\n    echo "Status: Pass"\n    echo "Current Value: TFTP client is not installed"\n    echo "Recommendation: No action needed."\nfi\n', '#!/bin/bash\n\n# Check if FTP client is installed\nif rpm -q ftp &>/dev/null; then\n    echo "Check: Ensure FTP client is not installed"\n    echo "Status: Fail"\n    echo "Current Value: FTP client is installed"\n    echo "Recommendation: Uninstall FTP client if not needed."\n    echo "Remediation Steps:"\n    echo "1. To uninstall FTP client, run the following command:"\n    echo "   sudo yum remove ftp    # For RHEL/CentOS"\n    echo "   sudo apt remove ftp    # For Ubuntu/Debian"\nelse\n    echo "Check: Ensure FTP client is not installed"\n    echo "Status: Pass"\n    echo "Current Value: FTP client is not installed"\n    echo "Recommendation: No action needed."\nfi\n', '#!/bin/bash\n\n# List of nonessential services to check\nnonessential_services=("telnet.socket" "ftp.socket" "rpcbind" "cups" "avahi-daemon" "nfs-server" "dnsmasq" "snmpd" "samba" "vsftpd")\n\n# Loop through each nonessential service and check its status\nfor service in "${nonessential_services[@]}"; do\n    # Check if the service is running\n    service_status=$(systemctl is-active "$service" 2>/dev/null)\n\n    if [[ "$service_status" == "active" || "$service_status" == "enabled" ]]; then\n        echo "Check: Ensure $service is not running or enabled"\n        echo "Status: Fail"\n        echo "Current Value: $service is running or enabled"\n        echo "Recommendation: Mask or remove the nonessential service."\n        echo "Remediation Steps:"\n        echo "1. To stop and disable the service, run the following commands:"\n        echo "   sudo systemctl stop $service"\n        echo "   sudo systemctl disable $service"\n        echo "2. To mask the service (to prevent it from being started), run the following command:"\n        echo "   sudo systemctl mask $service"\n    else\n        echo "Check: Ensure $service is not running or enabled"\n        echo "Status: Pass"\n        echo "Current Value: $service is not running or enabled"\n        echo "Recommendation: No action needed."\n    fi\ndone\n', '#!/bin/bash\n\naudit_pre_start=$(sudo grep -E \\\'^start_audit\\\' /etc/audit/auditd.conf | awk \\\'{print $2}\\\')\n\nif [[ "$audit_pre_start" == "yes" ]]; then\n    echo "Check: Ensure auditing for processes that start prior to auditd is enabled"\n    echo "Status: Pass"\n    echo "Current Value: Auditing for processes that start prior to auditd is enabled"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure auditing for processes that start prior to auditd is enabled"\n    echo "Status: Fail"\n    echo "Current Value: Auditing for processes that start prior to auditd is not enabled"\n    echo "Recommendation: Enable auditing for processes that start prior to auditd"\n    echo "Remediation: sudo echo \\\'start_audit = yes\\\' >> /etc/audit/auditd.conf && sudo systemctl restart auditd"\nfi\n', '#!/bin/bash\n\naudit_backlog_limit=$(sudo grep -E \\\'^audit_backlog_limit\\\' /etc/audit/auditd.conf | awk \\\'{print $2}\\\')\n\n# Define a recommended minimum value for audit_backlog_limit, for example, 8192\nrecommended_limit=8192\n\nif [[ "$audit_backlog_limit" -ge "$recommended_limit" ]]; then\n    echo "Check: Ensure audit_backlog_limit is sufficient"\n    echo "Status: Pass"\n    echo "Current Value: audit_backlog_limit is set to $audit_backlog_limit"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure audit_backlog_limit is sufficient"\n    echo "Status: Fail"\n    echo "Current Value: audit_backlog_limit is set to $audit_backlog_limit"\n    echo "Recommendation: Set audit_backlog_limit to at least $recommended_limit"\n    echo "Remediation: sudo echo \\\'audit_backlog_limit = $recommended_limit\\\' >> /etc/audit/auditd.conf && sudo systemctl restart auditd"\nfi\n', '#!/bin/bash\n\nauditd_status=$(sudo systemctl is-enabled auditd)\n\nif [[ "$auditd_status" == "enabled" ]]; then\n    echo "Check: Ensure auditd service is enabled"\n    echo "Status: Pass"\n    echo "Current Value: auditd service is enabled"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure auditd service is enabled"\n    echo "Status: Fail"\n    echo "Current Value: auditd service is not enabled"\n    echo "Recommendation: Enable the auditd service"\n    echo "Remediation: sudo systemctl enable auditd && sudo systemctl start auditd"\nfi\n', '#!/bin/bash\n\naudit_log_storage_size=$(sudo grep -E \\\'^max_log_file\\\' /etc/audit/auditd.conf | awk \\\'{print $2}\\\')\n\n# Define a recommended minimum value for max_log_file (in MB), e.g., 50 MB\nrecommended_size=50\n\nif [[ "$audit_log_storage_size" -ge "$recommended_size" ]]; then\n    echo "Check: Ensure audit log storage size is configured"\n    echo "Status: Pass"\n    echo "Current Value: Audit log storage size is set to $audit_log_storage_size MB"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure audit log storage size is configured"\n    echo "Status: Fail"\n    echo "Current Value: Audit log storage size is set to $audit_log_storage_size MB"\n    echo "Recommendation: Set the audit log storage size to at least $recommended_size MB"\n    echo "Remediation: sudo echo \\\'max_log_file = $recommended_size\\\' >> /etc/audit/auditd.conf && sudo systemctl restart auditd"\nfi\n', '#!/bin/bash\n\n# Check if the \\\'max_log_file_action\\\' is set to "rotate" or "keep_logs"\nmax_log_file_action=$(sudo grep -E \\\'^max_log_file_action\\\' /etc/audit/auditd.conf | awk \\\'{print $2}\\\')\n\nif [[ "$max_log_file_action" == "rotate" || "$max_log_file_action" == "keep_logs" ]]; then\n    echo "Check: Ensure audit logs are not automatically deleted"\n    echo "Status: Pass"\n    echo "Current Value: Audit logs are not automatically deleted"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure audit logs are not automatically deleted"\n    echo "Status: Fail"\n    echo "Current Value: Audit logs may be automatically deleted"\n    echo "Recommendation: Set \\\'max_log_file_action\\\' to \\\'rotate\\\' or \\\'keep_logs\\\'"\n    echo "Remediation: sudo echo \\\'max_log_file_action = rotate\\\' >> /etc/audit/auditd.conf && sudo systemctl restart auditd"\nfi\n', '#!/bin/bash\n\n# Check if \\\'space_left_action\\\' is set to "email" or "syslog" and \\\'action_mail_acct\\\' is set for notification\nspace_left_action=$(sudo grep -E \\\'^space_left_action\\\' /etc/audit/auditd.conf | awk \\\'{print $2}\\\')\nspace_left_action_expected="syslog"\n\nif [[ "$space_left_action" == "$space_left_action_expected" ]]; then\n    echo "Check: Ensure system is disabled when audit logs are full"\n    echo "Status: Pass"\n    echo "Current Value: System is disabled when audit logs are full"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure system is disabled when audit logs are full"\n    echo "Status: Fail"\n    echo "Current Value: System is not disabled when audit logs are full"\n    echo "Recommendation: Set \\\'space_left_action\\\' to \\\'syslog\\\' or \\\'email\\\' and configure a notification system"\n    echo "Remediation: sudo echo \\\'space_left_action = syslog\\\' >> /etc/audit/auditd.conf && sudo systemctl restart auditd"\nfi\n', '#!/bin/bash\n\n# Check if audit is configured to monitor changes to the sudoers file\nsudoers_audit=$(sudo grep -E \\\'^auditctl -w /etc/sudoers\\\' /etc/audit/rules.d/audit.rules)\n\nif [[ -n "$sudoers_audit" ]]; then\n    echo "Check: Ensure changes to system administration scope (sudoers) is collected"\n    echo "Status: Pass"\n    echo "Current Value: Changes to the sudoers file are being collected"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure changes to system administration scope (sudoers) is collected"\n    echo "Status: Fail"\n    echo "Current Value: Changes to the sudoers file are not being collected"\n    echo "Recommendation: Add auditing for sudoers file changes"\n    echo "Remediation: sudo echo \\\'-w /etc/sudoers -p wa\\\' >> /etc/audit/rules.d/audit.rules && sudo systemctl restart auditd"\nfi\n', '#!/bin/bash\n\n# Check if audit is configured to monitor \\\'su\\\' (switch user) activity\nsu_audit=$(sudo grep -E \\\'^auditctl -w /bin/su\\\' /etc/audit/rules.d/audit.rules)\n\nif [[ -n "$su_audit" ]]; then\n    echo "Check: Ensure actions as another user are always logged"\n    echo "Status: Pass"\n    echo "Current Value: Actions as another user (via \\\'su\\\') are being logged"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure actions as another user are always logged"\n    echo "Status: Fail"\n    echo "Current Value: Actions as another user (via \\\'su\\\') are not being logged"\n    echo "Recommendation: Add auditing for \\\'su\\\' commands"\n    echo "Remediation: sudo echo \\\'-w /bin/su -p x\\\' >> /etc/audit/rules.d/audit.rules && sudo systemctl restart auditd"\nfi\n', '#!/bin/bash\n\n# Check if audit is configured to monitor changes to the sudo log file\nsudo_log_audit=$(sudo grep -E \\\'^auditctl -w /var/log/sudo.log\\\' /etc/audit/rules.d/audit.rules)\n\nif [[ -n "$sudo_log_audit" ]]; then\n    echo "Check: Ensure events that modify the sudo log file are collected"\n    echo "Status: Pass"\n    echo "Current Value: Events modifying the sudo log file are being collected"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure events that modify the sudo log file are collected"\n    echo "Status: Fail"\n    echo "Current Value: Events modifying the sudo log file are not being collected"\n    echo "Recommendation: Add auditing for changes to the sudo log file"\n    echo "Remediation: sudo echo \\\'-w /var/log/sudo.log -p wa\\\' >> /etc/audit/rules.d/audit.rules && sudo systemctl restart auditd"\nfi\n', '#!/bin/bash\n\n# Check if audit is configured to monitor changes to date and time information\ndate_time_audit=$(sudo grep -E \\\'^auditctl -w /usr/bin/date\\\' /etc/audit/rules.d/audit.rules)\n\nif [[ -n "$date_time_audit" ]]; then\n    echo "Check: Ensure events that modify date and time information are collected"\n    echo "Status: Pass"\n    echo "Current Value: Changes to date and time information are being collected"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure events that modify date and time information are collected"\n    echo "Status: Fail"\n    echo "Current Value: Changes to date and time information are not being collected"\n    echo "Recommendation: Add auditing for date command usage"\n    echo "Remediation: sudo echo \\\'-w /usr/bin/date -p x\\\' >> /etc/audit/rules.d/audit.rules && sudo systemctl restart auditd"\nfi\n', '#!/bin/bash\n\n# Check if audit is configured to monitor changes to network configuration files\nnetwork_env_audit=$(sudo grep -E \\\'^auditctl -w /etc/network\\\' /etc/audit/rules.d/audit.rules)\n\nif [[ -n "$network_env_audit" ]]; then\n    echo "Check: Ensure events that modify the system\\\'s network environment are collected"\n    echo "Status: Pass"\n    echo "Current Value: Changes to network environment are being collected"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure events that modify the system\\\'s network environment are collected"\n    echo "Status: Fail"\n    echo "Current Value: Changes to network environment are not being collected"\n    echo "Recommendation: Add auditing for network configuration changes"\n    echo "Remediation: sudo echo \\\'-w /etc/network -p wa\\\' >> /etc/audit/rules.d/audit.rules && sudo systemctl restart auditd"\nfi\n', '#!/bin/bash\n\n# Check if audit is configured to monitor use of privileged commands like \\\'sudo\\\', \\\'su\\\', etc.\nprivileged_commands_audit=$(sudo grep -E \\\'^auditctl -w /usr/bin/sudo\\\' /etc/audit/rules.d/audit.rules)\n\nif [[ -n "$privileged_commands_audit" ]]; then\n    echo "Check: Ensure use of privileged commands are collected"\n    echo "Status: Pass"\n    echo "Current Value: Use of privileged commands is being logged"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure use of privileged commands are collected"\n    echo "Status: Fail"\n    echo "Current Value: Use of privileged commands is not being logged"\n    echo "Recommendation: Add auditing for privileged commands usage"\n    echo "Remediation: sudo echo \\\'-w /usr/bin/sudo -p x\\\' >> /etc/audit/rules.d/audit.rules && sudo systemctl restart auditd"\nfi\n', '#!/bin/bash\n\necho "Check: Ensure nftables base chains exist"\n\n# Check if the nftables base chains exist\nif nft list ruleset 2>/dev/null | grep -q "table inet filter"; then\n    echo "Status: Pass"\n    echo "Current Value: nftables base chains exist."\n    echo "Expected Value: nftables base chains should exist."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Status: Fail"\n    echo "Current Value: nftables base chains do not exist."\n    echo "Expected Value: nftables base chains should exist."\n    echo "Recommendation: Add nftables base chains."\n    echo "Remediation:"\n    echo "# To add nftables base chains, run the following command:"\n    echo "# sudo nft add table inet filter"\n    echo "# sudo nft add chain inet filter input { type filter hook input priority 0 \\\\; }"\n    echo "# sudo nft add chain inet filter forward { type filter hook forward priority 0 \\\\; }"\n    echo "# sudo nft add chain inet filter output { type filter hook output priority 0 \\\\; }"\n    echo "# To save the rules, run: sudo nft list ruleset > /etc/nftables.conf"\n    echo "# Then restart nftables: sudo systemctl restart nftables"\nfi\n', '#!/bin/bash\n\necho "Check: Ensure nftables base chains exist"\n\n# Check if the nftables base chains exist\nif nft list ruleset 2>/dev/null | grep -q "table inet filter"; then\n    echo "Status: Pass"\n    echo "Current Value: nftables base chains exist."\n    echo "Expected Value: nftables base chains should exist."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Status: Fail"\n    echo "Current Value: nftables base chains do not exist."\n    echo "Expected Value: nftables base chains should exist."\n    echo "Recommendation: Add nftables base chains."\n    echo "Remediation:"\n    echo "# To add nftables base chains, run the following command:"\n    echo "# sudo nft add table inet filter"\n    echo "# sudo nft add chain inet filter input { type filter hook input priority 0 \\\\; }"\n    echo "# sudo nft add chain inet filter forward { type filter hook forward priority 0 \\\\; }"\n    echo "# sudo nft add chain inet filter output { type filter hook output priority 0 \\\\; }"\n    echo "# To save the rules, run: sudo nft list ruleset > /etc/nftables.conf"\n    echo "# Then restart nftables: sudo systemctl restart nftables"\nfi\n', '#!/bin/bash\n\necho "Check: Ensure host-based firewall loopback traffic is configured"\n\n# Check if the loopback traffic is allowed in nftables\nif nft list ruleset 2>/dev/null | grep -q "i lo accept"; then\n    echo "Status: Pass"\n    echo "Current Value: Loopback traffic is allowed in the firewall."\n    echo "Expected Value: Loopback traffic should be allowed in the firewall."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Status: Fail"\n    echo "Current Value: Loopback traffic is not allowed in the firewall."\n    echo "Expected Value: Loopback traffic should be allowed in the firewall."\n    echo "Recommendation: Configure the firewall to allow loopback traffic."\n    echo "Remediation:"\n    echo "# To allow loopback traffic, run the following commands:"\n    echo "# sudo nft add rule inet filter input iif lo accept"\n    echo "# sudo nft add rule inet filter forward iif lo accept"\n    echo "# sudo nft add rule inet filter output oif lo accept"\n    echo "# To save the rules, run: sudo nft list ruleset > /etc/nftables.conf"\n    echo "# Then restart nftables: sudo systemctl restart nftables"\nfi\n', '#!/bin/bash\n\necho "Check: Ensure firewalld drops unnecessary services and ports"\n\n# Check if the firewalld configuration drops unnecessary services and ports\nif firewall-cmd --list-all | grep -q "services:.*" && firewall-cmd --list-all | grep -q "ports:.*"; then\n    echo "Status: Pass"\n    echo "Current Value: Only necessary services and ports are open in firewalld."\n    echo "Expected Value: Only necessary services and ports should be open in firewalld."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Status: Fail"\n    echo "Current Value: Unnecessary services or ports are open in firewalld."\n    echo "Expected Value: Only necessary services and ports should be open in firewalld."\n    echo "Recommendation: Configure firewalld to drop unnecessary services and ports."\n    echo "Remediation:"\n    echo "# To list currently open services and ports, run: firewall-cmd --list-all"\n    echo "# To remove unnecessary services, run: sudo firewall-cmd --remove-service=<service_name>"\n    echo "# To remove unnecessary ports, run: sudo firewall-cmd --remove-port=<port_number>/tcp"\n    echo "# To make changes permanent, run: sudo firewall-cmd --runtime-to-permanent"\n    echo "# Restart firewalld to apply changes: sudo systemctl restart firewalld"\nfi\n', '#!/bin/bash\n\necho "Check: Ensure nftables established connections are configured"\n\n# Check if the nftables rules allow established connections\nif nft list ruleset 2>/dev/null | grep -q "ct state established,related accept"; then\n    echo "Status: Pass"\n    echo "Current Value: Established connections are allowed in nftables."\n    echo "Expected Value: Established connections should be allowed in nftables."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Status: Fail"\n    echo "Current Value: Established connections are not allowed in nftables."\n    echo "Expected Value: Established connections should be allowed in nftables."\n    echo "Recommendation: Configure nftables to allow established connections."\n    echo "Remediation:"\n    echo "# To allow established connections, run the following command:"\n    echo "# sudo nft add rule inet filter input ct state established,related accept"\n    echo "# To save the rules, run: sudo nft list ruleset > /etc/nftables.conf"\n    echo "# Then restart nftables: sudo systemctl restart nftables"\nfi\n', '#!/bin/bash\n\necho "Check: Ensure nftables default deny firewall policy"\n\n# Check if the default policy is set to deny for nftables\nif nft list ruleset 2>/dev/null | grep -q "policy drop"; then\n    echo "Status: Pass"\n    echo "Current Value: Default policy is set to deny in nftables."\n    echo "Expected Value: Default policy should be set to deny in nftables."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Status: Fail"\n    echo "Current Value: Default policy is not set to deny in nftables."\n    echo "Expected Value: Default policy should be set to deny in nftables."\n    echo "Recommendation: Configure nftables to set default policy to deny."\n    echo "Remediation:"\n    echo "# To set the default policy to drop, run the following commands:"\n    echo "# sudo nft add rule inet filter input drop"\n    echo "# sudo nft add rule inet filter forward drop"\n    echo "# sudo nft add rule inet filter output drop"\n    echo "# To save the rules, run: sudo nft list ruleset > /etc/nftables.conf"\n    echo "# Then restart nftables: sudo systemctl restart nftables"\nfi\n', '#!/bin/bash\n\nif command -v rsyslogd &> /dev/null; then\n    echo "Check: Ensure rsyslog is installed"\n    echo "Status: Pass"\n    echo "Current Value: rsyslog is installed"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure rsyslog is installed"\n    echo "Status: Fail"\n    echo "Current Value: rsyslog is not installed"\n    echo "Recommendation: Install rsyslog using your package manager"\n    echo "Remediation: sudo apt install rsyslog -y OR sudo yum install rsyslog -y"\nfi\n', '#!/bin/bash\n\nservice_status=$(sudo systemctl is-enabled rsyslog 2>/dev/null)\n\nif [[ "$service_status" == "enabled" ]]; then\n    echo "Check: Ensure rsyslog service is enabled"\n    echo "Status: Pass"\n    echo "Current Value: rsyslog service is enabled"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure rsyslog service is enabled"\n    echo "Status: Fail"\n    echo "Current Value: rsyslog service is not enabled"\n    echo "Recommendation: Enable rsyslog service"\n    echo "Remediation: sudo systemctl enable rsyslog && sudo systemctl start rsyslog"\nfi\n', '#!/bin/bash\n\njournald_config=$(sudo grep -E \\\'^ForwardToSyslog=\\\' /etc/systemd/journald.conf | awk -F\\\'=\\\' \\\'{print $2}\\\')\n\nif [[ "$journald_config" == "yes" ]]; then\n    echo "Check: Ensure journald is configured to send logs to rsyslog"\n    echo "Status: Pass"\n    echo "Current Value: ForwardToSyslog is set to yes"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure journald is configured to send logs to rsyslog"\n    echo "Status: Fail"\n    echo "Current Value: ForwardToSyslog is not set to yes"\n    echo "Recommendation: Configure journald to forward logs"\n    echo "Remediation: sudo sed -i \\\'s/^#ForwardToSyslog=.*/ForwardToSyslog=yes/\\\' /etc/systemd/journald.conf && sudo systemctl restart systemd-journald"\nfi\n', '#!/bin/bash\n\ndefault_permissions=$(sudo grep -E \\\'^$FileCreateMode\\\' /etc/rsyslog.conf | awk \\\'{print $2}\\\')\n\nif [[ "$default_permissions" == "0640" ]]; then\n    echo "Check: Ensure rsyslog default file permissions are configured"\n    echo "Status: Pass"\n    echo "Current Value: Default file permissions are set to 0640"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure rsyslog default file permissions are configured"\n    echo "Status: Fail"\n    echo "Current Value: Default file permissions are not set to 0640"\n    echo "Recommendation: Set default permissions to 0640"\n    echo "Remediation: sudo echo \\\'$FileCreateMode 0640\\\' >> /etc/rsyslog.conf && sudo systemctl restart rsyslog"\nfi\n', '#!/bin/bash\n\nconfig_files=("/etc/rsyslog.conf" "/etc/rsyslog.d/*.conf")\nlog_configured="true"\n\nfor file in "${config_files[@]}"; do\n    if ! sudo grep -qE \\\'/var/log/\\\' "$file"; then\n        log_configured="false"\n        break\n    fi\ndone\n\nif [[ "$log_configured" == "true" ]]; then\n    echo "Check: Ensure logging is configured"\n    echo "Status: Pass"\n    echo "Current Value: Logging is properly configured"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure logging is configured"\n    echo "Status: Fail"\n    echo "Current Value: Logging is not properly configured"\n    echo "Recommendation: Ensure logging to files in /var/log is configured in rsyslog"\n    echo "Remediation: Review rsyslog configuration files"\nfi\n', '#!/bin/bash\n\nremote_host=$(sudo grep -E \\\'^*.* @@\\\' /etc/rsyslog.conf | awk \\\'{print $2}\\\')\n\nif [[ -n "$remote_host" ]]; then\n    echo "Check: Ensure rsyslog is configured to send logs to a remote log host"\n    echo "Status: Pass"\n    echo "Current Value: Logs are being sent to $remote_host"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure rsyslog is configured to send logs to a remote log host"\n    echo "Status: Fail"\n    echo "Current Value: No remote log host configured"\n    echo "Recommendation: Configure rsyslog to send logs to a remote host"\n    echo "Remediation: Add *.* @@<remote-host> in /etc/rsyslog.conf and restart rsyslog"\nfi\n', '#!/bin/bash\n\nreceive_logs=$(sudo grep -E \\\'^\\\\$ModLoad imtcp|^\\\\$InputTCPServerRun\\\' /etc/rsyslog.conf)\n\nif [[ -z "$receive_logs" ]]; then\n    echo "Check: Ensure rsyslog is not configured to receive logs from a remote client"\n    echo "Status: Pass"\n    echo "Current Value: rsyslog is not configured to receive logs"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure rsyslog is not configured to receive logs from a remote client"\n    echo "Status: Fail"\n    echo "Current Value: rsyslog is configured to receive logs"\n    echo "Recommendation: Disable receiving logs"\n    echo "Remediation: Remove or comment lines with \\\\$ModLoad imtcp or \\\\$InputTCPServerRun in /etc/rsyslog.conf and restart rsyslog"\nfi\n', '#!/bin/bash\n\nif command -v systemd-journal-remote &> /dev/null; then\n    echo "Check: Ensure systemd-journal-remote is installed"\n    echo "Status: Pass"\n    echo "Current Value: systemd-journal-remote is installed"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure systemd-journal-remote is installed"\n    echo "Status: Fail"\n    echo "Current Value: systemd-journal-remote is not installed"\n    echo "Recommendation: Install systemd-journal-remote using your package manager"\n    echo "Remediation: sudo apt install systemd-journal-remote -y OR sudo yum install systemd-journal-remote -y"\nfi\n', '#!/bin/bash\n\nconfig_file="/etc/systemd/journal-remote.conf"\n\nif [[ -f "$config_file" && -n $(sudo grep -vE \\\'^#|^$\\\' "$config_file") ]]; then\n    echo "Check: Ensure systemd-journal-remote is configured"\n    echo "Status: Pass"\n    echo "Current Value: Configuration is present in $config_file"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure systemd-journal-remote is configured"\n    echo "Status: Fail"\n    echo "Current Value: No valid configuration found in $config_file"\n    echo "Recommendation: Configure systemd-journal-remote with appropriate settings"\n    echo "Remediation: Edit $config_file with required settings and restart systemd-journal-remote"\nfi\n', '#!/bin/bash\n\nservice_status=$(sudo systemctl is-enabled systemd-journal-remote 2>/dev/null)\n\nif [[ "$service_status" == "enabled" ]]; then\n    echo "Check: Ensure systemd-journal-remote is enabled"\n    echo "Status: Pass"\n    echo "Current Value: systemd-journal-remote service is enabled"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure systemd-journal-remote is enabled"\n    echo "Status: Fail"\n    echo "Current Value: systemd-journal-remote service is not enabled"\n    echo "Recommendation: Enable systemd-journal-remote service"\n    echo "Remediation: sudo systemctl enable systemd-journal-remote && sudo systemctl start systemd-journal-remote"\nfi\n', '#!/bin/bash\n\nconfig_file="/etc/systemd/journald.conf"\nreceive_logs=$(sudo grep -E \\\'^ForwardToSyslog=\\\' "$config_file" | awk -F\\\'=\\\' \\\'{print $2}\\\')\n\nif [[ "$receive_logs" == "no" || -z "$receive_logs" ]]; then\n    echo "Check: Ensure journald is not configured to receive logs from a remote client"\n    echo "Status: Pass"\n    echo "Current Value: ForwardToSyslog is set to no or not configured"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure journald is not configured to receive logs from a remote client"\n    echo "Status: Fail"\n    echo "Current Value: ForwardToSyslog is set to yes"\n    echo "Recommendation: Disable remote log receiving in journald"\n    echo "Remediation: sudo sed -i \\\'s/^ForwardToSyslog=.*/ForwardToSyslog=no/\\\' $config_file && sudo systemctl restart systemd-journald"\nfi\n', '#!/bin/bash\n\nservice_status=$(sudo systemctl is-enabled systemd-journald 2>/dev/null)\n\nif [[ "$service_status" == "enabled" ]]; then\n    echo "Check: Ensure journald service is enabled"\n    echo "Status: Pass"\n    echo "Current Value: journald service is enabled"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure journald service is enabled"\n    echo "Status: Fail"\n    echo "Current Value: journald service is not enabled"\n    echo "Recommendation: Enable journald service"\n    echo "Remediation: sudo systemctl enable systemd-journald && sudo systemctl start systemd-journald"\nfi\n', '#!/bin/bash\n\nconfig_file="/etc/systemd/journald.conf"\ncompress_logs=$(sudo grep -E \\\'^Compress=\\\' "$config_file" | awk -F\\\'=\\\' \\\'{print $2}\\\')\n\nif [[ "$compress_logs" == "yes" ]]; then\n    echo "Check: Ensure journald is configured to compress large log files"\n    echo "Status: Pass"\n    echo "Current Value: Compress is set to yes"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure journald is configured to compress large log files"\n    echo "Status: Fail"\n    echo "Current Value: Compress is not set to yes"\n    echo "Recommendation: Configure journald to compress log files"\n    echo "Remediation: sudo sed -i \\\'s/^#Compress=.*/Compress=yes/\\\' $config_file && sudo systemctl restart systemd-journald"\nfi\n', '#!/bin/bash\n\nconfig_file="/etc/systemd/journald.conf"\nstorage_setting=$(sudo grep -E \\\'^Storage=\\\' "$config_file" | awk -F\\\'=\\\' \\\'{print $2}\\\')\n\nif [[ "$storage_setting" == "persistent" ]]; then\n    echo "Check: Ensure journald is configured to write logfiles to persistent disk"\n    echo "Status: Pass"\n    echo "Current Value: Storage is set to persistent"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure journald is configured to write logfiles to persistent disk"\n    echo "Status: Fail"\n    echo "Current Value: Storage is set to $storage_setting"\n    echo "Recommendation: Configure journald to store logs on persistent disk"\n    echo "Remediation: sudo sed -i \\\'s/^#Storage=.*/Storage=persistent/\\\' $config_file && sudo systemctl restart systemd-journald"\nfi\n', '#!/bin/bash\n\nconfig_file="/etc/systemd/journald.conf"\nforward_logs=$(sudo grep -E \\\'^ForwardToSyslog=\\\' "$config_file" | awk -F\\\'=\\\' \\\'{print $2}\\\')\n\nif [[ "$forward_logs" == "no" || -z "$forward_logs" ]]; then\n    echo "Check: Ensure journald is not configured to send logs to rsyslog"\n    echo "Status: Pass"\n    echo "Current Value: ForwardToSyslog is set to no or not configured"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure journald is not configured to send logs to rsyslog"\n    echo "Status: Fail"\n    echo "Current Value: ForwardToSyslog is set to yes"\n    echo "Recommendation: Disable forwarding logs to rsyslog"\n    echo "Remediation: sudo sed -i \\\'s/^#ForwardToSyslog=.*/ForwardToSyslog=no/\\\' $config_file && sudo systemctl restart systemd-journald"\nfi\n', '#!/bin/bash\n\nconfig_file="/etc/systemd/journald.conf"\nmax_file=$(sudo grep -E \\\'^SystemMaxFileSize=\\\' "$config_file" | awk -F\\\'=\\\' \\\'{print $2}\\\')\nmax_files=$(sudo grep -E \\\'^SystemMaxFiles=\\\' "$config_file" | awk -F\\\'=\\\' \\\'{print $2}\\\')\n\nif [[ -n "$max_file" && -n "$max_files" ]]; then\n    echo "Check: Ensure journald log rotation is configured per site policy"\n    echo "Status: Pass"\n    echo "Current Value: SystemMaxFileSize=$max_file, SystemMaxFiles=$max_files"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure journald log rotation is configured per site policy"\n    echo "Status: Fail"\n    echo "Current Value: SystemMaxFileSize or SystemMaxFiles is not configured"\n    echo "Recommendation: Configure journald log rotation parameters"\n    echo "Remediation: Edit $config_file and set SystemMaxFileSize and SystemMaxFiles as per site policy, then restart systemd-journald"\nfi\n', '#!/bin/bash\n\nconfig_file="/etc/systemd/journald.conf"\nperm_setting=$(sudo grep -E \\\'^SystemKeepFree=\\\' "$config_file" | awk -F\\\'=\\\' \\\'{print $2}\\\')\n\nif [[ -n "$perm_setting" ]]; then\n    echo "Check: Ensure journald default file permissions are configured"\n    echo "Status: Pass"\n    echo "Current Value: SystemKeepFree=$perm_setting"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure journald default file permissions are configured"\n    echo "Status: Fail"\n    echo "Current Value: SystemKeepFree is not set"\n    echo "Recommendation: Configure default file permissions in journald"\n    echo "Remediation: Edit $config_file and set SystemKeepFree, then restart systemd-journald"\nfi\n', '#!/bin/bash\n\n# Check if audit rules are set to log unsuccessful file access attempts\nfile_access_audit=$(sudo grep -E \\\'\\\\-a always,exit -F arch=b64 -S open,openat,creat -F exit=-EACCES -F auid>=1000\\\' /etc/audit/rules.d/audit.rules)\n\nif [[ -n "$file_access_audit" ]]; then\n    echo "Check: Ensure unsuccessful file access attempts are collected"\n    echo "Status: Pass"\n    echo "Current Value: Unsuccessful file access attempts are being logged"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure unsuccessful file access attempts are collected"\n    echo "Status: Fail"\n    echo "Current Value: Unsuccessful file access attempts are not being logged"\n    echo "Recommendation: Add auditing for unsuccessful file access attempts"\n    echo "Remediation: sudo echo \\\'-a always,exit -F arch=b64 -S open,openat,creat -F exit=-EACCES -F auid>=1000\\\' >> /etc/audit/rules.d/audit.rules && sudo systemctl restart auditd"\nfi\n', '#!/bin/bash\n\n# Check if audit rules are set to monitor user/group modification events\nuser_group_audit=$(sudo grep -E \\\'(/etc/passwd|/etc/group|/etc/shadow)\\\' /etc/audit/rules.d/audit.rules)\n\nif [[ -n "$user_group_audit" ]]; then\n    echo "Check: Ensure events that modify user/group information are collected"\n    echo "Status: Pass"\n    echo "Current Value: User/group modification events are being logged"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure events that modify user/group information are collected"\n    echo "Status: Fail"\n    echo "Current Value: User/group modification events are not being logged"\n    echo "Recommendation: Add auditing for user/group information modification events"\n    echo "Remediation: sudo echo \\\'-w /etc/passwd -p wa\\\' >> /etc/audit/rules.d/audit.rules && sudo echo \\\'-w /etc/group -p wa\\\' >> /etc/audit/rules.d/audit.rules && sudo echo \\\'-w /etc/shadow -p wa\\\' >> /etc/audit/rules.d/audit.rules && sudo systemctl restart auditd"\nfi\n', '#!/bin/bash\n\n# Check if audit rules are set to monitor DAC permission modifications\ndac_audit=$(sudo grep -E \\\'\\\\-a always,exit -F arch=b64 -S chmod,fchmod,fchmodat -F auid>=1000\\\' /etc/audit/rules.d/audit.rules)\n\nif [[ -n "$dac_audit" ]]; then\n    echo "Check: Ensure discretionary access control permission modification events are collected"\n    echo "Status: Pass"\n    echo "Current Value: DAC permission modification events are being logged"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure discretionary access control permission modification events are collected"\n    echo "Status: Fail"\n    echo "Current Value: DAC permission modification events are not being logged"\n    echo "Recommendation: Add auditing for DAC permission modifications"\n    echo "Remediation: sudo echo \\\'-a always,exit -F arch=b64 -S chmod,fchmod,fchmodat -F auid>=1000\\\' >> /etc/audit/rules.d/audit.rules && sudo systemctl restart auditd"\nfi\n', '#!/bin/bash\n\n# Check if audit rules are set to monitor file system mounts\nmount_audit=$(sudo grep -E \\\'\\\\-a always,exit -F arch=b64 -S mount -F auid>=1000\\\' /etc/audit/rules.d/audit.rules)\n\nif [[ -n "$mount_audit" ]]; then\n    echo "Check: Ensure successful file system mounts are collected"\n    echo "Status: Pass"\n    echo "Current Value: Successful file system mounts are being logged"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure successful file system mounts are collected"\n    echo "Status: Fail"\n    echo "Current Value: Successful file system mounts are not being logged"\n    echo "Recommendation: Add auditing for file system mounts"\n    echo "Remediation: sudo echo \\\'-a always,exit -F arch=b64 -S mount -F auid>=1000\\\' >> /etc/audit/rules.d/audit.rules && sudo systemctl restart auditd"\nfi\n', '#!/bin/bash\n\n# Check if audit rules are set to monitor session initiation\nsession_init_audit=$(sudo grep -E \\\'\\\\-w /var/run/utmp -p wa\\\' /etc/audit/rules.d/audit.rules)\n\nif [[ -n "$session_init_audit" ]]; then\n    echo "Check: Ensure session initiation information is collected"\n    echo "Status: Pass"\n    echo "Current Value: Session initiation information is being logged"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure session initiation information is collected"\n    echo "Status: Fail"\n    echo "Current Value: Session initiation information is not being logged"\n    echo "Recommendation: Add auditing for session initiation information"\n    echo "Remediation: sudo echo \\\'-w /var/run/utmp -p wa\\\' >> /etc/audit/rules.d/audit.rules && sudo systemctl restart auditd"\nfi\n', '#!/bin/bash\n\n# Check if audit rules are set to monitor login/logout events\nlogin_logout_audit=$(sudo grep -E \\\'\\\\-w /var/log/wtmp -p wa\\\' /etc/audit/rules.d/audit.rules)\n\nif [[ -n "$login_logout_audit" ]]; then\n    echo "Check: Ensure login and logout events are collected"\n    echo "Status: Pass"\n    echo "Current Value: Login and logout events are being logged"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure login and logout events are collected"\n    echo "Status: Fail"\n    echo "Current Value: Login and logout events are not being logged"\n    echo "Recommendation: Add auditing for login/logout events"\n    echo "Remediation: sudo echo \\\'-w /var/log/wtmp -p wa\\\' >> /etc/audit/rules.d/audit.rules && sudo systemctl restart auditd"\nfi\n', '#!/bin/bash\n\n# Check if audit rules are set to log file deletion events by users\nfile_deletion_audit=$(sudo grep -E \\\'\\\\-a always,exit -F arch=b64 -S unlink,unlinkat,rename,renameat -F auid>=1000\\\' /etc/audit/rules.d/audit.rules)\n\nif [[ -n "$file_deletion_audit" ]]; then\n    echo "Check: Ensure file deletion events by users are collected"\n    echo "Status: Pass"\n    echo "Current Value: File deletion events by users are being logged"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure file deletion events by users are collected"\n    echo "Status: Fail"\n    echo "Current Value: File deletion events by users are not being logged"\n    echo "Recommendation: Add auditing for file deletion events"\n    echo "Remediation: sudo echo \\\'-a always,exit -F arch=b64 -S unlink,unlinkat,rename,renameat -F auid>=1000\\\' >> /etc/audit/rules.d/audit.rules && sudo systemctl restart auditd"\nfi\n', '#!/bin/bash\n\n# Check if audit rules are set to log changes to Mandatory Access Controls (MAC)\nmac_audit=$(sudo grep -E \\\'\\\\-w /etc/selinux/ -p wa\\\' /etc/audit/rules.d/audit.rules)\n\nif [[ -n "$mac_audit" ]]; then\n    echo "Check: Ensure events that modify the system\\\'s Mandatory Access Controls are collected"\n    echo "Status: Pass"\n    echo "Current Value: Events modifying Mandatory Access Controls are being logged"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure events that modify the system\\\'s Mandatory Access Controls are collected"\n    echo "Status: Fail"\n    echo "Current Value: Events modifying Mandatory Access Controls are not being logged"\n    echo "Recommendation: Add auditing for changes to Mandatory Access Controls"\n    echo "Remediation: sudo echo \\\'-w /etc/selinux/ -p wa\\\' >> /etc/audit/rules.d/audit.rules && sudo systemctl restart auditd"\nfi\n', '#!/bin/bash\n\n# Check if audit rules are set to log attempts to use the chcon command\nchcon_audit=$(sudo grep -E \\\'\\\\-a always,exit -F arch=b64 -S chown,fchown,fchownat,lchown -F auid>=1000\\\' /etc/audit/rules.d/audit.rules)\n\nif [[ -n "$chcon_audit" ]]; then\n    echo "Check: Ensure successful and unsuccessful attempts to use the chcon command are recorded"\n    echo "Status: Pass"\n    echo "Current Value: Attempts to use the chcon command are being logged"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure successful and unsuccessful attempts to use the chcon command are recorded"\n    echo "Status: Fail"\n    echo "Current Value: Attempts to use the chcon command are not being logged"\n    echo "Recommendation: Add auditing for chcon command usage"\n    echo "Remediation: sudo echo \\\'-a always,exit -F arch=b64 -S chown,fchown,fchownat,lchown -F auid>=1000\\\' >> /etc/audit/rules.d/audit.rules && sudo systemctl restart auditd"\nfi\n', '#!/bin/bash\n\n# Check if audit rules are set to log attempts to use the setfacl command\nsetfacl_audit=$(sudo grep -E \\\'\\\\-a always,exit -F arch=b64 -S setfacl -F auid>=1000\\\' /etc/audit/rules.d/audit.rules)\n\nif [[ -n "$setfacl_audit" ]]; then\n    echo "Check: Ensure successful and unsuccessful attempts to use the setfacl command are recorded"\n    echo "Status: Pass"\n    echo "Current Value: Attempts to use the setfacl command are being logged"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure successful and unsuccessful attempts to use the setfacl command are recorded"\n    echo "Status: Fail"\n    echo "Current Value: Attempts to use the setfacl command are not being logged"\n    echo "Recommendation: Add auditing for setfacl command usage"\n    echo "Remediation: sudo echo \\\'-a always,exit -F arch=b64 -S setfacl -F auid>=1000\\\' >> /etc/audit/rules.d/audit.rules && sudo systemctl restart auditd"\nfi\n', '#!/bin/bash\n\n# Check if audit rules are set to log attempts to use the chacl command\nchacl_audit=$(sudo grep -E \\\'\\\\-a always,exit -F arch=b64 -S chacl -F auid>=1000\\\' /etc/audit/rules.d/audit.rules)\n\nif [[ -n "$chacl_audit" ]]; then\n    echo "Check: Ensure successful and unsuccessful attempts to use the chacl command are recorded"\n    echo "Status: Pass"\n    echo "Current Value: Attempts to use the chacl command are being logged"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure successful and unsuccessful attempts to use the chacl command are recorded"\n    echo "Status: Fail"\n    echo "Current Value: Attempts to use the chacl command are not being logged"\n    echo "Recommendation: Add auditing for chacl command usage"\n    echo "Remediation: sudo echo \\\'-a always,exit -F arch=b64 -S chacl -F auid>=1000\\\' >> /etc/audit/rules.d/audit.rules && sudo systemctl restart auditd"\nfi\n', '#!/bin/bash\n\n# Check if audit rules are set to log attempts to use the usermod command\nusermod_audit=$(sudo grep -E \\\'\\\\-a always,exit -F arch=b64 -S usermod -F auid>=1000\\\' /etc/audit/rules.d/audit.rules)\n\nif [[ -n "$usermod_audit" ]]; then\n    echo "Check: Ensure successful and unsuccessful attempts to use the usermod command are recorded"\n    echo "Status: Pass"\n    echo "Current Value: Attempts to use the usermod command are being logged"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure successful and unsuccessful attempts to use the usermod command are recorded"\n    echo "Status: Fail"\n    echo "Current Value: Attempts to use the usermod command are not being logged"\n    echo "Recommendation: Add auditing for usermod command usage"\n    echo "Remediation: sudo echo \\\'-a always,exit -F arch=b64 -S usermod -F auid>=1000\\\' >> /etc/audit/rules.d/audit.rules && sudo systemctl restart auditd"\nfi\n', '#!/bin/bash\n\n# Check if audit rules are set to log kernel module loading, unloading, and modification\nkernel_module_audit=$(sudo grep -E \\\'\\\\-a always,exit -F arch=b64 -S init_module,delete_module -F auid>=1000\\\' /etc/audit/rules.d/audit.rules)\n\nif [[ -n "$kernel_module_audit" ]]; then\n    echo "Check: Ensure kernel module loading, unloading, and modification is collected"\n    echo "Status: Pass"\n    echo "Current Value: Kernel module loading, unloading, and modification events are being logged"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure kernel module loading, unloading, and modification is collected"\n    echo "Status: Fail"\n    echo "Current Value: Kernel module loading, unloading, and modification events are not being logged"\n    echo "Recommendation: Add auditing for kernel module loading, unloading, and modification"\n    echo "Remediation: sudo echo \\\'-a always,exit -F arch=b64 -S init_module,delete_module -F auid>=1000\\\' >> /etc/audit/rules.d/audit.rules && sudo systemctl restart auditd"\nfi\n', '#!/bin/bash\n\n# Check if the audit configuration is immutable by checking file attributes\naudit_config_immutable=$(sudo lsattr /etc/audit/audit.rules /etc/audit/rules.d/* | grep -E \\\'^[^i]\\\')\n\nif [[ -z "$audit_config_immutable" ]]; then\n    echo "Check: Ensure the audit configuration is immutable"\n    echo "Status: Pass"\n    echo "Current Value: The audit configuration is immutable"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure the audit configuration is immutable"\n    echo "Status: Fail"\n    echo "Current Value: The audit configuration is not immutable"\n    echo "Recommendation: Set immutable flag on the audit configuration"\n    echo "Remediation: sudo chattr +i /etc/audit/audit.rules /etc/audit/rules.d/*"\nfi\n', '#!/bin/bash\n\n# Check if the audit configuration in memory (running) is the same as the on-disk configuration\nrunning_config=$(sudo auditctl -l)\ndisk_config=$(cat /etc/audit/audit.rules)\n\nif [[ "$running_config" == "$disk_config" ]]; then\n    echo "Check: Ensure the running and on-disk configuration is the same"\n    echo "Status: Pass"\n    echo "Current Value: Running and on-disk audit configuration match"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure the running and on-disk configuration is the same"\n    echo "Status: Fail"\n    echo "Current Value: Running and on-disk audit configuration do not match"\n    echo "Recommendation: Sync the audit configuration"\n    echo "Remediation: sudo auditctl -R /etc/audit/audit.rules"\nfi\n', '#!/bin/bash\n\n# Check if audit log files are set to mode 0640 or less permissive\nlog_files=$(sudo find /var/log/audit/ -type f -exec stat -c "%a %n" {} \\\\; | awk \\\'$1 > 640 {print $0}\\\')\n\nif [[ -z "$log_files" ]]; then\n    echo "Check: Ensure audit log files are mode 0640 or less permissive"\n    echo "Status: Pass"\n    echo "Current Value: Audit log files have correct permissions (0640 or less)"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure audit log files are mode 0640 or less permissive"\n    echo "Status: Fail"\n    echo "Current Value: Some audit log files have permissions more permissive than 0640"\n    echo "Recommendation: Set the permissions of the audit log files to 0640 or less permissive"\n    echo "Remediation: sudo chmod 0640 $(echo "$log_files" | awk \\\'{print $2}\\\')"\nfi\n', '#!/bin/bash\n\n# Define authorized user for audit logs\nauthorized_user="root"\n\n# Check the ownership of audit log files\nlog_files=$(sudo find /var/log/audit/ -type f -exec stat -c "%U %n" {} \\\\; | awk -v user="$authorized_user" \\\'$1 != user {print $0}\\\')\n\nif [[ -z "$log_files" ]]; then\n    echo "Check: Ensure only authorized users own audit log files"\n    echo "Status: Pass"\n    echo "Current Value: Audit log files are owned by authorized users"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure only authorized users own audit log files"\n    echo "Status: Fail"\n    echo "Current Value: Some audit log files are not owned by authorized users"\n    echo "Recommendation: Change the ownership of the audit log files to authorized users"\n    echo "Remediation: sudo chown root:root $(echo "$log_files" | awk \\\'{print $2}\\\')"\nfi\n', '#!/bin/bash\n\n# Define authorized group for audit logs\nauthorized_group="root"\n\n# Check the group ownership of audit log files\nlog_files=$(sudo find /var/log/audit/ -type f -exec stat -c "%G %n" {} \\\\; | awk -v group="$authorized_group" \\\'$1 != group {print $0}\\\')\n\nif [[ -z "$log_files" ]]; then\n    echo "Check: Ensure only authorized groups are assigned ownership of audit log files"\n    echo "Status: Pass"\n    echo "Current Value: Audit log files are assigned to authorized groups"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure only authorized groups are assigned ownership of audit log files"\n    echo "Status: Fail"\n    echo "Current Value: Some audit log files are not assigned to authorized groups"\n    echo "Recommendation: Change the group ownership of the audit log files to authorized groups"\n    echo "Remediation: sudo chown :root $(echo "$log_files" | awk \\\'{print $2}\\\')"\nfi\n', '#!/bin/bash\n\n# Check the permissions of the audit log directory\nlog_dir_permissions=$(sudo stat -c "%a" /var/log/audit)\n\nif [[ "$log_dir_permissions" -le 750 ]]; then\n    echo "Check: Ensure the audit log directory is 0750 or more restrictive"\n    echo "Status: Pass"\n    echo "Current Value: Audit log directory permissions are set to $log_dir_permissions"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure the audit log directory is 0750 or more restrictive"\n    echo "Status: Fail"\n    echo "Current Value: Audit log directory permissions are set to $log_dir_permissions"\n    echo "Recommendation: Set the audit log directory permissions to 0750 or more restrictive"\n    echo "Remediation: sudo chmod 0750 /var/log/audit"\nfi\n', '#!/bin/bash\n\n# Check the permissions of audit configuration files\nconfig_files=$(sudo find /etc/audit/ -type f -exec stat -c "%a %n" {} \\\\; | awk \\\'$1 > 640 {print $0}\\\')\n\nif [[ -z "$config_files" ]]; then\n    echo "Check: Ensure audit configuration files are 640 or more restrictive"\n    echo "Status: Pass"\n    echo "Current Value: Audit configuration files have correct permissions (640 or more restrictive)"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure audit configuration files are 640 or more restrictive"\n    echo "Status: Fail"\n    echo "Current Value: Some audit configuration files have permissions more permissive than 640"\n    echo "Recommendation: Set the permissions of audit configuration files to 640 or more restrictive"\n    echo "Remediation: sudo chmod 0640 $(echo "$config_files" | awk \\\'{print $2}\\\')"\nfi\n', '#!/bin/bash\n\n# Check the ownership of audit configuration files\nunauthorized_files=$(sudo find /etc/audit/ -type f -exec stat -c "%U %n" {} \\\\; | awk \\\'$1 != "root" {print $0}\\\')\n\nif [[ -z "$unauthorized_files" ]]; then\n    echo "Check: Ensure audit configuration files are owned by root"\n    echo "Status: Pass"\n    echo "Current Value: All audit configuration files are owned by root"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure audit configuration files are owned by root"\n    echo "Status: Fail"\n    echo "Current Value: Some audit configuration files are not owned by root"\n    echo "Recommendation: Set ownership of audit configuration files to root"\n    echo "Remediation: sudo chown root:root $(echo "$unauthorized_files" | awk \\\'{print $2}\\\')"\nfi\n', '#!/bin/bash\n\n# Check the group ownership of audit configuration files\nunauthorized_files=$(sudo find /etc/audit/ -type f -exec stat -c "%G %n" {} \\\\; | awk \\\'$1 != "root" {print $0}\\\')\n\nif [[ -z "$unauthorized_files" ]]; then\n    echo "Check: Ensure audit configuration files belong to group root"\n    echo "Status: Pass"\n    echo "Current Value: All audit configuration files belong to group root"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure audit configuration files belong to group root"\n    echo "Status: Fail"\n    echo "Current Value: Some audit configuration files do not belong to group root"\n    echo "Recommendation: Set the group ownership of audit configuration files to root"\n    echo "Remediation: sudo chgrp root $(echo "$unauthorized_files" | awk \\\'{print $2}\\\')"\nfi\n', '#!/bin/bash\n\n# Check the permissions of audit tools\nunauthorized_tools=$(sudo find /sbin /usr/sbin -type f -name "audit*" -exec stat -c "%a %n" {} \\\\; | awk \\\'$1 > 755 {print $0}\\\')\n\nif [[ -z "$unauthorized_tools" ]]; then\n    echo "Check: Ensure audit tools are 755 or more restrictive"\n    echo "Status: Pass"\n    echo "Current Value: All audit tools have correct permissions (755 or more restrictive)"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure audit tools are 755 or more restrictive"\n    echo "Status: Fail"\n    echo "Current Value: Some audit tools have permissions more permissive than 755"\n    echo "Recommendation: Set the permissions of audit tools to 755 or more restrictive"\n    echo "Remediation: sudo chmod 0755 $(echo "$unauthorized_tools" | awk \\\'{print $2}\\\')"\nfi\n', '#!/bin/bash\n\n# Check the ownership of audit tools\nunauthorized_tools=$(sudo find /sbin /usr/sbin -type f -name "audit*" -exec stat -c "%U %n" {} \\\\; | awk \\\'$1 != "root" {print $0}\\\')\n\nif [[ -z "$unauthorized_tools" ]]; then\n    echo "Check: Ensure audit tools are owned by root"\n    echo "Status: Pass"\n    echo "Current Value: All audit tools are owned by root"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure audit tools are owned by root"\n    echo "Status: Fail"\n    echo "Current Value: Some audit tools are not owned by root"\n    echo "Recommendation: Set ownership of audit tools to root"\n    echo "Remediation: sudo chown root:root $(echo "$unauthorized_tools" | awk \\\'{print $2}\\\')"\nfi\n', '#!/bin/bash\n\n# Check the group ownership of audit tools\nunauthorized_tools=$(sudo find /sbin /usr/sbin -type f -name "audit*" -exec stat -c "%G %n" {} \\\\; | awk \\\'$1 != "root" {print $0}\\\')\n\nif [[ -z "$unauthorized_tools" ]]; then\n    echo "Check: Ensure audit tools belong to group root"\n    echo "Status: Pass"\n    echo "Current Value: All audit tools belong to group root"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure audit tools belong to group root"\n    echo "Status: Fail"\n    echo "Current Value: Some audit tools do not belong to group root"\n    echo "Recommendation: Set the group ownership of audit tools to root"\n    echo "Remediation: sudo chgrp root $(echo "$unauthorized_tools" | awk \\\'{print $2}\\\')"\nfi\n']

def powershell_run_script(command):
    """Runs a PowerShell command and checks its compliance status."""
    script = ['bash','-c', command]
    try:
        result = subprocess.run(
            script,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        # Log output and errors for debugging
        print(f"Command Output: {result.stdout}")
        print(f"Command Error: {result.stderr}")
        
        if result.returncode == 0 and "Pass" in result.stdout:
            return 1  
        else:
            return 0  
    except Exception as e:
        print(f"Error executing command: {e}")
        return None

def run_redhat_9():
    """Runs compliance checks and generates an audit report."""
    pass_count = 0
    fail_count = 0
    results = {"cis_index": [], "title": [], "status": []}
    
    for i in range(len(cis_index)):
        # Append results incrementally
        results["cis_index"].append(cis_index[i])
        results["title"].append(title[i])
        status = powershell_run_script(code[i])
        results["status"].append("Pass" if status == 1 else "Fail")
        
        if status == 1:
            pass_count += 1
        else:
            fail_count += 1
    
    # Create a DataFrame for the results
    df = pd.DataFrame(data=results)
    filename = os.path.join("./", f"audit_file_{datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}.csv")
    df.to_csv(filename, index=False)
    
    print("Stats:-")
    print("Pass count:", pass_count)
    print("Fail count:", fail_count)
    print(f"Compliance Percentage: {(pass_count / (pass_count + fail_count)) * 100:.2f}%")
    print(f"Audit report saved to {filename}")

run_redhat_9()
print(len(title),len(cis_index),len(code))