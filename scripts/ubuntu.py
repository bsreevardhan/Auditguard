import subprocess
import pandas as pd
import datetime
import os 

cis_index = ['2.1.1', '2.1.2', '2.1.2', '2.1.3', '2.1.4', '1.1.1.1', '3.1.1', '2.1.5', '2.1.6', '1.1.1.2', '2.1.7', '3.1.2', '1.1.1.3', '2.1.8', '3.1.3', '1.1.1.4', '2.1.9 ', '2.1.10', '3.2.1', '2.1.11', '2.1.12', '3.2.2', '2.1.13', '2.1.14', '2.1.15', '3.2.3', '1.1.1.6', '3.2.4', '2.1.16', '1.1.1.7', '2.1.17', '2.1.18', '3.3.1', '2.1.19', '3.3.2', '2.1.20', '3.3.3', '2.1.21', '2.1.22', '3.3.4', '2.2.1', '2.2.2', '3.3.5', '2.2.3', '3.3.6', '2.2.4', '3.3.7', '2.2.5', '3.3.8 ', '2.2.6', '3.3.9', '1.1.1.5', '1.1.1.8', '1.1.2.1.1', '3.3.10', '1.1.2.1.2', '3.3.11', '4.1.1', '1.1.2.1.3', '4.1.2', '1.1.2.1.4', '4.1.3', '1.1.2.2.1', '1.1.2.2.1', '4.1.4', '4.1.4', '1.1.2.2.3', '4.1.5', '4.1.6 ', '1.1.2.2.4', '4.1.7 ', '4.2.1', '1.1.2.3.1', '4.2.2 ', '1.1.2.3.2', '1.1.2.3.3', '1.1.2.4.1', '4.2.3 ', '1.1.2.4.2', '4.2.4 ', '1.1.2.4.3', '4.2.5 ', '4.2.6', '4.2.7 ', '1.1.2.5.1', '1.1.2.5.2', '1.1.2.5.3', '1.1.2.5.4', '1.1.2.6.1', '4.2.8 ', '4.2.9 ', '4.2.10', '4.3.1.1', '1.1.2.6.2', '1.1.2.6.3 ', '1.1.2.6.4 ', '1.1.2.7.1', '1.1.2.7.2 ', '1.1.2.7.3 ', '1.1.2.7.4 ', '1.2.1.1 ', '1.2.1.2 ', '1.2.2.1', '1.3.1.1', '1.3.1.2 ', '1.3.1.3 ', '1.3.1.4 ', '1.4.1', '1.4.2 ', '2.3.1.1', '1.5.1 ', '1.5.2', '2.3.2.1', '1.5.3 ', '2.3.2.2', '1.5.4 ', '2.3.3.1', '2.3.3.2', '2.3.3.3 ', '1.5.5 ', '2.4.1.1', '1.6.1 ', '2.4.1.2', '2.4.1.3', '1.6.2 ', '2.4.1.4', '1.6.3 ', '2.4.1.5', '2.4.1.6', '1.6.4 ', '2.4.1.7', '1.6.5 ', '2.4.1.8', '1.6.6 ', '2.4.2.1', '1.7.1 ', '1.7.2 ', '1.7.3 ', '1.7.4 ', '1.7.5 ', '1.7.6 ', '1.7.7 ', '1.7.8 ', '1.7.9 ', '1.7.10 ', '4.3.1.2 ', '4.3.1.3 ', '4.3.2.1 ', '4.3.2.2 ', '4.3.2.3 ', '4.3.2.4 ', '4.3.3.1 ', '4.3.3.2 ', '4.3.3.3 ', '4.3.3.4 ', '5.1.1 ', '5.2.1', '5.2.2', '5.2.3', '5.2.4 ', '5.2.5', '5.2.6', '5.2.7 ', '5.3.1.1', '5.3.1.2 ', '5.3.1.3', '5.1.2 ', '5.1.3 ', '5.1.11', '5.1.4 ', '5.1.12', '5.1.5 ', '5.1.6 ', '5.1.13 ', '5.1.7 ', '5.1.14 ', '5.1.15', '5.1.8 ', '5.1.16', '5.1.17', '5.1.18 ', '5.1.9 ', '5.1.10 ', '5.1.19', '5.1.20', '5.1.21', '5.1.22', '7.1.1 ', '7.1.2', '7.1.3', '7.1.4 ', '7.1.5', '7.2.1 ', '7.1.6 ', '7.2.2 ', '7.1.7 ', '7.1.8 ', '7.2.3', '7.1.9 ', '7.1.10', '7.1.11 ', '7.1.12 ', '7.1.13 ', '7.2.4 ', '7.2.5 ', '7.2.6', '7.2.7', '7.2.8 ', '7.2.9 ', '7.2.10', '5.3.1.1', '5.3.1.2', '5.3.2.1', '5.3.2.2', '5.3.2.3', '5.3.2.4', '5.3.3.1.1', '5.3.3.1.2', '5.3.3.1.3', '5.3.3.2.1', '5.3.3.2.2', '5.3.3.2.3', '5.3.3.2.4', '5.3.3.2.5', '5.3.3.2.6', '5.3.3.2.7', '5.3.3.2.8', '5.3.3.3.1', '5.3.3.3.2', '5.3.3.3.3', '5.3.3.4.1', '5.3.3.4.2', '5.3.3.4.3', '5.3.3.4.4', '6.3.1.1', '6.3.4.10', '6.3.1.2', '6.3.4.9', '6.3.1.3', '6.3.4.8', '6.3.4.7', '6.3.1.4', '6.3.4.6', '6.3.4.5', '6.3.4.4', '1.3.1.4', '6.3.4.3', '1.7.6', '6.3.4.2', '6.3.4.1', '1.7.7', '6.3.3.21', '6.3.3.20', '5.2.4', '6.3.3.19', '6.3.3.18', '5.3.3.1.3', '6.3.3.17', '6.3.3.16', '6.3.3.15', '5.4.1.2', '6.3.3.14', '6.3.3.13', '5.4.3.1', '6.3.3.12', '6.1.3', '6.3.2.1', '6.3.2.2', '6.3.2.3', '6.3.2.4', '6.3.3.1', '6.3.3.2', '6.3.3.3', '4.1.1.1', '6.3.3.4', '6.3.3.5', '6.3.3.6', '6.3.3.7', '6.3.3.8', '6.3.3.9', '6.3.3.10', '6.3.3.11']
title = ['Ensure autofs services are not in use', 'Ensure avahi daemon services are not in use', 'Ensure avahi daemon services are not in use', 'Ensure dhcp server services are not in use', 'Ensure dns server services are not in use', 'Ensure cramfs kernel module is not available', 'Ensure IPv6 status is identified', 'Ensure dnsmasq services are not in use', 'Ensure ftp server services are not in use', 'Ensure freevxfs kernel module is not available', 'Ensure ldap server services are not in use', 'Ensure wireless interfaces are disabled', 'Ensure hfs kernel module is not available', 'Ensure message access server services are not in use', 'Ensure bluetooth services are not in use', 'Ensure hfsplus kernel module is not available', 'Ensure network file system services are not in use', ' Ensure nis server services are not in use', 'Ensure dccp kernel module is not available', 'Ensure print server services are not in use', 'Ensure rpcbind services are not in use', 'Ensure tipc kernel module is not available', 'Ensure rsync services are not in use', 'Ensure samba file server services are not in use', 'Ensure snmp services are not in use', 'Ensure rds kernel module is not available', 'Ensure squashfs kernel module is not available', 'Ensure sctp kernel module is not available', 'Ensure tftp server services are not in use', 'Ensure udf kernel module is not available', 'Ensure web proxy server services are not in use', 'Ensure web server services are not in use', 'Ensure ip forwarding is disabled', 'Ensure xinetd services are not in use', 'Ensure packet redirect sending is disabled', 'Ensure X window server services are not in use', 'Ensure bogus icmp responses are ignored', 'Ensure mail transfer agent is configured for local-only mode', 'Ensure only approved services are listening on a network interface', 'Ensure broadcast icmp requests are ignored', 'Ensure NIS Client is not installed', 'Ensure rsh client is not installed', 'Ensure icmp redirects are not accepted', 'Ensure talk client is not installed', 'Ensure secure icmp redirects are not accepted', 'Ensure telnet client is not installed', 'Ensure reverse path filtering is enabled', 'Ensure ldap client is not installed', 'Ensure source routed packets are not accepted', 'Ensure ftp client is not installed', 'Ensure suspicious packets are logged', 'Ensure jffs2 kernel module is not available', 'Ensure usb-storage kernel module is not available', ' Ensure /tmp is a separate partition', 'Ensure suspicious packets are logged', 'Ensure nodev option set on /tmp partition', 'ipv6 router advertisements are not accepted', 'Ensure ufw is installed', ' Ensure nosuid option set on /tmp partition', 'Ensure iptables-persistent is not installed with ufw', 'Ensure noexec option set on /tmp partition', 'Ensure ufw service is enabled', 'Ensure /dev/shm is a separate partition', 'Ensure /dev/shm is a separate partition', 'Ensure ufw loopback traffic is configured', 'Ensure ufw loopback traffic is configured', 'Ensure nosuid option set on /dev/shm partition', 'Ensure ufw outbound connections are configured', 'Ensure ufw firewall rules exist for all open ports', 'Ensure noexec option set on /dev/shm partition', 'Ensure ufw default deny firewall policy', 'Ensure nftables is installed', 'Ensure separate partition exists for /home', 'Ensure ufw is uninstalled or disabled with nftables', 'Ensure nodev option set on /home partition', 'Ensure nosuid option set on /home partition', 'Ensure separate partition exists for /var', 'Ensure iptables are flushed with nftables', 'Ensure nodev option set on /var partition', 'Ensure a nftables table exists', 'Ensure nosuid option set on /var partition', 'Ensure nftables base chains exist', 'Ensure nftables loopback traffic is configured', 'Ensure nftables outbound and established connections are configured', 'Ensure separate partition exists for /var/tmp', 'Ensure nodev option set on /var/tmp partition', 'Ensure nosuid option set on /var/tmp partition', 'Ensure noexec option set on /var/tmp partition', 'Ensure separate partition exists for /var/log', 'Ensure nftables default deny firewall policy', 'Ensure nftables service is enabled', 'Ensure nftables rules are permanent', 'Ensure iptables packages are installed', 'Ensure nodev option set on /var/log partition', 'Ensure nosuid option set on /var/log partition', 'noexec option set on /var/log partition', 'Ensure separate partition exists for /var/log/audit', 'Ensure nodev option set on /var/log/audit partition', 'Ensure nosuid option set on /var/log/audit partition', 'Ensure noexec option set on /var/log/audit partition', 'Ensure GPG keys are configured', 'Ensure package manager repositories are configured', 'Ensure updates, patches, and additional security software are installed', 'Ensure AppArmor is installed', 'Ensure AppArmor is enabled in the bootloader configuration', 'Ensure all AppArmor Profiles are in enforce or complain mode', 'Ensure all AppArmor Profiles are enforcing', 'Ensure bootloader password is set', 'Ensure access to bootloader config is configured', 'Ensure a single time synchronization daemon is in use', 'Ensure address space layout randomization is enabled', 'Ensure ptrace_scope is restricted', 'Ensure systemd-timesyncd configured with authorized timeserver', 'Ensure core dumps are restricted', 'Ensure systemd-timesyncd is enabled and running', 'Ensure prelink is not installed', ' Ensure chrony is configured with authorized timeserver', 'Ensure chrony is running as user _chrony', 'Ensure chrony is enabled and running', 'Ensure Automatic Error Reporting is not enabled', 'Ensure cron daemon is enabled and active', 'Ensure message of the day is configured properly', 'Ensure permissions on /etc/crontab are configured', 'Ensure permissions on /etc/cron.hourly are configured', 'Ensure local login warning banner is configured properly', 'Ensure permissions on /etc/cron.daily are configured', 'Ensure remote login warning banner is configured properly', 'Ensure permissions on /etc/cron.weekly are configured', 'Ensure permissions on /etc/cron.monthly are configured', 'Ensure access to /etc/motd is configured', 'Ensure permissions on /etc/cron.d are configured', 'Ensure access to /etc/issue is configured', 'Ensure crontab is restricted to authorized users', 'Ensure access to /etc/issue.net is configured', 'Ensure at is restricted to authorized users', 'Ensure GDM is removed', 'Ensure GDM login banner is configured', 'Ensure GDM disable-user-list option is enabled', 'Ensure GDM screen locks when the user is idle', 'Ensure GDM screen locks cannot be overridden', 'Ensure GDM automatic mounting of removable media is disabled', 'Ensure GDM disabling automatic mounting of removable media is not overridden', 'Ensure GDM autorun-never is enabled', 'Ensure GDM autorun-never is not overridden', 'Ensure XDCMP is not enabled', 'Ensure nftables is not installed with iptables', 'Ensure ufw is uninstalled or disabled with iptables', 'Ensure iptables default deny firewall policy', 'Ensure iptables loopback traffic is configured', ' Ensure iptables outbound and established connections are configured', 'Ensure iptables firewall rules exist for all open ports', 'Ensure ip6tables default deny firewall policy', 'Ensure ip6tables loopback traffic is configured', 'Ensure ip6tables outbound and established connections are configured', 'Ensure ip6tables firewall rules exist for all open ports', 'Ensure permissions on /etc/ssh/sshd_config are configured', 'Ensure sudo is installed', 'Ensure sudo commands use pty', ' Ensure sudo log file exists', 'Ensure users must provide password for privilege escalation', 'Ensure re-authentication for privilege escalation is not disabled globally', 'Ensure sudo authentication timeout is configured correctly', 'Ensure access to the su command is restricted', 'Ensure latest version of pam is installed', 'Ensure libpam-modules is installed', 'Ensure libpam-pwquality is installed', 'Ensure permissions on SSH private host key files are configured', 'Ensure permissions on SSH public host key files are configured', 'Ensure sshd IgnoreRhosts is enabled', 'Ensure sshd access is configured', 'Ensure sshd KexAlgorithms is configured', 'Ensure sshd Banner is configured', 'Ensure sshd Ciphers are configured', 'Ensure sshd LoginGraceTime is configured', 'Ensure sshd ClientAliveInterval and ClientAliveCountMax are configured', 'Ensure sshd LogLevel is configured', 'Ensure sshd MACs are configured', 'Ensure sshd DisableForwarding is enabled', 'Ensure sshd MaxAuthTries is configured', 'Ensure sshd MaxSessions is configured', 'Ensure sshd MaxStartups is configured', 'Ensure sshd GSSAPIAuthentication is disabled', 'Ensure sshd HostbasedAuthentication is disabled', 'Ensure sshd PermitEmptyPasswords is disabled', 'Ensure sshd PermitRootLogin is disabled', 'Ensure sshd PermitUserEnvironment is disabled', ' Ensure sshd UsePAM is enabled', 'Ensure permissions on /etc/passwd are configured', 'Ensure permissions on /etc/passwd- are configured', 'Ensure permissions on /etc/group are configured', 'Ensure permissions on /etc/group- are configured', 'Ensure permissions on /etc/shadow are configured', 'Ensure accounts in /etc/passwd use shadowed passwords', 'Ensure permissions on /etc/shadow- are configured', 'Ensure /etc/shadow password fields are not empty', 'Ensure permissions on /etc/gshadow are configured', 'Ensure permissions on /etc/gshadow- are configured', 'Ensure all groups in /etc/passwd exist in /etc/group', 'Ensure permissions on /etc/shells are configured', 'Ensure permissions on /etc/security/opasswd are configured', 'Ensure world writable files and directories are secured', 'Ensure no files or directories without an owner and a group exist', 'Ensure SUID and SGID files are reviewed', 'Ensure shadow group is empty', 'Ensure no duplicate UIDs exist', 'Ensure no duplicate GIDs exist', 'Ensure no duplicate user names exist', 'Ensure no duplicate group names exist', 'Ensure local interactive user home directories are configured', 'Ensure local interactive user dot files access is configured', 'Ensure latest version of pam is installed', 'Ensure libpam-modules is installed', 'Ensure pam_unix module is enabled', 'Ensure pam_faillock module is enabled', 'Ensure pam_pwquality module is enabled', 'Ensure pam_pwhistory module is enabled', 'Ensure password failed attempts lockout is configured', 'Ensure password unlock time is configured', 'Ensure password failed attempts lockout includes root account', 'Ensure password number of changed characters is configured', 'Ensure minimum password length is configured', 'Ensure password complexity is configured', 'Ensure password same consecutive characters is configured', 'Ensure password maximum sequential characters is configured', 'Ensure password dictionary check is enabled', 'Ensure password quality checking is enforced', 'Ensure password quality is enforced for the root user', 'Ensure password history remember is configured', 'Ensure password history is enforced for the root user', 'Ensure pam_pwhistory includes use_authtok', 'Ensure pam_unix does not include nullok', 'Ensure pam_unix does not include remember', 'Ensure pam_unix includes a strong password hashing algorithm', 'Ensure pam_unix includes use_authtok', 'Ensure auditd packages are installed', 'Ensure audit tools group owner is configured', 'Ensure auditd service is enabled and active', 'Ensure audit tools owner is configured', ' Ensure auditing for processes that start prior to auditd is enabled', 'Ensure audit tools mode is configured', 'Ensure audit configuration files group owner is configured', 'Ensure audit_backlog_limit is sufficient', 'Ensure audit configuration files owner is configured', 'Ensure audit configuration files mode is configured', 'Ensure the audit log file directory mode is configured', 'Ensure all AppArmor Profiles are enforcing', 'Ensure audit log files group owner is configured', 'Ensure GDM automatic mounting of removable media is disabled', 'Ensure audit log files owner is configured', 'Ensure audit log files mode is configured', 'Ensure GDM disabling automatic mounting of removable media is not overridden', 'Ensure the running and on disk configuration is the same', 'Ensure the audit configuration is immutable', 'Ensure users must provide password for privilege escalation', 'Ensure kernel module loading unloading and modification is collected', 'Ensure successful and unsuccessful attempts to use the usermod command are recorded', 'Ensure password failed attempts lockout includes root account', 'Ensure successful and unsuccessful attempts to use the chacl command are recorded', 'Ensure successful and unsuccessful attempts to use the setfacl command are recorded', 'Ensure successful and unsuccessful attempts to use the chcon command are recorded', 'Ensure minimum password age is configured', "Ensure events that modify the system's Mandatory Access Controls are collected", 'Ensure file deletion events by users are collected', 'Ensure nologin is not listed in /etc/shells', 'Ensure login and logout events are collected', 'Ensure cryptographic mechanisms are used to protect the integrity of audit tools', ' Ensure audit log storage size is configured', 'Ensure audit logs are not automatically deleted', 'Ensure system is disabled when audit logs are full', 'Ensure system warns when audit logs are low on space', 'Ensure changes to system administration scope (sudoers) is collected', 'Ensure actions as another user are always logged', 'Ensure events that modify the sudo log file are collected', 'Ensure auditd is installed', 'Ensure events that modify date and time information are collected', "Ensure events that modify the system's network environment are collected", 'Ensure use of privileged commands are collected', 'Ensure unsuccessful file access attempts are collected', 'Ensure events that modify user/group information are collected', 'Ensure discretionary access control permission modification events are collected', 'Ensure successful file system mounts are collected', 'Ensure session initiation information is collected']
code = ['# Check if autofs services are running\ncheck_autofs_status() { \n if systemctl is-enabled autofs >/dev/null 2>&1; then \n echo "Check: Ensure autofs services are not in use" \n echo "Status: Fail" \n echo "Current Value: autofs service is enabled." \n echo "Expected Value: autofs service should be disabled or masked." \n echo "Recommendation: Disable the autofs service to harden the system." \n echo "Remediation:" \n echo "# sudo systemctl disable autofs" \n echo "# sudo systemctl stop autofs" \n echo "# sudo systemctl mask autofs" \n else \n echo "Check: Ensure autofs services are not in use" \n echo "Status: Pass" \n echo "Current Value: autofs service is not enabled." \n echo "Expected Value: autofs service should be disabled or masked." \n echo "Recommendation: No remediation required." \n fi \n}\n\n# Execute the check\ncheck_autofs_status', '# Check if Avahi daemon services are running\ncheck_avahi_status() { \n if systemctl is-enabled avahi-daemon >/dev/null 2>&1; then \n echo "Check: Ensure Avahi daemon services are not in use" \n echo "Status: Fail" \n echo "Current Value: Avahi daemon service is enabled." \n echo "Expected Value: Avahi daemon service should be disabled or masked." \n echo "Recommendation: Disable the Avahi daemon service to harden the system." \n echo "Remediation:" \n echo "# sudo systemctl disable avahi-daemon" \n echo "# sudo systemctl stop avahi-daemon" \n echo "# sudo systemctl mask avahi-daemon" \n else \n echo "Check: Ensure Avahi daemon services are not in use" \n echo "Status: Pass" \n echo "Current Value: Avahi daemon service is not enabled." \n echo "Expected Value: Avahi daemon service should be disabled or masked." \n echo "Recommendation: No remediation required." \n fi \n}\n\n# Execute the check\ncheck_avahi_status', '#!/bin/bash\\n\\ncheck_ntp_access_control() {\\n    if [[ -f /etc/ntp.conf ]]; then\\n        if grep -qE "^(restrict\\\\s+.*)" /etc/ntp.conf; then\\n            echo "Check: Ensure ntp access control is configured"\\n            echo "Status: Pass"\\n            echo "Current Value: Access control configured in /etc/ntp.conf."\\n            echo "Recommendation: No remediation required."\\n        else\\n            echo "Check: Ensure ntp access control is configured"\\n            echo "Status: Fail"\\n            echo "Current Value: No access control configured in /etc/ntp.conf."\\n            echo "Recommendation: Configure access control in /etc/ntp.conf."\\n            echo "Remediation:"\\n            echo "# Add \'restrict\' directives to /etc/ntp.conf as needed."\\n        fi\\n    else\\n        echo "Check: Ensure ntp access control is configured"\\n        echo "Status: Fail"\\n        echo "Current Value: /etc/ntp.conf not found."\\n        echo "Recommendation: Install and configure NTP."\\n        echo "Remediation:"\\n        echo "# sudo apt install ntp  # For Debian-based systems"\\n        echo "# sudo yum install ntp  # For Red Hat-based systems"\\n    fi\\n}\\n\\ncheck_ntp_access_control\\n', '# Check if DHCP server services are running\ncheck_dhcp_status() { \n if systemctl is-enabled isc-dhcp-server >/dev/null 2>&1 || systemctl is-enabled dhcpd >/dev/null 2>&1; then \n echo "Check: Ensure DHCP server services are not in use" \n echo "Status: Fail" \n echo "Current Value: DHCP server service is enabled." \n echo "Expected Value: DHCP server service should be disabled or masked." \n echo "Recommendation: Disable the DHCP server service to harden the system." \n echo "Remediation:" \n echo "# sudo systemctl disable isc-dhcp-server" \n echo "# sudo systemctl stop isc-dhcp-server" \n echo "# sudo systemctl mask isc-dhcp-server" \n echo "# sudo systemctl disable dhcpd" \n echo "# sudo systemctl stop dhcpd" \n echo "# sudo systemctl mask dhcpd" \n else \n echo "Check: Ensure DHCP server services are not in use" \n echo "Status: Pass" \n echo "Current Value: DHCP server service is not enabled." \n echo "Expected Value: DHCP server service should be disabled or masked." \n echo "Recommendation: No remediation required." \n fi \n}\n\n# Execute the check\ncheck_dhcp_status', '# Check if DNS server services are running\ncheck_dns_status() { \n if systemctl is-enabled bind9 >/dev/null 2>&1 || systemctl is-enabled named >/dev/null 2>&1; then \n echo "Check: Ensure DNS server services are not in use" \n echo "Status: Fail" \n echo "Current Value: DNS server service is enabled." \n echo "Expected Value: DNS server service should be disabled or masked." \n echo "Recommendation: Disable the DNS server service to harden the system." \n echo "Remediation:" \n echo "# sudo systemctl disable bind9" \n echo "# sudo systemctl stop bind9" \n echo "# sudo systemctl mask bind9" \n echo "# sudo systemctl disable named" \n echo "# sudo systemctl stop named" \n echo "# sudo systemctl mask named" \n else \n echo "Check: Ensure DNS server services are not in use" \n echo "Status: Pass" \n echo "Current Value: DNS server service is not enabled." \n echo "Expected Value: DNS server service should be disabled or masked." \n echo "Recommendation: No remediation required." \n fi \n}\n\n# Execute the check\ncheck_dns_status', '#!/bin/bash\nmodule="cramfs"\nif lsmod | grep -wq "$module"; then\n    echo "Check: Ensure $module kernel module is not available"\n    echo "Status: Fail"\n    echo "Current Value: $module kernel module is loaded."\n    echo "Expected Value: $module kernel module should not be loaded."\n    echo "Recommendation: Ensure that the $module kernel module is disabled."\n    echo "Remediation:"\n    echo "  # Add the following line to /etc/modprobe.d/$module.conf:"\n    echo "  blacklist $module"\n    echo "  # Prevent loading immediately by running:"\n    echo "  sudo rmmod $module"\n    echo "  # Update the initramfs with:"\n    echo "  sudo update-initramfs -u"\nelse\n    echo "Check: Ensure $module kernel module is not available"\n    echo "Status: Pass"\n    echo "Current Value: $module kernel module is not loaded."\n    echo "Expected Value: $module kernel module should not be loaded."\n    echo "Recommendation: No action needed."\nfi\n', '#!/bin/bash\n\ncheck_ipv6_status() {\n    ipv6_status=$(sysctl -a | grep net.ipv6.conf.all.disable_ipv6)\n\n    if [[ "$ipv6_status" == *"net.ipv6.conf.all.disable_ipv6 = 1"* ]]; then\n        echo "Check: Ensure IPv6 status is identified"\n        echo "Status: Pass"\n        echo "Current Value: IPv6 is disabled."\n        echo "Expected Value: IPv6 should be disabled if not in use."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure IPv6 status is identified"\n        echo "Status: Fail"\n        echo "Current Value: IPv6 is enabled."\n        echo "Expected Value: IPv6 should be disabled if not in use."\n        echo "Recommendation: Disable IPv6 if not needed."\n        echo "Remediation:"\n        echo "# sudo sysctl -w net.ipv6.conf.all.disable_ipv6=1"\n    fi\n}\n\n# Execute the check\ncheck_ipv6_status', '# Check if dnsmasq services are running\ncheck_dnsmasq_status() { \n if systemctl is-enabled dnsmasq >/dev/null 2>&1; then \n echo "Check: Ensure dnsmasq services are not in use" \n echo "Status: Fail" \n echo "Current Value: dnsmasq service is enabled." \n echo "Expected Value: dnsmasq service should be disabled or masked." \n echo "Recommendation: Disable the dnsmasq service to harden the system." \n echo "Remediation:" \n echo "# sudo systemctl disable dnsmasq" \n echo "# sudo systemctl stop dnsmasq" \n echo "# sudo systemctl mask dnsmasq" \n else \n echo "Check: Ensure dnsmasq services are not in use" \n echo "Status: Pass" \n echo "Current Value: dnsmasq service is not enabled." \n echo "Expected Value: dnsmasq service should be disabled or masked." \n echo "Recommendation: No remediation required." \n fi \n}\n\n# Execute the check\ncheck_dnsmasq_status', '# Check if FTP server services are running\ncheck_ftp_status() { \n if systemctl is-enabled vsftpd >/dev/null 2>&1 || systemctl is-enabled proftpd >/dev/null 2>&1 || systemctl is-enabled pure-ftpd >/dev/null 2>&1; then \n echo "Check: Ensure FTP server services are not in use" \n echo "Status: Fail" \n echo "Current Value: FTP server service is enabled." \n echo "Expected Value: FTP server service should be disabled or masked." \n echo "Recommendation: Disable the FTP server service to harden the system." \n echo "Remediation:" \n echo "# sudo systemctl disable vsftpd" \n echo "# sudo systemctl stop vsftpd" \n echo "# sudo systemctl mask vsftpd" \n echo "# sudo systemctl disable proftpd" \n echo "# sudo systemctl stop proftpd" \n echo "# sudo systemctl mask proftpd" \n echo "# sudo systemctl disable pure-ftpd" \n echo "# sudo systemctl stop pure-ftpd" \n echo "# sudo systemctl mask pure-ftpd" \n else \n echo "Check: Ensure FTP server services are not in use" \n echo "Status: Pass" \n echo "Current Value: FTP server service is not enabled." \n echo "Expected Value: FTP server service should be disabled or masked." \n echo "Recommendation: No remediation required." \n fi \n}\n\n# Execute the check\ncheck_ftp_status', '#!/bin/bash\nmodule="freevxfs"\nif lsmod | grep -wq "$module"; then\n    echo "Check: Ensure $module kernel module is not available"\n    echo "Status: Fail"\n    echo "Current Value: $module kernel module is loaded."\n    echo "Expected Value: $module kernel module should not be loaded."\n    echo "Recommendation: Ensure that the $module kernel module is disabled."\n    echo "Remediation:"\n    echo "  # Add the following line to /etc/modprobe.d/$module.conf:"\n    echo "  blacklist $module"\n    echo "  # Prevent loading immediately by running:"\n    echo "  sudo rmmod $module"\n    echo "  # Update the initramfs with:"\n    echo "  sudo update-initramfs -u"\nelse\n    echo "Check: Ensure $module kernel module is not available"\n    echo "Status: Pass"\n    echo "Current Value: $module kernel module is not loaded."\n    echo "Expected Value: $module kernel module should not be loaded."\n    echo "Recommendation: No action needed."\nfi\n', '# Check if LDAP server services are running\ncheck_ldap_status() { \n if systemctl is-enabled slapd >/dev/null 2>&1; then \n echo "Check: Ensure LDAP server services are not in use" \n echo "Status: Fail" \n echo "Current Value: LDAP server service is enabled." \n echo "Expected Value: LDAP server service should be disabled or masked." \n echo "Recommendation: Disable the LDAP server service to harden the system." \n echo "Remediation:" \n echo "# sudo systemctl disable slapd" \n echo "# sudo systemctl stop slapd" \n echo "# sudo systemctl mask slapd" \n else \n echo "Check: Ensure LDAP server services are not in use" \n echo "Status: Pass" \n echo "Current Value: LDAP server service is not enabled." \n echo "Expected Value: LDAP server service should be disabled or masked." \n echo "Recommendation: No remediation required." \n fi \n}\n\n# Execute the check\ncheck_ldap_status', '#!/bin/bash\n\ncheck_wireless_interfaces() {\n    wireless_interfaces=$(iw dev | grep Interface)\n\n    if [[ -n "$wireless_interfaces" ]]; then\n        echo "Check: Ensure wireless interfaces are disabled"\n        echo "Status: Fail"\n        echo "Current Value: Wireless interfaces are enabled."\n        echo "Expected Value: Wireless interfaces should be disabled if not in use."\n        echo "Recommendation: Disable wireless interfaces if not needed."\n        echo "Remediation:"\n        echo "# sudo ip link set <interface> down"\n        echo "# sudo nmcli radio wifi off"\n    else\n        echo "Check: Ensure wireless interfaces are disabled"\n        echo "Status: Pass"\n        echo "Current Value: No wireless interfaces are enabled."\n        echo "Expected Value: Wireless interfaces should be disabled if not in use."\n        echo "Recommendation: No remediation required."\n    fi\n}\n\n# Execute the check\ncheck_wireless_interfaces', '#!/bin/bash\nmodule="hfs"\nif lsmod | grep -wq "$module"; then\n    echo "Check: Ensure $module kernel module is not available"\n    echo "Status: Fail"\n    echo "Current Value: $module kernel module is loaded."\n    echo "Expected Value: $module kernel module should not be loaded."\n    echo "Recommendation: Ensure that the $module kernel module is disabled."\n    echo "Remediation:"\n    echo "  # Add the following line to /etc/modprobe.d/$module.conf:"\n    echo "  blacklist $module"\n    echo "  # Prevent loading immediately by running:"\n    echo "  sudo rmmod $module"\n    echo "  # Update the initramfs with:"\n    echo "  sudo update-initramfs -u"\nelse\n    echo "Check: Ensure $module kernel module is not available"\n    echo "Status: Pass"\n    echo "Current Value: $module kernel module is not loaded."\n    echo "Expected Value: $module kernel module should not be loaded."\n    echo "Recommendation: No action needed."\nfi\n', '# Check if Message Access Server services are running\ncheck_imap_pop_status() { \n if systemctl is-enabled dovecot >/dev/null 2>&1; then \n echo "Check: Ensure Message Access Server services are not in use" \n echo "Status: Fail" \n echo "Current Value: Message Access Server service is enabled." \n echo "Expected Value: Message Access Server service should be disabled or masked." \n echo "Recommendation: Disable the Message Access Server service to harden the system." \n echo "Remediation:" \n echo "# sudo systemctl disable dovecot" \n echo "# sudo systemctl stop dovecot" \n echo "# sudo systemctl mask dovecot" \n else \n echo "Check: Ensure Message Access Server services are not in use" \n echo "Status: Pass" \n echo "Current Value: Message Access Server service is not enabled." \n echo "Expected Value: Message Access Server service should be disabled or masked." \n echo "Recommendation: No remediation required." \n fi \n}\n\n# Execute the check\ncheck_imap_pop_status', '#!/bin/bash\n\ncheck_bluetooth_services() {\n    bluetooth_status=$(systemctl is-active bluetooth)\n\n    if [[ "$bluetooth_status" == "active" ]]; then\n        echo "Check: Ensure Bluetooth services are not in use"\n        echo "Status: Fail"\n        echo "Current Value: Bluetooth service is active."\n        echo "Expected Value: Bluetooth service should be inactive or stopped if not in use."\n        echo "Recommendation: Disable Bluetooth service if not needed."\n        echo "Remediation:"\n        echo "# sudo systemctl stop bluetooth"\n        echo "# sudo systemctl disable bluetooth"\n    else\n        echo "Check: Ensure Bluetooth services are not in use"\n        echo "Status: Pass"\n        echo "Current Value: Bluetooth service is inactive."\n        echo "Expected Value: Bluetooth service should be inactive or stopped if not in use."\n        echo "Recommendation: No remediation required."\n    fi\n}\n\n# Execute the check\ncheck_bluetooth_services', '#!/bin/bash\nmodule="hfsplus"\nif lsmod | grep -wq "$module"; then\n    echo "Check: Ensure $module kernel module is not available"\n    echo "Status: Fail"\n    echo "Current Value: $module kernel module is loaded."\n    echo "Expected Value: $module kernel module should not be loaded."\n    echo "Recommendation: Ensure that the $module kernel module is disabled."\n    echo "Remediation:"\n    echo "  # Add the following line to /etc/modprobe.d/$module.conf:"\n    echo "  blacklist $module"\n    echo "  # Prevent loading immediately by running:"\n    echo "  sudo rmmod $module"\n    echo "  # Update the initramfs with:"\n    echo "  sudo update-initramfs -u"\nelse\n    echo "Check: Ensure $module kernel module is not available"\n    echo "Status: Pass"\n    echo "Current Value: $module kernel module is not loaded."\n    echo "Expected Value: $module kernel module should not be loaded."\n    echo "Recommendation: No action needed."\nfi\n', '# Check if NFS services are running\ncheck_nfs_status() { \n if systemctl is-enabled nfs-server >/dev/null 2>&1; then \n echo "Check: Ensure Network File System services are not in use" \n echo "Status: Fail" \n echo "Current Value: NFS service is enabled." \n echo "Expected Value: NFS service should be disabled or masked." \n echo "Recommendation: Disable the NFS service to harden the system." \n echo "Remediation:" \n echo "# sudo systemctl disable nfs-server" \n echo "# sudo systemctl stop nfs-server" \n echo "# sudo systemctl mask nfs-server" \n else \n echo "Check: Ensure Network File System services are not in use" \n echo "Status: Pass" \n echo "Current Value: NFS service is not enabled." \n echo "Expected Value: NFS service should be disabled or masked." \n echo "Recommendation: No remediation required." \n fi \n}\n\n# Execute the check\ncheck_nfs_status', '# Check if NIS services are running\ncheck_nis_status() { \n if systemctl is-enabled ypserv >/dev/null 2>&1; then \n echo "Check: Ensure NIS server services are not in use" \n echo "Status: Fail" \n echo "Current Value: NIS server service is enabled." \n echo "Expected Value: NIS server service should be disabled or masked." \n echo "Recommendation: Disable the NIS server service to harden the system." \n echo "Remediation:" \n echo "# sudo systemctl disable ypserv" \n echo "# sudo systemctl stop ypserv" \n echo "# sudo systemctl mask ypserv" \n else \n echo "Check: Ensure NIS server services are not in use" \n echo "Status: Pass" \n echo "Current Value: NIS server service is not enabled." \n echo "Expected Value: NIS server service should be disabled or masked." \n echo "Recommendation: No remediation required." \n fi \n}\n\n# Execute the check\ncheck_nis_status', '#!/bin/bash\nmodule="jffs2"\nif lsmod | grep -wq "$module"; then\n    echo "Check: Ensure jffs2 kernel module is not available"\n    echo "Status: Fail"\n    echo "Current Value: jffs2 kernel module is loaded."\n    echo "Expected Value: jffs2 kernel module should not be loaded."\n    echo "Recommendation: Ensure that the jffs2 kernel module is disabled."\n    echo "Remediation:"\n    echo "  # Add the following line to /etc/modprobe.d/$module.conf:"\n    echo "  blacklist $module"\n    echo "  # Prevent loading immediately by running:"\n    echo "  sudo rmmod $module"\n    echo "  # Update the initramfs with:"\n    echo "  sudo update-initramfs -u"\nelse\n    echo "Check: Ensure jffs2 kernel module is not available"\n    echo "Status: Pass"\n    echo "Current Value: jffs2 kernel module is not loaded."\n    echo "Expected Value: jffs2 kernel module should not be loaded."\n    echo "Recommendation: No action needed."\nfi', '# Check if Print Server services are running\ncheck_print_server_status() { \n if systemctl is-enabled cups >/dev/null 2>&1; then \n echo "Check: Ensure Print Server services are not in use" \n echo "Status: Fail" \n echo "Current Value: Print server service is enabled." \n echo "Expected Value: Print server service should be disabled or masked." \n echo "Recommendation: Disable the Print server service to harden the system." \n echo "Remediation:" \n echo "# sudo systemctl disable cups" \n echo "# sudo systemctl stop cups" \n echo "# sudo systemctl mask cups" \n else \n echo "Check: Ensure Print Server services are not in use" \n echo "Status: Pass" \n echo "Current Value: Print server service is not enabled." \n echo "Expected Value: Print server service should be disabled or masked." \n echo "Recommendation: No remediation required." \n fi \n}\n\n# Execute the check\ncheck_print_server_status', '# Check if rpcbind service is running\ncheck_rpcbind_status() { \n if systemctl is-enabled rpcbind >/dev/null 2>&1; then \n echo "Check: Ensure rpcbind services are not in use" \n echo "Status: Fail" \n echo "Current Value: rpcbind service is enabled." \n echo "Expected Value: rpcbind service should be disabled or masked." \n echo "Recommendation: Disable the rpcbind service to harden the system." \n echo "Remediation:" \n echo "# sudo systemctl disable rpcbind" \n echo "# sudo systemctl stop rpcbind" \n echo "# sudo systemctl mask rpcbind" \n else \n echo "Check: Ensure rpcbind services are not in use" \n echo "Status: Pass" \n echo "Current Value: rpcbind service is not enabled." \n echo "Expected Value: rpcbind service should be disabled or masked." \n echo "Recommendation: No remediation required." \n fi \n}\n\n# Execute the check\ncheck_rpcbind_status', '#!/bin/bash\nmodule="tipc"\nif lsmod | grep -wq "$module"; then\n    echo "Check: Ensure tipc kernel module is not available"\n    echo "Status: Fail"\n    echo "Current Value: tipc kernel module is loaded."\n    echo "Expected Value: tipc kernel module should not be loaded."\n    echo "Recommendation: Unload and disable the tipc kernel module."\n    echo "Remediation:"\n    echo "# sudo modprobe -r tipc"\n    echo "# sudo echo \'blacklist tipc\' >> /etc/modprobe.d/blacklist.conf"\nelse\n    echo "Check: Ensure tipc kernel module is not available"\n    echo "Status: Pass"\n    echo "Current Value: tipc kernel module is not loaded."\n    echo "Expected Value: tipc kernel module should not be loaded."\n    echo "Recommendation: No remediation required."\nfi', '# Check if rsync service is running\ncheck_rsync_status() { \n if systemctl is-enabled rsyncd >/dev/null 2>&1; then \n echo "Check: Ensure rsync services are not in use" \n echo "Status: Fail" \n echo "Current Value: rsync service is enabled." \n echo "Expected Value: rsync service should be disabled or masked." \n echo "Recommendation: Disable the rsync service to harden the system." \n echo "Remediation:" \n echo "# sudo systemctl disable rsyncd" \n echo "# sudo systemctl stop rsyncd" \n echo "# sudo systemctl mask rsyncd" \n else \n echo "Check: Ensure rsync services are not in use" \n echo "Status: Pass" \n echo "Current Value: rsync service is not enabled." \n echo "Expected Value: rsync service should be disabled or masked." \n echo "Recommendation: No remediation required." \n fi \n}\n\n# Execute the check\ncheck_rsync_status', '# Check if Samba File Server services are running\ncheck_samba_status() { \n if systemctl is-enabled smbd >/dev/null 2>&1 || systemctl is-enabled nmbd >/dev/null 2>&1; then \n echo "Check: Ensure Samba File Server services are not in use" \n echo "Status: Fail" \n echo "Current Value: Samba File Server service is enabled." \n echo "Expected Value: Samba File Server service should be disabled or masked." \n echo "Recommendation: Disable the Samba File Server service to harden the system." \n echo "Remediation:" \n echo "# sudo systemctl disable smbd" \n echo "# sudo systemctl stop smbd" \n echo "# sudo systemctl mask smbd" \n echo "# sudo systemctl disable nmbd" \n echo "# sudo systemctl stop nmbd" \n echo "# sudo systemctl mask nmbd" \n else \n echo "Check: Ensure Samba File Server services are not in use" \n echo "Status: Pass" \n echo "Current Value: Samba File Server service is not enabled." \n echo "Expected Value: Samba File Server service should be disabled or masked." \n echo "Recommendation: No remediation required." \n fi \n}\n\n# Execute the check\ncheck_samba_status', '# Check if SNMP service is running\ncheck_snmp_status() { \n if systemctl is-enabled snmpd >/dev/null 2>&1; then \n echo "Check: Ensure SNMP services are not in use" \n echo "Status: Fail" \n echo "Current Value: SNMP service is enabled." \n echo "Expected Value: SNMP service should be disabled or masked." \n echo "Recommendation: Disable the SNMP service to harden the system." \n echo "Remediation:" \n echo "# sudo systemctl disable snmpd" \n echo "# sudo systemctl stop snmpd" \n echo "# sudo systemctl mask snmpd" \n else \n echo "Check: Ensure SNMP services are not in use" \n echo "Status: Pass" \n echo "Current Value: SNMP service is not enabled." \n echo "Expected Value: SNMP service should be disabled or masked." \n echo "Recommendation: No remediation required." \n fi \n}\n\n# Execute the check\ncheck_snmp_status', '#!/bin/bash\nmodule="rds"\nif lsmod | grep -wq "$module"; then\n    echo "Check: Ensure rds kernel module is not available"\n    echo "Status: Fail"\n    echo "Current Value: rds kernel module is loaded."\n    echo "Expected Value: rds kernel module should not be loaded."\n    echo "Recommendation: Unload and disable the rds kernel module."\n    echo "Remediation:"\n    echo "# sudo modprobe -r rds"\n    echo "# sudo echo \'blacklist rds\' >> /etc/modprobe.d/blacklist.conf"\nelse\n    echo "Check: Ensure rds kernel module is not available"\n    echo "Status: Pass"\n    echo "Current Value: rds kernel module is not loaded."\n    echo "Expected Value: rds kernel module should not be loaded."\n    echo "Recommendation: No remediation required."\nfi', '#!/bin/bash\nmodule="squashfs"\nif lsmod | grep -wq "$module"; then\n    echo "Check: Ensure $module kernel module is not available"\n    echo "Status: Fail"\n    echo "Current Value: $module kernel module is loaded."\n    echo "Expected Value: $module kernel module should not be loaded."\n    echo "Recommendation: Ensure that the $module kernel module is disabled."\n    echo "Remediation:"\n    echo "  # Add the following line to /etc/modprobe.d/$module.conf:"\n    echo "  blacklist $module"\n    echo "  # Prevent loading immediately by running:"\n    echo "  sudo rmmod $module"\n    echo "  # Update the initramfs with:"\n    echo "  sudo update-initramfs -u"\nelse\n    echo "Check: Ensure $module kernel module is not available"\n    echo "Status: Pass"\n    echo "Current Value: $module kernel module is not loaded."\n    echo "Expected Value: $module kernel module should not be loaded."\n    echo "Recommendation: No action needed."\nfi\n', '#!/bin/bash\nmodule="sctp"\nif lsmod | grep -wq "$module"; then\n    echo "Check: Ensure sctp kernel module is not available"\n    echo "Status: Fail"\n    echo "Current Value: sctp kernel module is loaded."\n    echo "Expected Value: sctp kernel module should not be loaded."\n    echo "Recommendation: Unload and disable the sctp kernel module."\n    echo "Remediation:"\n    echo "# sudo modprobe -r sctp"\n    echo "# sudo echo \'blacklist sctp\' >> /etc/modprobe.d/blacklist.conf"\nelse\n    echo "Check: Ensure sctp kernel module is not available"\n    echo "Status: Pass"\n    echo "Current Value: sctp kernel module is not loaded."\n    echo "Expected Value: sctp kernel module should not be loaded."\n    echo "Recommendation: No remediation required."\nfi', '# Check if TFTP server services are running\ncheck_tftp_status() { \n if systemctl is-enabled tftpd >/dev/null 2>&1 || systemctl is-enabled tftp >/dev/null 2>&1; then \n echo "Check: Ensure TFTP server services are not in use" \n echo "Status: Fail" \n echo "Current Value: TFTP service is enabled." \n echo "Expected Value: TFTP service should be disabled or masked." \n echo "Recommendation: Disable the TFTP service to harden the system." \n echo "Remediation:" \n echo "# sudo systemctl disable tftpd" \n echo "# sudo systemctl stop tftpd" \n echo "# sudo systemctl mask tftpd" \n echo "# sudo systemctl disable tftp" \n echo "# sudo systemctl stop tftp" \n echo "# sudo systemctl mask tftp" \n else \n echo "Check: Ensure TFTP server services are not in use" \n echo "Status: Pass" \n echo "Current Value: TFTP service is not enabled." \n echo "Expected Value: TFTP service should be disabled or masked." \n echo "Recommendation: No remediation required." \n fi \n}\n\n# Execute the check\ncheck_tftp_status', '#!/bin/bash\n\nmodule="udf"\n\nif lsmod | grep -wq "$module"; then\n    echo "Check: Ensure $module kernel module is not available"\n    echo "Status: Fail"\n    echo "Current Value: $module kernel module is loaded."\n    echo "Expected Value: $module kernel module should not be loaded."\n    echo "Recommendation: Ensure that the $module kernel module is disabled."\n    echo "Remediation:"\n    echo "  # Add the following line to /etc/modprobe.d/$module.conf:"\n    echo "  blacklist $module"\n    echo "  # Prevent loading immediately by running:"\n    echo "  sudo rmmod $module"\n    echo "  # Update the initramfs with:"\n    echo "  sudo update-initramfs -u"\nelse\n    echo "Check: Ensure $module kernel module is not available"\n    echo "Status: Pass"\n    echo "Current Value: $module kernel module is not loaded."\n    echo "Expected Value: $module kernel module should not be loaded."\n    echo "Recommendation: No action needed."\nfi\n', '# Check if Web Proxy Server services are running\ncheck_proxy_status() { \n if systemctl is-enabled squid >/dev/null 2>&1 || systemctl is-enabled polipo >/dev/null 2>&1; then \n echo "Check: Ensure Web Proxy Server services are not in use" \n echo "Status: Fail" \n echo "Current Value: Web Proxy service is enabled." \n echo "Expected Value: Web Proxy service should be disabled or masked." \n echo "Recommendation: Disable the Web Proxy service to harden the system." \n echo "Remediation:" \n echo "# sudo systemctl disable squid" \n echo "# sudo systemctl stop squid" \n echo "# sudo systemctl mask squid" \n echo "# sudo systemctl disable polipo" \n echo "# sudo systemctl stop polipo" \n echo "# sudo systemctl mask polipo" \n else \n echo "Check: Ensure Web Proxy Server services are not in use" \n echo "Status: Pass" \n echo "Current Value: Web Proxy service is not enabled." \n echo "Expected Value: Web Proxy service should be disabled or masked." \n echo "Recommendation: No remediation required." \n fi \n}\n\n# Execute the check\ncheck_proxy_status', '# Check if Web Server services are running\ncheck_web_server_status() { \n if systemctl is-enabled apache2 >/dev/null 2>&1 || systemctl is-enabled nginx >/dev/null 2>&1 || systemctl is-enabled httpd >/dev/null 2>&1; then \n echo "Check: Ensure Web Server services are not in use" \n echo "Status: Fail" \n echo "Current Value: Web Server service is enabled." \n echo "Expected Value: Web Server service should be disabled or masked." \n echo "Recommendation: Disable the Web Server service to harden the system." \n echo "Remediation:" \n echo "# sudo systemctl disable apache2" \n echo "# sudo systemctl stop apache2" \n echo "# sudo systemctl mask apache2" \n echo "# sudo systemctl disable nginx" \n echo "# sudo systemctl stop nginx" \n echo "# sudo systemctl mask nginx" \n echo "# sudo systemctl disable httpd" \n echo "# sudo systemctl stop httpd" \n echo "# sudo systemctl mask httpd" \n else \n echo "Check: Ensure Web Server services are not in use" \n echo "Status: Pass" \n echo "Current Value: Web Server service is not enabled." \n echo "Expected Value: Web Server service should be disabled or masked." \n echo "Recommendation: No remediation required." \n fi \n}\n\n# Execute the check\ncheck_web_server_status', '#!/bin/bash\nmodule="ip_forwarding"\nif sysctl net.ipv4.ip_forward | grep -q "net.ipv4.ip_forward = 1"; then\n    echo "Check: Ensure IP forwarding is disabled"\n    echo "Status: Fail"\n    echo "Current Value: IP forwarding is enabled."\n    echo "Expected Value: IP forwarding should be disabled."\n    echo "Recommendation: Disable IP forwarding."\n    echo "Remediation:"\n    echo "# sudo sysctl -w net.ipv4.ip_forward=0"\n    echo "# sudo echo \'net.ipv4.ip_forward = 0\' >> /etc/sysctl.conf"\n    echo "# sudo sysctl -p"\nelse\n    echo "Check: Ensure IP forwarding is disabled"\n    echo "Status: Pass"\n    echo "Current Value: IP forwarding is disabled."\n    echo "Expected Value: IP forwarding should be disabled."\n    echo "Recommendation: No remediation required."\nfi', '# Check if Xinetd service is running\ncheck_xinetd_status() { \n if systemctl is-enabled xinetd >/dev/null 2>&1; then \n echo "Check: Ensure Xinetd services are not in use" \n echo "Status: Fail" \n echo "Current Value: Xinetd service is enabled." \n echo "Expected Value: Xinetd service should be disabled or masked." \n echo "Recommendation: Disable the Xinetd service to harden the system." \n echo "Remediation:" \n echo "# sudo systemctl disable xinetd" \n echo "# sudo systemctl stop xinetd" \n echo "# sudo systemctl mask xinetd" \n else \n echo "Check: Ensure Xinetd services are not in use" \n echo "Status: Pass" \n echo "Current Value: Xinetd service is not enabled." \n echo "Expected Value: Xinetd service should be disabled or masked." \n echo "Recommendation: No remediation required." \n fi \n}\n\n# Execute the check\ncheck_xinetd_status', '#!/bin/bash\nmodule="packet_redirect_sending"\nif sysctl net.ipv4.conf.all.send_redirects | grep -q "net.ipv4.conf.all.send_redirects = 1"; then\n    echo "Check: Ensure packet redirect sending is disabled"\n    echo "Status: Fail"\n    echo "Current Value: Packet redirect sending is enabled."\n    echo "Expected Value: Packet redirect sending should be disabled."\n    echo "Recommendation: Disable packet redirect sending."\n    echo "Remediation:"\n    echo "# sudo sysctl -w net.ipv4.conf.all.send_redirects=0"\n    echo "# sudo echo \'net.ipv4.conf.all.send_redirects = 0\' >> /etc/sysctl.conf"\n    echo "# sudo sysctl -p"\nelse\n    echo "Check: Ensure packet redirect sending is disabled"\n    echo "Status: Pass"\n    echo "Current Value: Packet redirect sending is disabled."\n    echo "Expected Value: Packet redirect sending should be disabled."\n    echo "Recommendation: No remediation required."\nfi', '# Check if X Window Server services are running\ncheck_x_window_status() { \n if systemctl is-enabled xorg.service >/dev/null 2>&1 || systemctl is-enabled gdm >/dev/null 2>&1 || systemctl is-enabled lightdm >/dev/null 2>&1; then \n echo "Check: Ensure X Window Server services are not in use" \n echo "Status: Fail" \n echo "Current Value: X Window Server service is enabled." \n echo "Expected Value: X Window Server service should be disabled or masked." \n echo "Recommendation: Disable the X Window Server service to harden the system." \n echo "Remediation:" \n echo "# sudo systemctl disable xorg.service" \n echo "# sudo systemctl stop xorg.service" \n echo "# sudo systemctl mask xorg.service" \n echo "# sudo systemctl disable gdm" \n echo "# sudo systemctl stop gdm" \n echo "# sudo systemctl mask gdm" \n echo "# sudo systemctl disable lightdm" \n echo "# sudo systemctl stop lightdm" \n echo "# sudo systemctl mask lightdm" \n else \n echo "Check: Ensure X Window Server services are not in use" \n echo "Status: Pass" \n echo "Current Value: X Window Server service is not enabled." \n echo "Expected Value: X Window Server service should be disabled or masked." \n echo "Recommendation: No remediation required." \n fi \n}\n\n# Execute the check\ncheck_x_window_status', '#!/bin/bash\ncheck_bogus_icmp_responses() {\nicmp_ignore_status=$(sysctl net.ipv4.icmp_ignore_bogus_error_responses)\n\nif [[ "$icmp_ignore_status" == "net.ipv4.icmp_ignore_bogus_error_responses = 1" ]]; then\n    echo "Check: Ensure bogus ICMP responses are ignored"\n    echo "Status: Pass"\n    echo "Current Value: Bogus ICMP responses are ignored."\n    echo "Expected Value: Bogus ICMP responses should be ignored."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Check: Ensure bogus ICMP responses are ignored"\n    echo "Status: Fail"\n    echo "Current Value: Bogus ICMP responses are not ignored."\n    echo "Expected Value: Bogus ICMP responses should be ignored."\n    echo "Recommendation: Enable ignoring of bogus ICMP responses."\n    echo "Remediation:"\n    echo "# sudo sysctl -w net.ipv4.icmp_ignore_bogus_error_responses=1"\n    echo "# sudo echo \'net.ipv4.icmp_ignore_bogus_error_responses = 1\' >> /etc/sysctl.conf"\n    echo "# sudo sysctl -p"\nfi\n}\n\ncheck_bogus_icmp_responses', '# Check if MTA is configured for local-only mode\ncheck_mta_status() { \n if systemctl is-enabled postfix >/dev/null 2>&1 || systemctl is-enabled sendmail >/dev/null 2>&1; then \n echo "Check: Ensure Mail Transfer Agent is configured for local-only mode" \n echo "Status: Fail" \n echo "Current Value: MTA is not configured for local-only mode." \n echo "Expected Value: MTA should be configured for local-only mode." \n echo "Recommendation: Configure the MTA for local-only mode to restrict external mail." \n echo "Remediation:" \n echo "# sudo postconf -e \'inet_interfaces = loopback-only\'" \n echo "# sudo systemctl restart postfix" \n else \n echo "Check: Ensure Mail Transfer Agent is configured for local-only mode" \n echo "Status: Pass" \n echo "Current Value: MTA is not enabled." \n echo "Expected Value: MTA should not be enabled or configured for external access." \n echo "Recommendation: No remediation required." \n fi \n}\n\n# Execute the check\ncheck_mta_status', '# Check if unauthorized network services are running\n\ncheck_network_services() {\n    unauthorized_services=("telnet" "ftp" "rsh" "rexec" "finger")\n    all_passed=true  # Variable to track if all tests pass\n\n    # Check if netstat is available, if not use ss\n    if ! command -v netstat &>/dev/null; then\n        netstat="ss -tuln"\n    else\n        netstat="netstat -tuln"\n    fi\n\n    for service in "${unauthorized_services[@]}"; do\n        if $netstat | grep ":$service" >/dev/null; then\n            echo "Check: Ensure only approved services are listening on a network interface"\n            echo "Status: Fail"\n            echo "Current Value: Unauthorized service $service is listening on a network interface."\n            echo "Expected Value: Only approved services should be listening on network interfaces."\n            echo "Recommendation: Disable unauthorized services."\n            echo "Remediation:"\n            echo "# sudo systemctl disable $service"\n            echo "# sudo systemctl stop $service"\n            all_passed=false  # Mark as failed if any unauthorized service is found\n        fi\n    done\n\n    # If no unauthorized services were found, print the else statement\n    if [ "$all_passed" = true ]; then\n        echo "Check: Ensure only approved services are listening on a network interface"\n        echo "Status: Pass"\n        echo "Current Value: No unauthorized services are listening on a network interface."\n        echo "Expected Value: Only approved services should be listening on network interfaces."\n        echo "Recommendation: No action needed. All services are approved."\n    fi\n}\n\n# Execute the check\ncheck_network_services', '#!/bin/bash\ncheck_broadcast_icmp_requests() {\nbroadcast_status=$(sysctl net.ipv4.icmp_echo_ignore_broadcasts)\n\nif [[ "$broadcast_status" == "net.ipv4.icmp_echo_ignore_broadcasts = 1" ]]; then\n    echo "Check: Ensure broadcast ICMP requests are ignored"\n    echo "Status: Pass"\n    echo "Current Value: Broadcast ICMP requests are ignored."\n    echo "Expected Value: Broadcast ICMP requests should be ignored."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Check: Ensure broadcast ICMP requests are ignored"\n    echo "Status: Fail"\n    echo "Current Value: Broadcast ICMP requests are not ignored."\n    echo "Expected Value: Broadcast ICMP requests should be ignored."\n    echo "Recommendation: Enable ignoring of broadcast ICMP requests."\n    echo "Remediation:"\n    echo "# sudo sysctl -w net.ipv4.icmp_echo_ignore_broadcasts=1"\n    echo "# sudo echo \'net.ipv4.icmp_echo_ignore_broadcasts = 1\' >> /etc/sysctl.conf"\n    echo "# sudo sysctl -p"\nfi\n}\n\ncheck_broadcast_icmp_requests', '# Check if NIS client is installed\ncheck_nis_client() { \n if rpm -q ypbind >/dev/null 2>&1 || dpkg -l | grep -q ypbind; then \n echo "Check: Ensure NIS Client is not installed" \n echo "Status: Fail" \n echo "Current Value: NIS Client is installed." \n echo "Expected Value: NIS Client should not be installed." \n echo "Recommendation: Remove the NIS Client package to harden the system." \n echo "Remediation:" \n echo "# sudo yum remove ypbind"  # For RedHat-based systems \n echo "# sudo apt-get remove ypbind"  # For Debian-based systems \n else \n echo "Check: Ensure NIS Client is not installed" \n echo "Status: Pass" \n echo "Current Value: NIS Client is not installed." \n echo "Expected Value: NIS Client should not be installed." \n echo "Recommendation: No remediation required." \n fi \n}\n\n# Execute the check\ncheck_nis_client', '# Check if RSH client is installed\ncheck_rsh_client() { \n if rpm -q rsh >/dev/null 2>&1 || dpkg -l | grep -q rsh; then \n echo "Check: Ensure RSH Client is not installed" \n echo "Status: Fail" \n echo "Current Value: RSH Client is installed." \n echo "Expected Value: RSH Client should not be installed." \n echo "Recommendation: Remove the RSH Client package to harden the system." \n echo "Remediation:" \n echo "# sudo yum remove rsh"  # For RedHat-based systems \n echo "# sudo apt-get remove rsh"  # For Debian-based systems \n else \n echo "Check: Ensure RSH Client is not installed" \n echo "Status: Pass" \n echo "Current Value: RSH Client is not installed." \n echo "Expected Value: RSH Client should not be installed." \n echo "Recommendation: No remediation required." \n fi \n}\n\n# Execute the check\ncheck_rsh_client', '#!/bin/bash\ncheck_icmp_redirects() {\nicmp_redirect_status=$(sysctl net.ipv4.conf.all.accept_redirects)\n\nif [[ "$icmp_redirect_status" == "net.ipv4.conf.all.accept_redirects = 0" ]]; then\n    echo "Check: Ensure ICMP redirects are not accepted"\n    echo "Status: Pass"\n    echo "Current Value: ICMP redirects are not accepted."\n    echo "Expected Value: ICMP redirects should not be accepted."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Check: Ensure ICMP redirects are not accepted"\n    echo "Status: Fail"\n    echo "Current Value: ICMP redirects are accepted."\n    echo "Expected Value: ICMP redirects should not be accepted."\n    echo "Recommendation: Disable acceptance of ICMP redirects."\n    echo "Remediation:"\n    echo "# sudo sysctl -w net.ipv4.conf.all.accept_redirects=0"\n    echo "# sudo echo \'net.ipv4.conf.all.accept_redirects = 0\' >> /etc/sysctl.conf"\n    echo "# sudo sysctl -p"\nfi\n}\n\ncheck_icmp_redirects', '# Check if Talk client is installed\ncheck_talk_client() { \n if rpm -q talk >/dev/null 2>&1 || dpkg -l | grep -q talk; then \n echo "Check: Ensure Talk Client is not installed" \n echo "Status: Fail" \n echo "Current Value: Talk Client is installed." \n echo "Expected Value: Talk Client should not be installed." \n echo "Recommendation: Remove the Talk Client package to harden the system." \n echo "Remediation:" \n echo "# sudo yum remove talk"  # For RedHat-based systems \n echo "# sudo apt-get remove talk"  # For Debian-based systems \n else \n echo "Check: Ensure Talk Client is not installed" \n echo "Status: Pass" \n echo "Current Value: Talk Client is not installed." \n echo "Expected Value: Talk Client should not be installed." \n echo "Recommendation: No remediation required." \n fi \n}\n\n# Execute the check\ncheck_talk_client', '#!/bin/bash\ncheck_secure_icmp_redirects() {\n    secure_icmp_redirect_status=$(sysctl net.ipv4.conf.all.secure_redirects)\n\n    if [[ "$secure_icmp_redirect_status" == "net.ipv4.conf.all.secure_redirects = 0" ]]; then\n        echo "Check: Ensure secure ICMP redirects are not accepted"\n        echo "Status: Pass"\n        echo "Current Value: Secure ICMP redirects are not accepted."\n        echo "Expected Value: Secure ICMP redirects should not be accepted."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure secure ICMP redirects are not accepted"\n        echo "Status: Fail"\n        echo "Current Value: Secure ICMP redirects are accepted."\n        echo "Expected Value: Secure ICMP redirects should not be accepted."\n        echo "Recommendation: Disable acceptance of secure ICMP redirects."\n        echo "Remediation:"\n        echo "# sudo sysctl -w net.ipv4.conf.all.secure_redirects=0"\n        echo "# sudo echo \'net.ipv4.conf.all.secure_redirects = 0\' >> /etc/sysctl.conf"\n        echo "# sudo sysctl -p"\n    fi\n}\n\ncheck_secure_icmp_redirects', '# Check if Telnet client is installed\ncheck_telnet_client() { \n if rpm -q telnet >/dev/null 2>&1 || dpkg -l | grep -q telnet; then \n echo "Check: Ensure Telnet Client is not installed" \n echo "Status: Fail" \n echo "Current Value: Telnet Client is installed." \n echo "Expected Value: Telnet Client should not be installed." \n echo "Recommendation: Remove the Telnet Client package to harden the system." \n echo "Remediation:" \n echo "# sudo yum remove telnet"  # For RedHat-based systems \n echo "# sudo apt-get remove telnet"  # For Debian-based systems \n else \n echo "Check: Ensure Telnet Client is not installed" \n echo "Status: Pass" \n echo "Current Value: Telnet Client is not installed." \n echo "Expected Value: Telnet Client should not be installed." \n echo "Recommendation: No remediation required." \n fi \n}\n\n# Execute the check\ncheck_telnet_client', '# Check if reverse path filtering is enabled\n\ncheck_reverse_path_filtering() {\n    rp_filter_status=$(sysctl net.ipv4.conf.all.rp_filter)\n\n    if [[ "$rp_filter_status" == "net.ipv4.conf.all.rp_filter = 1" ]]; then\n        echo "Check: Ensure reverse path filtering is enabled"\n        echo "Status: Pass"\n        echo "Current Value: Reverse path filtering is enabled."\n        echo "Expected Value: Reverse path filtering should be enabled."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure reverse path filtering is enabled"\n        echo "Status: Fail"\n        echo "Current Value: Reverse path filtering is not enabled."\n        echo "Expected Value: Reverse path filtering should be enabled."\n        echo "Recommendation: Enable reverse path filtering."\n        echo "Remediation:"\n        echo "# sudo sysctl -w net.ipv4.conf.all.rp_filter=1"\n        echo "# sudo echo \'net.ipv4.conf.all.rp_filter = 1\' >> /etc/sysctl.conf"\n        echo "# sudo sysctl -p"\n    fi\n}\n\n# Execute the check\ncheck_reverse_path_filtering', '# Check if LDAP client is installed\ncheck_ldap_client() { \n if rpm -q openldap-clients >/dev/null 2>&1 || dpkg -l | grep -q ldap-utils; then \n echo "Check: Ensure LDAP Client is not installed" \n echo "Status: Fail" \n echo "Current Value: LDAP Client is installed." \n echo "Expected Value: LDAP Client should not be installed." \n echo "Recommendation: Remove the LDAP Client package to harden the system." \n echo "Remediation:" \n echo "# sudo yum remove openldap-clients"  # For RedHat-based systems \n echo "# sudo apt-get remove ldap-utils"  # For Debian-based systems \n else \n echo "Check: Ensure LDAP Client is not installed" \n echo "Status: Pass" \n echo "Current Value: LDAP Client is not installed." \n echo "Expected Value: LDAP Client should not be installed." \n echo "Recommendation: No remediation required." \n fi \n}\n\n# Execute the check\ncheck_ldap_client', '# Check if source routed packets are not accepted\n\ncheck_source_routed_packets() {\n    source_routed_status=$(sysctl net.ipv4.conf.all.accept_source_route)\n\n    if [[ "$source_routed_status" == "net.ipv4.conf.all.accept_source_route = 0" ]]; then\n        echo "Check: Ensure source routed packets are not accepted"\n        echo "Status: Pass"\n        echo "Current Value: Source routed packets are not accepted."\n        echo "Expected Value: Source routed packets should not be accepted."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure source routed packets are not accepted"\n        echo "Status: Fail"\n        echo "Current Value: Source routed packets are accepted."\n        echo "Expected Value: Source routed packets should not be accepted."\n        echo "Recommendation: Disable acceptance of source routed packets."\n        echo "Remediation:"\n        echo "# sudo sysctl -w net.ipv4.conf.all.accept_source_route=0"\n        echo "# sudo echo \'net.ipv4.conf.all.accept_source_route = 0\' >> /etc/sysctl.conf"\n        echo "# sudo sysctl -p"\n    fi\n}\n\n# Execute the check\ncheck_source_routed_packets', '# Check if FTP client is installed\ncheck_ftp_client() { \n if rpm -q ftp >/dev/null 2>&1 || dpkg -l | grep -q ftp; then \n echo "Check: Ensure FTP Client is not installed" \n echo "Status: Fail" \n echo "Current Value: FTP Client is installed." \n echo "Expected Value: FTP Client should not be installed." \n echo "Recommendation: Remove the FTP Client package to harden the system." \n echo "Remediation:" \n echo "# sudo yum remove ftp"  # For RedHat-based systems \n echo "# sudo apt-get remove ftp"  # For Debian-based systems \n else \n echo "Check: Ensure FTP Client is not installed" \n echo "Status: Pass" \n echo "Current Value: FTP Client is not installed." \n echo "Expected Value: FTP Client should not be installed." \n echo "Recommendation: No remediation required." \n fi \n}\n\n# Execute the check\ncheck_ftp_client', '# Check if suspicious packets are logged\n\ncheck_suspicious_packets_logging() {\n    suspicious_packets_status=$(sysctl net.ipv4.conf.all.log_martians)\n\n    if [[ "$suspicious_packets_status" == "net.ipv4.conf.all.log_martians = 1" ]]; then\n        echo "Check: Ensure suspicious packets are logged"\n        echo "Status: Pass"\n        echo "Current Value: Suspicious packets are logged."\n        echo "Expected Value: Suspicious packets should be logged."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure suspicious packets are logged"\n        echo "Status: Fail"\n        echo "Current Value: Suspicious packets are not logged."\n        echo "Expected Value: Suspicious packets should be logged."\n        echo "Recommendation: Enable logging of suspicious packets."\n        echo "Remediation:"\n        echo "# sudo sysctl -w net.ipv4.conf.all.log_martians=1"\n        echo "# sudo echo \'net.ipv4.conf.all.log_martians = 1\' >> /etc/sysctl.conf"\n        echo "# sudo sysctl -p"\n    fi\n}\n\n# Execute the check\ncheck_suspicious_packets_logging', '#!/bin/bash\n\nmodule=\\"jffs2\\"\n\nif lsmod | grep -wq \\"\\$module\\"; then\n    echo \\"Check: Ensure \\$module kernel module is not available\\"\n    echo \\"Status: Fail\\"\n    echo \\"Current Value: \\$module kernel module is loaded.\\"\n    echo \\"Expected Value: \\$module kernel module should not be loaded.\\"\n    echo \\"Recommendation: Ensure that the \\$module kernel module is disabled.\\"\n    echo \\"Remediation:\\"\n    echo \\"  # Add the following line to /etc/modprobe.d/\\$module.conf:\\"\n    echo \\"  blacklist \\$module\\"\n    echo \\"  # Prevent loading immediately by running:\\"\n    echo \\"  sudo rmmod \\$module\\"\n    echo \\"  # Update the initramfs with:\\"\n    echo \\"  sudo update-initramfs -u\\"\nelse\n    echo \\"Check: Ensure \\$module kernel module is not available\\"\n    echo \\"Status: Pass\\"\n    echo \\"Current Value: \\$module kernel module is not loaded.\\"\n    echo \\"Expected Value: \\$module kernel module should not be loaded.\\"\n    echo \\"Recommendation: No action needed.\\"\nfi', '#!/bin/bash\nmodule="usb-storage"\nif lsmod | grep -wq "$module"; then\n    echo "Check: Ensure $module kernel module is not available"\n    echo "Status: Fail"\n    echo "Current Value: $module kernel module is loaded."\n    echo "Expected Value: $module kernel module should not be loaded."\n    echo "Recommendation: Ensure that the $module kernel module is disabled."\n    echo "Remediation:"\n    echo "  # Add the following line to /etc/modprobe.d/$module.conf:"\n    echo "  blacklist $module"\n    echo "  # Prevent loading immediately by running:"\n    echo "  sudo rmmod $module"\n    echo "  # Update the initramfs with:"\n    echo "  sudo update-initramfs -u"\nelse\n    echo "Check: Ensure $module kernel module is not available"\n    echo "Status: Pass"\n    echo "Current Value: $module kernel module is not loaded."\n    echo "Expected Value: $module kernel module should not be loaded."\n    echo "Recommendation: No action needed."\nfi\n', '#!/bin/bash\npartition="/tmp"\nif mount | grep -qw "$partition"; then\n    echo "Check: Ensure $partition is a separate partition"\n    echo "Status: Pass"\n    echo "Current Value: $partition is mounted as a separate partition."\n    echo "Expected Value: $partition should be mounted as a separate partition."\n    echo "Recommendation: No action needed."\nelse\n    echo "Check: Ensure $partition is a separate partition"\n    echo "Status: Fail"\n    echo "Current Value: $partition is not mounted as a separate partition."\n    echo "Expected Value: $partition should be mounted as a separate partition."\n    echo "Recommendation: Configure $partition as a separate partition during the next system maintenance window."\n    echo "Remediation:"\n    echo "  1. Update the /etc/fstab file to include an entry for /tmp."\n    echo "  2. Example:"\n    echo "     tmpfs  /tmp  tmpfs  defaults,nodev,nosuid,noexec  0  0"\n    echo "  3. Mount the partition with:"\n    echo "     sudo mount -o remount /tmp"\nfi\n', '# Check if TCP SYN cookies are enabled\ncheck_tcp_syn_cookies() {\nsyn_cookies_status=$(sysctl net.ipv4.tcp_syncookies)\nif [[ "$syn_cookies_status" == "net.ipv4.tcp_syncookies = 1" ]]; then\n    echo "Check: Ensure TCP SYN cookies are enabled"\n    echo "Status: Pass"\n    echo "Current Value: TCP SYN cookies are enabled."\n    echo "Expected Value: TCP SYN cookies should be enabled."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Check: Ensure TCP SYN cookies are enabled"\n    echo "Status: Fail"\n    echo "Current Value: TCP SYN cookies are not enabled."\n    echo "Expected Value: TCP SYN cookies should be enabled."\n    echo "Recommendation: Enable TCP SYN cookies."\n    echo "Remediation:"\n    echo "# sudo sysctl -w net.ipv4.tcp_syncookies=1"\n    echo "# sudo echo \'net.ipv4.tcp_syncookies = 1\' >> /etc/sysctl.conf"\n    echo "# sudo sysctl -p"\nfi\n}\n\n# Execute the check\ncheck_tcp_syn_cookies\n', '#!/bin/bash\npartition="/tmp"\noption="nodev"\nif mount | grep -qw "$partition"; then\n    if mount | grep "$partition" | grep -qw "$option"; then\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Pass"\n        echo "Current Value: $option option is set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Recommendation: No action needed."\n    else\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Fail"\n        echo "Current Value: $option option is not set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Remediation Steps:"\n        echo "1. Open the /etc/fstab file for editing:"\n        echo "   # sudo nano /etc/fstab"\n        echo "2. Add or modify the entry for /tmp to include $option. For example:"\n        echo "   tmpfs  /tmp  tmpfs  defaults,nodev,nosuid,noexec  0  0"\n        echo "3. Remount the /tmp partition:"\n        echo "   # sudo mount -o remount /tmp"\n        echo "4. Verify the changes:"\n        echo "   # mount | grep /tmp"\n    fi\nelse\n    echo "Check: Ensure $option option is set on $partition partition"\n    echo "Status: Fail"\n    echo "Current Value: $partition is not mounted."\n    echo "Expected Value: $partition should be mounted with $option."\n    echo "Remediation Steps:"\n    echo "1. Ensure $partition is mounted by adding it to /etc/fstab as shown:"\n    echo "   tmpfs  /tmp  tmpfs  defaults,nodev,nosuid,noexec  0  0"\n    echo "2. Mount the partition with:"\n    echo "   # sudo mount -a"\n    echo "3. Verify the changes:"\n    echo "   # mount | grep /tmp"\nfi\n', '# Check if IPv6 router advertisements are not accepted\ncheck_ipv6_router_advertisements() {\n    ipv6_router_status=$(sysctl net.ipv6.conf.all.accept_ra)\n    if [[ "$ipv6_router_status" == "net.ipv6.conf.all.accept_ra = 0" ]]; then\n        echo "Check: Ensure IPv6 router advertisements are not accepted"\n        echo "Status: Pass"\n        echo "Current Value: IPv6 router advertisements are not accepted."\n        echo "Expected Value: IPv6 router advertisements should not be accepted."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure IPv6 router advertisements are not accepted"\n        echo "Status: Fail"\n        echo "Current Value: IPv6 router advertisements are accepted."\n        echo "Expected Value: IPv6 router advertisements should not be accepted."\n        echo "Recommendation: Disable acceptance of IPv6 router advertisements."\n        echo "Remediation:"\n        echo "# sudo sysctl -w net.ipv6.conf.all.accept_ra=0"\n        echo "# sudo echo \'net.ipv6.conf.all.accept_ra = 0\' >> /etc/sysctl.conf"\n        echo "# sudo sysctl -p"\n    fi\n}\n\n# Execute the check\ncheck_ipv6_router_advertisements\n', '# Check if UFW is installed\ncheck_ufw_installed() {\n    if command -v ufw > /dev/null; then\n        echo "Check: Ensure UFW is installed"\n        echo "Status: Pass"\n        echo "Current Value: UFW is installed."\n        echo "Expected Value: UFW should be installed."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure UFW is installed"\n        echo "Status: Fail"\n        echo "Current Value: UFW is not installed."\n        echo "Expected Value: UFW should be installed."\n        echo "Recommendation: Install UFW."\n        echo "Remediation:"\n        echo "# sudo apt-get install ufw"\n    fi\n}\n\n# Execute the check\ncheck_ufw_installed\n', '#!/bin/bash\npartition="/tmp"\noption="nosuid"\nif mount | grep -qw "$partition"; then\n    if mount | grep "$partition" | grep -qw "$option"; then\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Pass"\n        echo "Current Value: $option option is set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Recommendation: No action needed."\n    else\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Fail"\n        echo "Current Value: $option option is not set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Remediation Steps:"\n        echo "1. Open the /etc/fstab file for editing:"\n        echo "   # sudo nano /etc/fstab"\n        echo "2. Add or modify the entry for /tmp to include $option. For example:"\n        echo "   tmpfs  /tmp  tmpfs  defaults,nodev,nosuid,noexec  0  0"\n        echo "3. Remount the /tmp partition:"\n        echo "   # sudo mount -o remount /tmp"\n        echo "4. Verify the changes:"\n        echo "   # mount | grep /tmp"\n    fi\nelse\n    echo "Check: Ensure $option option is set on $partition partition"\n    echo "Status: Fail"\n    echo "Current Value: $partition is not mounted."\n    echo "Expected Value: $partition should be mounted with $option."\n    echo "Remediation Steps:"\n    echo "1. Ensure $partition is mounted by adding it to /etc/fstab as shown:"\n    echo "   tmpfs  /tmp  tmpfs  defaults,nodev,nosuid,noexec  0  0"\n    echo "2. Mount the partition with:"\n    echo "   # sudo mount -a"\n    echo "3. Verify the changes:"\n    echo "   # mount | grep /tmp"\nfi\n', '# Check if iptables-persistent is installed\ncheck_iptables_persistent_installed() {\n    if dpkg -l | grep -q iptables-persistent; then\n        echo "Check: Ensure iptables-persistent is not installed with UFW"\n        echo "Status: Fail"\n        echo "Current Value: iptables-persistent is installed."\n        echo "Expected Value: iptables-persistent should not be installed with UFW."\n        echo "Recommendation: Remove iptables-persistent."\n        echo "Remediation:"\n        echo "# sudo apt-get remove --purge iptables-persistent"\n    else\n        echo "Check: Ensure iptables-persistent is not installed with UFW"\n        echo "Status: Pass"\n        echo "Current Value: iptables-persistent is not installed."\n        echo "Expected Value: iptables-persistent should not be installed."\n        echo "Recommendation: No remediation required."\n    fi\n}\n\n# Execute the check\ncheck_iptables_persistent_installed\n', '#!/bin/bash\npartition="/tmp"\noption="noexec"\nif mount | grep -qw "$partition"; then\n    if mount | grep "$partition" | grep -qw "$option"; then\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Pass"\n        echo "Current Value: $option option is set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Recommendation: No action needed."\n    else\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Fail"\n        echo "Current Value: $option option is not set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Remediation Steps:"\n        echo "1. Open the /etc/fstab file for editing:"\n        echo "   # sudo nano /etc/fstab"\n        echo "2. Add or modify the entry for /tmp to include $option. For example:"\n        echo "   tmpfs  /tmp  tmpfs  defaults,nodev,nosuid,noexec  0  0"\n        echo "3. Remount the /tmp partition:"\n        echo "   # sudo mount -o remount /tmp"\n        echo "4. Verify the changes:"\n        echo "   # mount | grep /tmp"\n    fi\nelse\n    echo "Check: Ensure $option option is set on $partition partition"\n    echo "Status: Fail"\n    echo "Current Value: $partition is not mounted."\n    echo "Expected Value: $partition should be mounted with $option."\n    echo "Remediation Steps:"\n    echo "1. Ensure $partition is mounted by adding it to /etc/fstab as shown:"\n    echo "   tmpfs  /tmp  tmpfs  defaults,nodev,nosuid,noexec  0  0"\n    echo "2. Mount the partition with:"\n    echo "   # sudo mount -a"\n    echo "3. Verify the changes:"\n    echo "   # mount | grep /tmp"\nfi\n', '# Check if UFW service is enabled\ncheck_ufw_service_enabled() {\n    if systemctl is-enabled ufw > /dev/null; then\n        echo "Check: Ensure UFW service is enabled"\n        echo "Status: Pass"\n        echo "Current Value: UFW service is enabled."\n        echo "Expected Value: UFW service should be enabled."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure UFW service is enabled"\n        echo "Status: Fail"\n        echo "Current Value: UFW service is not enabled."\n        echo "Expected Value: UFW service should be enabled."\n        echo "Recommendation: Enable UFW service."\n        echo "Remediation:"\n        echo "# sudo systemctl enable ufw"\n        echo "# sudo systemctl start ufw"\n    fi\n}\n\n# Execute the check\ncheck_ufw_service_enabled\n', '#!/bin/bash\npartition="/dev/shm"\nif mount | grep -qw "$partition"; then\n    echo "Check: Ensure $partition is a separate partition"\n    echo "Status: Pass"\n    echo "Current Value: $partition is mounted as a separate partition."\n    echo "Expected Value: $partition should be mounted as a separate partition."\n    echo "Recommendation: No action needed."\nelse\n    echo "Check: Ensure $partition is a separate partition"\n    echo "Status: Fail"\n    echo "Current Value: $partition is not mounted as a separate partition."\n    echo "Expected Value: $partition should be mounted as a separate partition."\n    echo "Remediation Steps:"\n    echo "1. Open the /etc/fstab file for editing:"\n    echo "   # sudo nano /etc/fstab"\n    echo "2. Add the following entry for /dev/shm:"\n    echo "   tmpfs  /dev/shm  tmpfs  defaults,nodev,nosuid,noexec  0  0"\n    echo "3. Mount the partition with:"\n    echo "   # sudo mount -a"\n    echo "4. Verify the changes:"\n    echo "   # mount | grep /dev/shm"\nfi\n', '#!/bin/bash\npartition="/dev/shm"\noption="nodev"\nif mount | grep -qw "$partition"; then\n    if mount | grep "$partition" | grep -qw "$option"; then\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Pass"\n        echo "Current Value: $option option is set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Recommendation: No action needed."\n    else\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Fail"\n        echo "Current Value: $option option is not set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Remediation Steps:"\n        echo "1. Open the /etc/fstab file for editing:"\n        echo "   # sudo nano /etc/fstab"\n        echo "2. Add or modify the entry for /dev/shm to include $option. For example:"\n        echo "   tmpfs  /dev/shm  tmpfs  defaults,nodev,nosuid,noexec  0  0"\n        echo "3. Remount the /dev/shm partition:"\n        echo "   # sudo mount -o remount /dev/shm"\n        echo "4. Verify the changes:"\n        echo "   # mount | grep /dev/shm"\n    fi\nelse\n    echo "Check: Ensure $option option is set on $partition partition"\n    echo "Status: Fail"\n    echo "Current Value: $partition is not mounted."\n    echo "Expected Value: $partition should be mounted with $option."\n    echo "Remediation Steps:"\n    echo "1. Ensure $partition is mounted by adding it to /etc/fstab as shown:"\n    echo "   tmpfs  /dev/shm  tmpfs  defaults,nodev,nosuid,noexec  0  0"\n    echo "2. Mount the partition with:"\n    echo "   # sudo mount -a"\n    echo "3. Verify the changes:"\n    echo "   # mount | grep /dev/shm"\nfi\n', '# Check if loopback traffic is allowed\ncheck_ufw_loopback_traffic() {\n    loopback_status=$(ufw status verbose | grep \'ALLOW IN\' | grep \'127.0.0.1\')\n\n    if [[ -n "$loopback_status" ]]; then\n        echo "Check: Ensure UFW loopback traffic is configured"\n        echo "Status: Pass"\n        echo "Current Value: Loopback traffic is allowed."\n        echo "Expected Value: Loopback traffic should be allowed."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure UFW loopback traffic is configured"\n        echo "Status: Fail"\n        echo "Current Value: Loopback traffic is not allowed."\n        echo "Expected Value: Loopback traffic should be allowed."\n        echo "Recommendation: Allow loopback traffic."\n        echo "Remediation:"\n        echo "# sudo ufw allow in on lo"\n        echo "# sudo ufw reload"\n    fi\n}\n\n# Execute the check\ncheck_ufw_loopback_traffic', '# Check if loopback traffic is allowed\ncheck_ufw_loopback_traffic() {\n    loopback_status=$(ufw status verbose | grep \'ALLOW IN\' | grep \'127.0.0.1\')\n\n    if [[ -n "$loopback_status" ]]; then\n        echo "Check: Ensure UFW loopback traffic is configured"\n        echo "Status: Pass"\n        echo "Current Value: Loopback traffic is allowed."\n        echo "Expected Value: Loopback traffic should be allowed."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure UFW loopback traffic is configured"\n        echo "Status: Fail"\n        echo "Current Value: Loopback traffic is not allowed."\n        echo "Expected Value: Loopback traffic should be allowed."\n        echo "Recommendation: Allow loopback traffic."\n        echo "Remediation:"\n        echo "# sudo ufw allow in on lo"\n        echo "# sudo ufw reload"\n    fi\n}\n\n# Execute the check\ncheck_ufw_loopback_traffic\n', '#!/bin/bash\npartition="/dev/shm"\noption="nosuid"\nif mount | grep -qw "$partition"; then\n    if mount | grep "$partition" | grep -qw "$option"; then\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Pass"\n        echo "Current Value: $option option is set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Recommendation: No action needed."\n    else\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Fail"\n        echo "Current Value: $option option is not set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Remediation Steps:"\n        echo "1. Open the /etc/fstab file for editing:"\n        echo "   # sudo nano /etc/fstab"\n        echo "2. Add or modify the entry for /dev/shm to include $option. For example:"\n        echo "   tmpfs  /dev/shm  tmpfs  defaults,nodev,nosuid,noexec  0  0"\n        echo "3. Remount the /dev/shm partition:"\n        echo "   # sudo mount -o remount /dev/shm"\n        echo "4. Verify the changes:"\n        echo "   # mount | grep /dev/shm"\n    fi\nelse\n    echo "Check: Ensure $option option is set on $partition partition"\n    echo "Status: Fail"\n    echo "Current Value: $partition is not mounted."\n    echo "Expected Value: $partition should be mounted with $option."\n    echo "Remediation Steps:"\n    echo "1. Ensure $partition is mounted by adding it to /etc/fstab as shown:"\n    echo "   tmpfs  /dev/shm  tmpfs  defaults,nodev,nosuid,noexec  0  0"\n    echo "2. Mount the partition with:"\n    echo "   # sudo mount -a"\n    echo "3. Verify the changes:"\n    echo "   # mount | grep /dev/shm"\nfi\n', '# Check if outbound connections are allowed\ncheck_ufw_outbound_connections() {\n    outbound_status=$(ufw status verbose | grep \'ALLOW OUT\')\n\n    if [[ -n "$outbound_status" ]]; then\n        echo "Check: Ensure UFW outbound connections are configured"\n        echo "Status: Pass"\n        echo "Current Value: Outbound connections are allowed."\n        echo "Expected Value: Outbound connections should be allowed."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure UFW outbound connections are configured"\n        echo "Status: Fail"\n        echo "Current Value: Outbound connections are not allowed."\n        echo "Expected Value: Outbound connections should be allowed."\n        echo "Recommendation: Allow outbound connections."\n        echo "Remediation:"\n        echo "# sudo ufw default allow outgoing"\n        echo "# sudo ufw reload"\n    fi\n}\n\n# Execute the check\ncheck_ufw_outbound_connections\n', '# Check if UFW rules exist for all open ports\ncheck_ufw_firewall_rules() {\n    open_ports=$(ss -tuln | grep -oP \':\\K\\d+\' | sort -u)\n\n    if [[ -z "$open_ports" ]]; then\n        echo "Check: Ensure UFW firewall rules exist for all open ports"\n        echo "Status: Fail"\n        echo "Current Value: No open ports found."\n        echo "Expected Value: UFW should have firewall rules for open ports."\n        echo "Recommendation: No open ports found."\n    else\n        echo "Check: Ensure UFW firewall rules exist for all open ports"\n        echo "Status: Pass"\n        echo "Current Value: Open ports are identified and rules should exist for them."\n        echo "Expected Value: UFW should have firewall rules for open ports."\n        echo "Recommendation: No remediation required."\n        echo "Firewall Rules for Open Ports:"\n        for port in $open_ports; do\n            echo " - sudo ufw allow $port"\n        done\n    fi\n}\n\n# Execute the check\ncheck_ufw_firewall_rules\n', '#!/bin/bash\npartition="/dev/shm"\noption="noexec"\n\nif mount | grep -qw "$partition"; then\n    if mount | grep "$partition" | grep -qw "$option"; then\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Pass"\n        echo "Current Value: $option option is set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Recommendation: No action needed."\n    else\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Fail"\n        echo "Current Value: $option option is not set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Remediation Steps:"\n        echo "1. Open the /etc/fstab file for editing:"\n        echo "   # sudo nano /etc/fstab"\n        echo "2. Add or modify the entry for /dev/shm to include $option. For example:"\n        echo "   tmpfs  /dev/shm  tmpfs  defaults,nodev,nosuid,noexec  0  0"\n        echo "3. Remount the /dev/shm partition:"\n        echo "   # sudo mount -o remount /dev/shm"\n        echo "4. Verify the changes:"\n        echo "   # mount | grep /dev/shm"\n    fi\nelse\n    echo "Check: Ensure $option option is set on $partition partition"\n    echo "Status: Fail"\n    echo "Current Value: $partition is not mounted."\n    echo "Expected Value: $partition should be mounted with $option."\n    echo "Remediation Steps:"\n    echo "1. Ensure $partition is mounted by adding it to /etc/fstab as shown:"\n    echo "   tmpfs  /dev/shm  tmpfs  defaults,nodev,nosuid,noexec  0  0"\n    echo "2. Mount the partition with:"\n    echo "   # sudo mount -a"\n    echo "3. Verify the changes:"\n    echo "   # mount | grep /dev/shm"\nfi\n', 'check_ufw_default_deny_policy(){\ndefault_status=$(ufw status verbose | grep \'Default\' | grep \'deny\')\nif [[ -n \\"$default_status\\" ]]; then\necho \\"Check: Ensure UFW default deny firewall policy\\"\necho \\"Status: Pass\\"\necho \\"Current Value: Default UFW policy is set to deny.\\"\necho \\"Expected Value: Default policy should be set to deny.\\"\necho \\"Recommendation: No remediation required.\\"\nelse\necho \\"Check: Ensure UFW default deny firewall policy\\"\necho \\"Status: Fail\\"\necho \\"Current Value: Default UFW policy is not set to deny.\\"\necho \\"Expected Value: Default policy should be set to deny.\\"\necho \\"Recommendation: Set UFW default policy to deny.\\"\necho \\"Remediation:\\"\necho \\"# sudo ufw default deny incoming\\"\necho \\"# sudo ufw default deny outgoing\\"\necho \\"# sudo ufw reload\\"\nfi\n}\ncheck_ufw_default_deny_policy\n', 'check_nftables_installed(){\nif command -v nft > /dev/null; then\necho "Check: Ensure nftables is installed"\n\necho "Status: Pass"\n\necho "Current Value: nftables is installed."\n\necho "Expected Value: nftables should be installed."\n\necho "Recommendation: No remediation required."\n\nelse\n\necho "Check: Ensure nftables is installed"\n\necho "Status: Fail"\n\necho "Current Value: nftables is not installed."\n\necho "Expected Value: nftables should be installed."\n\necho "Recommendation: Install nftables."\n\necho "Remediation:"\n\necho "# sudo apt-get install nftables"\n\nfi\n\n}\ncheck_nftables_installed\n', '#!/bin/bash\npartition="/home"\n\nif mount | grep -qw "$partition"; then\n    echo "Check: Ensure $partition is a separate partition"\n    echo "Status: Pass"\n    echo "Current Value: $partition is mounted as a separate partition."\n    echo "Expected Value: $partition should be mounted as a separate partition."\n    echo "Recommendation: No action needed."\nelse\n    echo "Check: Ensure $partition is a separate partition"\n    echo "Status: Fail"\n    echo "Current Value: $partition is not mounted as a separate partition."\n    echo "Expected Value: $partition should be mounted as a separate partition."\n    echo "Remediation Steps:"\n    echo "1. Create a partition for /home if it does not already exist:"\n    echo "   # sudo fdisk /dev/<disk_name>"\n    echo "   (Replace <disk_name> with your actual disk name, e.g., sda)"\n    echo "2. Format the partition:"\n    echo "   # sudo mkfs.ext4 /dev/<partition_name>"\n    echo "3. Open /etc/fstab for editing:"\n    echo "   # sudo nano /etc/fstab"\n    echo "4. Add the following entry:"\n    echo "   /dev/<partition_name>  /home  ext4  defaults,nodev,nosuid  0  2"\n    echo "5. Mount the partition with:"\n    echo "   # sudo mount -a"\n    echo "6. Verify the changes:"\n    echo "   # mount | grep/home"\nfi\n', "check_ufw_disabled_with_nftables(){\nif command -v ufw > /dev/null && systemctl is-enabled ufw > /dev/null; then\necho 'Check: Ensure ufw is uninstalled or disabled with nftables'\necho 'Status: Fail'\necho 'Current Value: UFW is installed and enabled.'\necho 'Expected Value: UFW should be uninstalled or disabled with nftables.'\necho 'Recommendation: Disable or uninstall UFW.'\necho 'Remediation:'\necho '# sudo systemctl stop ufw'\necho '# sudo systemctl disable ufw'\necho '# sudo apt-get remove --purge ufw'\nelse\necho 'Check: Ensure ufw is uninstalled or disabled with nftables'\necho 'Status: Pass'\necho 'Current Value: UFW is either uninstalled or disabled.'\necho 'Expected Value: UFW should be uninstalled or disabled.'\necho 'Recommendation: No remediation required.'\nfi\n}\ncheck_ufw_disabled_with_nftables", '#!/bin/bash\n\npartition="/home"\noption="nodev"\n\nif mount | grep -qw "$partition"; then\n    if mount | grep "$partition" | grep -qw "$option"; then\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Pass"\n        echo "Current Value: $option option is set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Recommendation: No action needed."\n    else\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Fail"\n        echo "Current Value: $option option is not set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Remediation Steps:"\n        echo "1. Open the /etc/fstab file for editing:"\n        echo "   # sudo nano /etc/fstab"\n        echo "2. Add or modify the entry for /home to include $option. For example:"\n        echo "   /dev/<partition_name>  /home  ext4  defaults,nodev,nosuid  0  2"\n        echo "3. Remount the /home partition:"\n        echo "   # sudo mount -o remount /home"\n        echo "4. Verify the changes:"\n        echo "   # mount | grep /home"\n    fi\nelse\n    echo "Check: Ensure $option option is set on $partition partition"\n    echo "Status: Fail"\n    echo "Current Value: $partition is not mounted."\n    echo "Expected Value: $partition should be mounted with $option."\n    echo "Remediation Steps:"\n    echo "1. Ensure $partition is mounted by adding it to /etc/fstab as shown:"\n    echo "   /dev/<partition_name>  /home  ext4  defaults,nodev,nosuid  0  2"\n    echo "2. Mount the partition with:"\n    echo "   # sudo mount -a"\n    echo "3. Verify the changes:"\n    echo "   # mount | grep /home"\nfi\n ', '#!/bin/bash\n\npartition="/home"\noption="nosuid"\n\nif mount | grep -qw "$partition"; then\n    if mount | grep "$partition" | grep -qw "$option"; then\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Pass"\n        echo "Current Value: $option option is set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Recommendation: No action needed."\n    else\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Fail"\n        echo "Current Value: $option option is not set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Remediation Steps:"\n        echo "1. Open the /etc/fstab file for editing:"\n        echo "   # sudo nano /etc/fstab"\n        echo "2. Add or modify the entry for /home to include $option. For example:"\n        echo "   /dev/<partition_name>  /home  ext4  defaults,nodev,nosuid  0  2"\n        echo "3. Remount the /home partition:"\n        echo "   # sudo mount -o remount /home"\n        echo "4. Verify the changes:"\n        echo "   # mount | grep /home"\n    fi\nelse\n    echo "Check: Ensure $option option is set on $partition partition"\n    echo "Status: Fail"\n    echo "Current Value: $partition is not mounted."\n    echo "Expected Value: $partition should be mounted with $option."\n    echo "Remediation Steps:"\n    echo "1. Ensure $partition is mounted by adding it to /etc/fstab as shown:"\n    echo "   /dev/<partition_name>  /home  ext4  defaults,nodev,nosuid  0  2"\n    echo "2. Mount the partition with:"\n    echo "   # sudo mount -a"\n    echo "3. Verify the changes:"\n    echo "   # mount | grep /home"\nfi\n', '#!/bin/bash\n\npartition="/var"\n\nif mount | grep -qw "$partition"; then\n    echo "Check: Ensure $partition is a separate partition"\n    echo "Status: Pass"\n    echo "Current Value: $partition is mounted as a separate partition."\n    echo "Expected Value: $partition should be mounted as a separate partition."\n    echo "Recommendation: No action needed."\nelse\n    echo "Check: Ensure $partition is a separate partition"\n    echo "Status: Fail"\n    echo "Current Value: $partition is not mounted as a separate partition."\n    echo "Expected Value: $partition should be mounted as a separate partition."\n    echo "Remediation Steps:"\n    echo "1. Create a partition for /var if it does not already exist:"\n    echo "   # sudo fdisk /dev/<disk_name>"\n    echo "   (Replace <disk_name> with your actual disk name, e.g., sda)"\n    echo "2. Format the partition:"\n    echo "   # sudo mkfs.ext4 /dev/<partition_name>"\n    echo "3. Open /etc/fstab for editing:"\n    echo "   # sudo nano /etc/fstab"\n    echo "4. Add the following entry:"\n    echo "   /dev/<partition_name>  /var  ext4  defaults,nodev,nosuid  0  2"\n    echo "5. Mount the partition with:"\n    echo "   # sudo mount -a"\n    echo "6. Verify the changes:"\n    echo "   # mount | grep /var"\nfi', 'check_iptables_flushed_with_nftables() { if iptables -L > /dev/null; then echo "Check: Ensure iptables are flushed with nftables"\n echo "Status: Fail"\n echo "Current Value: iptables are still active."\n echo "Expected Value: iptables should be flushed."\n echo "Recommendation: Flush iptables rules and ensure nftables is in use."\n echo "Remediation:"\n echo "# sudo iptables -F"\n echo "# sudo systemctl stop iptables"\n echo "# sudo systemctl disable iptables"\n echo "# sudo systemctl enable nftables"\n else echo "Check: Ensure iptables are flushed with nftables"\n echo "Status: Pass"\n echo "Current Value: iptables are flushed."\n echo "Expected Value: iptables should be flushed."\n echo "Recommendation: No remediation required."\n fi }\n\n# Execute the check\ncheck_iptables_flushed_with_nftables', '#!/bin/bash\n\npartition="/var"\noption="nodev"\n\nif mount | grep -qw "$partition"; then\n    if mount | grep "$partition" | grep -qw "$option"; then\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Pass"\n        echo "Current Value: $option option is set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Recommendation: No action needed."\n    else\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Fail"\n        echo "Current Value: $option option is not set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Remediation Steps:"\n        echo "1. Open the /etc/fstab file for editing:"\n        echo "   # sudo nano /etc/fstab"\n        echo "2. Add or modify the entry for /var to include $option. For example:"\n        echo "   /dev/<partition_name>  /var  ext4  defaults,nodev,nosuid  0  2"\n        echo "3. Remount the /var partition:"\n        echo "   # sudo mount -o remount /var"\n        echo "4. Verify the changes:"\n        echo "   # mount | grep /var"\n    fi\nelse\n    echo "Check: Ensure $option option is set on $partition partition"\n    echo "Status: Fail"\n    echo "Current Value: $partition is not mounted."\n    echo "Expected Value: $partition should be mounted with $option."\n    echo "Remediation Steps:"\n    echo "1. Ensure $partition is mounted by adding it to /etc/fstab as shown:"\n    echo "   /dev/<partition_name>  /var  ext4  defaults,nodev,nosuid  0  2"\n    echo "2. Mount the partition with:"\n    echo "   # sudo mount -a"\n    echo "3. Verify the changes:"\n    echo "   # mount | grep /var"\nfi\n ', '#!/bin/bash\n# Check if nftables table exists\ncheck_nftables_table_exists() {\n    if nft list tables | grep -q "table"; then\n        echo "Check: Ensure a nftables table exists"\n        echo "Status: Pass"\n        echo "Current Value: nftables table exists."\n        echo "Expected Value: A nftables table should exist."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure a nftables table exists"\n        echo "Status: Fail"\n        echo "Current Value: No nftables table exists."\n        echo "Expected Value: A nftables table should exist."\n        echo "Recommendation: Create a nftables table."\n        echo "Remediation:"\n        echo "# sudo nft add table inet filter"\n    fi\n}\n# Execute the check\ncheck_nftables_table_exists', '#!/bin/bash\n\npartition="/var"\noption="nosuid"\n\nif mount | grep -qw "$partition"; then\n    if mount | grep "$partition" | grep -qw "$option"; then\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Pass"\n        echo "Current Value: $option option is set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Recommendation: No action needed."\n    else\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Fail"\n        echo "Current Value: $option option is not set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Remediation Steps:"\n        echo "1. Open the /etc/fstab file for editing:"\n        echo "   # sudo nano /etc/fstab"\n        echo "2. Add or modify the entry for /var to include $option. For example:"\n        echo "   /dev/<partition_name>  /var  ext4  defaults,nodev,nosuid  0  2"\n        echo "3. Remount the /var partition:"\n        echo "   # sudo mount -o remount /var"\n        echo "4. Verify the changes:"\n        echo "   # mount | grep /var"\n    fi\nelse\n    echo "Check: Ensure $option option is set on $partition partition"\n    echo "Status: Fail"\n    echo "Current Value: $partition is not mounted."\n    echo "Expected Value: $partition should be mounted with $option."\n    echo "Remediation Steps:"\n    echo "1. Ensure $partition is mounted by adding it to /etc/fstab as shown:"\n    echo "   /dev/<partition_name>  /var  ext4  defaults,nodev,nosuid  0  2"\n    echo "2. Mount the partition with:"\n    echo "   # sudo mount -a"\n    echo "3. Verify the changes:"\n    echo "   # mount | grep /var"\nfi', 'check_nftables_base_chains(){\nif nft list ruleset | grep -q "input" && nft list ruleset | grep -q "output" && nft list ruleset | grep -q "forward";then\necho "Check: Ensure nftables base chains exist"\necho "Status: Pass"\necho "Current Value: Base chains (input, output, forward) exist."\necho "Expected Value: Base chains should exist in nftables."\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure nftables base chains exist"\necho "Status: Fail"\necho "Current Value: Base chains are missing."\necho "Expected Value: Base chains should exist in nftables."\necho "Recommendation: Add base chains to nftables."\necho "Remediation:"\necho "# sudo nft add chain inet filter input { type filter hook input priority 0 \\; }"\necho "# sudo nft add chain inet filter output { type filter hook output priority 0 \\; }"\necho "# sudo nft add chain inet filter forward { type filter hook forward priority 0 \\; }"\nfi\n}\n\n# Execute the check\ncheck_nftables_base_chains\n', 'check_nftables_loopback_traffic(){\nloopback_status=$(nft list ruleset | grep "iif lo accept")\nif [[ -n "$loopback_status" ]];then\necho "Check: Ensure nftables loopback traffic is configured"\necho "Status: Pass"\necho "Current Value: Loopback traffic is allowed."\necho "Expected Value: Loopback traffic should be allowed."\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure nftables loopback traffic is configured"\necho "Status: Fail"\necho "Current Value: Loopback traffic is not allowed."\necho "Expected Value: Loopback traffic should be allowed."\necho "Recommendation: Allow loopback traffic."\necho "Remediation:"\necho "# sudo nft add rule inet filter input iif lo accept"\necho "# sudo nft add rule inet filter output oif lo accept"\nfi\n}\n\n# Execute the check\ncheck_nftables_loopback_traffic\n', 'check_nftables_outbound_established(){\noutbound_status=$(nft list ruleset | grep "ip dport")\nestablished_status=$(nft list ruleset | grep "ct state established")\nif [[ -n "$outbound_status" && -n "$established_status" ]];then\necho "Check: Ensure nftables outbound and established connections are configured"\necho "Status: Pass"\necho "Current Value: Outbound and established connections are configured."\necho "Expected Value: Outbound and established connections should be configured."\necho "Recommendation: No remediation required."\nelse\necho "Check: Ensure nftables outbound and established connections are configured"\necho "Status: Fail"\necho "Current Value: Outbound or established connections are not configured."\necho "Expected Value: Outbound and established connections should be configured."\necho "Recommendation: Configure outbound and established connections."\necho "Remediation:"\necho "# sudo nft add rule inet filter output ct state established,related accept"\necho "# sudo nft add rule inet filter input ct state established,related accept"\nfi\n}\n\n# Execute the check\ncheck_nftables_outbound_established\n', '#!/bin/bash\npartition="/var/tmp"\nif mount | grep -qw "$partition"; then\n    echo "Check: Ensure $partition is a separate partition"\n    echo "Status: Pass"\n    echo "Current Value: $partition is mounted as a separate partition."\n    echo "Expected Value: $partition should be mounted as a separate partition."\n    echo "Recommendation: No action needed."\nelse\n    echo "Check: Ensure $partition is a separate partition"\n    echo "Status: Fail"\n    echo "Current Value: $partition is not mounted as a separate partition."\n    echo "Expected Value: $partition should be mounted as a separate partition."\n    echo "Remediation Steps:"\n    echo "1. Create a partition for /var/tmp if it does not already exist:"\n    echo "   # sudo fdisk /dev/<disk_name>"\n    echo "   (Replace <disk_name> with your actual disk name, e.g., sda)"\n    echo "2. Format the partition:"\n    echo "   # sudo mkfs.ext4 /dev/<partition_name>"\n    echo "3. Open /etc/fstab for editing:"\n    echo "   # sudo nano /etc/fstab"\n    echo "4. Add the following entry:"\n    echo "   /dev/<partition_name>  /var/tmp  ext4  defaults,nodev,nosuid,noexec  0  2"\n    echo "5. Mount the partition with:"\n    echo "   # sudo mount -a"\n    echo "6. Verify the changes:"\n    echo "   # mount | grep /var/tmp"\nfi', '#!/bin/bash\npartition="/var/tmp"\noption="nodev"\nif mount | grep -qw "$partition"; then\n    if mount | grep "$partition" | grep -qw "$option"; then\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Pass"\n        echo "Current Value: $option option is set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Recommendation: No action needed."\n    else\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Fail"\n        echo "Current Value: $option option is not set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Remediation Steps:"\n        echo "1. Open the /etc/fstab file for editing:"\n        echo "   # sudo nano /etc/fstab"\n        echo "2. Add or modify the entry for /var/tmp to include $option. For example:"\n        echo "   /dev/<partition_name>  /var/tmp  ext4  defaults,nodev,nosuid,noexec  0  2"\n        echo "3. Remount the /var/tmp partition:"\n        echo "   # sudo mount -o remount /var/tmp"\n        echo "4. Verify the changes:"\n        echo "   # mount | grep /var/tmp"\n    fi\nelse\n    echo "Check: Ensure $option option is set on $partition partition"\n    echo "Status: Fail"\n    echo "Current Value: $partition is not mounted."\n    echo "Expected Value: $partition should be mounted with $option."\n    echo "Remediation Steps:"\n    echo "1. Ensure $partition is mounted by adding it to /etc/fstab as shown:"\n    echo "   /dev/<partition_name>  /var/tmp  ext4  defaults,nodev,nosuid,noexec  0  2"\n    echo "2. Mount the partition with:"\n    echo "   # sudo mount -a"\n    echo "3. Verify the changes:"\n    echo "   # mount | grep /var/tmp"\nfi', '#!/bin/bash\npartition="/var/tmp"\noption="nosuid"\nif mount | grep -qw "$partition"; then\n    if mount | grep "$partition" | grep -qw "$option"; then\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Pass"\n        echo "Current Value: $option option is set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Recommendation: No action needed."\n    else\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Fail"\n        echo "Current Value: $option option is not set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Remediation Steps:"\n        echo "1. Open the /etc/fstab file for editing:"\n        echo "   # sudo nano /etc/fstab"\n        echo "2. Add or modify the entry for /var/tmp to include $option. For example:"\n        echo "   /dev/<partition_name>  /var/tmp  ext4  defaults,nodev,nosuid,noexec  0  2"\n        echo "3. Remount the /var/tmp partition:"\n        echo "   # sudo mount -o remount /var/tmp"\n        echo "4. Verify the changes:"\n        echo "   # mount | grep /var/tmp"\n    fi\nelse\n    echo "Check: Ensure $option option is set on $partition partition"\n    echo "Status: Fail"\n    echo "Current Value: $partition is not mounted."\n    echo "Expected Value: $partition should be mounted with $option."\n    echo "Remediation Steps:"\n    echo "1. Ensure $partition is mounted by adding it to /etc/fstab as shown:"\n    echo "   /dev/<partition_name>  /var/tmp  ext4  defaults,nodev,nosuid,noexec  0  2"\n    echo "2. Mount the partition with:"\n    echo "   # sudo mount -a"\n    echo "3. Verify the changes:"\n    echo "   # mount | grep /var/tmp"\nfi', '#!/bin/bash\npartition="/var/tmp"\noption="noexec"\nif mount | grep -qw "$partition"; then\n    if mount | grep "$partition" | grep -qw "$option"; then\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Pass"\n        echo "Current Value: $option option is set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Recommendation: No action needed."\n    else\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Fail"\n        echo "Current Value: $option option is not set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Remediation Steps:"\n        echo "1. Open the /etc/fstab file for editing:"\n        echo "   # sudo nano /etc/fstab"\n        echo "2. Add or modify the entry for /var/tmp to include $option. For example:"\n        echo "   /dev/<partition_name>  /var/tmp  ext4  defaults,nodev,nosuid,noexec  0  2"\n        echo "3. Remount the /var/tmp partition:"\n        echo "   # sudo mount -o remount /var/tmp"\n        echo "4. Verify the changes:"\n        echo "   # mount | grep /var/tmp"\n    fi\nelse\n    echo "Check: Ensure $option option is set on $partition partition"\n    echo "Status: Fail"\n    echo "Current Value: $partition is not mounted."\n    echo "Expected Value: $partition should be mounted with $option."\n    echo "Remediation Steps:"\n    echo "1. Ensure $partition is mounted by adding it to /etc/fstab as shown:"\n    echo "   /dev/<partition_name>  /var/tmp  ext4  defaults,nodev,nosuid,noexec  0  2"\n    echo "2. Mount the partition with:"\n    echo "   # sudo mount -a"\n    echo "3. Verify the changes:"\n    echo "   # mount | grep /var/tmp"\nfi', '#!/bin/bash\npartition="/var/log"\nif mount | grep -qw "$partition"; then\n    echo "Check: Ensure $partition is a separate partition"\n    echo "Status: Pass"\n    echo "Current Value: $partition is mounted as a separate partition."\n    echo "Expected Value: $partition should be mounted as a separate partition."\n    echo "Recommendation: No action needed."\nelse\n    echo "Check: Ensure $partition is a separate partition"\n    echo "Status: Fail"\n    echo "Current Value: $partition is not mounted as a separate partition."\n    echo "Expected Value: $partition should be mounted as a separate partition."\n    echo "Remediation Steps:"\n    echo "1. Create a partition for /var/log if it does not already exist:"\n    echo "   # sudo fdisk /dev/<disk_name>"\n    echo "   (Replace <disk_name> with your actual disk name, e.g., sda)"\n    echo "2. Format the partition:"\n    echo "   # sudo mkfs.ext4 /dev/<partition_name>"\n    echo "3. Open /etc/fstab for editing:"\n    echo "   # sudo nano /etc/fstab"\n    echo "4. Add the following entry:"\n    echo "   /dev/<partition_name>  /var/log  ext4  defaults,nodev,nosuid,noexec  0  2"\n    echo "5. Mount the partition with:"\n    echo "   # sudo mount -a"\n    echo "6. Verify the changes:"\n    echo "   # mount | grep /var/log"\nfi', '# Check if nftables default deny policy is set\ncheck_nftables_default_deny_policy() {\n    default_status=$(nft list ruleset | grep "default drop")\n\n    if [[ -n "$default_status" ]]; then\n        echo "Check: Ensure nftables default deny firewall policy"\n        echo "Status: Pass"\n        echo "Current Value: Default policy is set to deny."\n        echo "Expected Value: Default policy should be set to deny."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure nftables default deny firewall policy"\n        echo "Status: Fail"\n        echo "Current Value: Default policy is not set to deny."\n        echo "Expected Value: Default policy should be set to deny."\n        echo "Recommendation: Set nftables default policy to deny."\n        echo "Remediation:"\n        echo "# sudo nft add rule inet filter input drop"\n        echo "# sudo nft add rule inet filter output drop"\n        echo "# sudo nft add rule inet filter forward drop"\n    fi\n}\n\n# Execute the check\ncheck_nftables_default_deny_policy\n', '# Check if nftables service is enabled\ncheck_nftables_service_enabled() {\n    if systemctl is-enabled nftables >/dev/null; then\n        echo "Check: Ensure nftables service is enabled"\n        echo "Status: Pass"\n        echo "Current Value: nftables service is enabled."\n        echo "Expected Value: nftables service should be enabled."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure nftables service is enabled"\n        echo "Status: Fail"\n        echo "Current Value: nftables service is not enabled."\n        echo "Expected Value: nftables service should be enabled."\n        echo "Recommendation: Enable nftables service."\n        echo "Remediation:"\n        echo "# sudo systemctl enable nftables"\n        echo "# sudo systemctl start nftables"\n    fi\n}\n\n# Execute the check\ncheck_nftables_service_enabled\n', '# Ensure nftables rules are permanent\ncheck_nftables_rules_permanent() {\n    if nft list ruleset > /etc/nftables.conf; then\n        echo "Check: Ensure nftables rules are permanent"\n        echo "Status: Pass"\n        echo "Current Value: nftables rules are permanent."\n        echo "Expected Value: nftables rules should be permanent."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure nftables rules are permanent"\n        echo "Status: Fail"\n        echo "Current Value: nftables rules are not permanent."\n        echo "Expected Value: nftables rules should be permanent."\n        echo "Recommendation: Save nftables rules to file."\n        echo "Remediation:"\n        echo "# sudo nft list ruleset > /etc/nftables.conf"\n        echo "# sudo systemctl enable nftables"\n        echo "# sudo systemctl start nftables"\n    fi\n}\n\n# Execute the check\ncheck_nftables_rules_permanent\n', '# Check if iptables is installed\ncheck_iptables_installed() {\n    if command -v iptables > /dev/null; then\n        echo "Check: Ensure iptables software is installed"\n        echo "Status: Pass"\n        echo "Current Value: iptables is installed."\n        echo "Expected Value: iptables should be installed."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure iptables software is installed"\n        echo "Status: Fail"\n        echo "Current Value: iptables is not installed."\n        echo "Expected Value: iptables should be installed."\n        echo "Recommendation: Install iptables."\n        echo "Remediation:"\n        echo "# sudo apt-get install iptables"\n    fi\n}\n\n# Execute the check\ncheck_iptables_installed\n', '#!/bin/bash\n\npartition="/var/log"\noption="nodev"\n\nif mount | grep -qw "$partition"; then\n    if mount | grep "$partition" | grep -qw "$option"; then\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Pass"\n        echo "Current Value: $option option is set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Recommendation: No action needed."\n    else\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Fail"\n        echo "Current Value: $option option is not set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Remediation Steps:"\n        echo "1. Open the /etc/fstab file for editing:"\n        echo "   # sudo nano /etc/fstab"\n        echo "2. Add or modify the entry for /var/log to include $option. For example:"\n        echo "   /dev/<partition_name>  /var/log  ext4  defaults,nodev,nosuid,noexec  0  2"\n        echo "3. Remount the /var/log partition:"\n        echo "   # sudo mount -o remount /var/log"\n        echo "4. Verify the changes:"\n        echo "   # mount | grep /var/log"\n    fi\nelse\n    echo "Check: Ensure $option option is set on $partition partition"\n    echo "Status: Fail"\n    echo "Current Value: $partition is not mounted."\n    echo "Expected Value: $partition should be mounted with $option."\n    echo "Remediation Steps:"\n    echo "1. Ensure $partition is mounted by adding it to /etc/fstab as shown:"\n    echo "   /dev/<partition_name>  /var/log  ext4  defaults,nodev,nosuid,noexec  0  2"\n    echo "2. Mount the partition with:"\n    echo "   # sudo mount -a"\n    echo "3. Verify the changes:"\n    echo "   # mount | grep /var/log"\nfi', '#!/bin/bash\n\npartition="/var/log"\noption="nosuid"\n\nif mount | grep -qw "$partition"; then\n    if mount | grep "$partition" | grep -qw "$option"; then\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Pass"\n        echo "Current Value: $option option is set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Recommendation: No action needed."\n    else\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Fail"\n        echo "Current Value: $option option is not set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Remediation Steps:"\n        echo "1. Open the /etc/fstab file for editing:"\n        echo "   # sudo nano /etc/fstab"\n        echo "2. Add or modify the entry for /var/log to include $option. For example:"\n        echo "   /dev/<partition_name>  /var/log  ext4  defaults,nodev,nosuid,noexec  0  2"\n        echo "3. Remount the /var/log partition:"\n        echo "   # sudo mount -o remount /var/log"\n        echo "4. Verify the changes:"\n        echo "   # mount | grep /var/log"\n    fi\nelse\n    echo "Check: Ensure $option option is set on $partition partition"\n    echo "Status: Fail"\n    echo "Current Value: $partition is not mounted."\n    echo "Expected Value: $partition should be mounted with $option."\n    echo "Remediation Steps:"\n    echo "1. Ensure $partition is mounted by adding it to /etc/fstab as shown:"\n    echo "   /dev/<partition_name>  /var/log  ext4  defaults,nodev,nosuid,noexec  0  2"\n    echo "2. Mount the partition with:"\n    echo "   # sudo mount -a"\n    echo "3. Verify the changes:"\n    echo "   # mount | grep /var/log"\nfi', '#!/bin/bash\n\npartition="/var/log"\noption="noexec"\n\nif mount | grep -qw "$partition"; then\n    if mount | grep "$partition" | grep -qw "$option"; then\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Pass"\n        echo "Current Value: $option option is set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Recommendation: No action needed."\n    else\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Fail"\n        echo "Current Value: $option option is not set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Remediation Steps:"\n        echo "1. Open the /etc/fstab file for editing:"\n        echo "   # sudo nano /etc/fstab"\n        echo "2. Add or modify the entry for /var/log to include $option. For example:"\n        echo "   /dev/<partition_name>  /var/log  ext4  defaults,nodev,nosuid,noexec  0  2"\n        echo "3. Remount the /var/log partition:"\n        echo "   # sudo mount -o remount /var/log"\n        echo "4. Verify the changes:"\n        echo "   # mount | grep /var/log"\n    fi\nelse\n    echo "Check: Ensure $option option is set on $partition partition"\n    echo "Status: Fail"\n    echo "Current Value: $partition is not mounted."\n    echo "Expected Value: $partition should be mounted with $option."\n    echo "Remediation Steps:"\n    echo "1. Ensure $partition is mounted by adding it to /etc/fstab as shown:"\n    echo "   /dev/<partition_name>  /var/log  ext4  defaults,nodev,nosuid,noexec  0  2"\n    echo "2. Mount the partition with:"\n    echo "   # sudo mount -a"\n    echo "3. Verify the changes:"\n    echo "   # mount | grep /var/log"\nfi', '#!/bin/bash\n\npartition="/var/log/audit"\n\nif mount | grep -qw "$partition"; then\n    echo "Check: Ensure $partition is a separate partition"\n    echo "Status: Pass"\n    echo "Current Value: $partition is mounted as a separate partition."\n    echo "Expected Value: $partition should be mounted as a separate partition."\n    echo "Recommendation: No action needed."\nelse\n    echo "Check: Ensure $partition is a separate partition"\n    echo "Status: Fail"\n    echo "Current Value: $partition is not mounted as a separate partition."\n    echo "Expected Value: $partition should be mounted as a separate partition."\n    echo "Remediation Steps:"\n    echo "1. Create a partition for /var/log/audit if it does not already exist:"\n    echo "   # sudo fdisk /dev/<disk_name>"\n    echo "   (Replace <disk_name> with your actual disk name, e.g., sda)"\n    echo "2. Format the partition:"\n    echo "   # sudo mkfs.ext4 /dev/<partition_name>"\n    echo "3. Open /etc/fstab for editing:"\n    echo "   # sudo nano /etc/fstab"\n    echo "4. Add the following entry:"\n    echo "   /dev/<partition_name>  /var/log/audit  ext4  defaults,nodev,nosuid,noexec  0  2"\n    echo "5. Mount the partition with:"\n    echo "   # sudo mount -a"\n    echo "6. Verify the changes:"\n    echo "   # mount | grep /var/log/audit"\nfi', '#!/bin/bash\n\npartition="/var/log/audit"\noption="nodev"\n\nif mount | grep -qw "$partition"; then\n    if mount | grep "$partition" | grep -qw "$option"; then\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Pass"\n        echo "Current Value: $option option is set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Recommendation: No action needed."\n    else\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Fail"\n        echo "Current Value: $option option is not set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Remediation Steps:"\n        echo "1. Open the /etc/fstab file for editing:"\n        echo "   # sudo nano /etc/fstab"\n        echo "2. Add or modify the entry for /var/log/audit to include $option. For example:"\n        echo "   /dev/<partition_name>  /var/log/audit  ext4  defaults,nodev,nosuid,noexec  0  2"\n        echo "3. Remount the /var/log/audit partition:"\n        echo "   # sudo mount -o remount /var/log/audit"\n        echo "4. Verify the changes:"\n        echo "   # mount | grep /var/log/audit"\n    fi\nelse\n    echo "Check: Ensure $option option is set on $partition partition"\n    echo "Status: Fail"\n    echo "Current Value: $partition is not mounted."\n    echo "Expected Value: $partition should be mounted with $option."\n    echo "Remediation Steps:"\n    echo "1. Ensure $partition is mounted by adding it to /etc/fstab as shown:"\n    echo "   /dev/<partition_name>  /var/log/audit  ext4  defaults,nodev,nosuid,noexec  0  2"\n    echo "2. Mount the partition with:"\n    echo "   # sudo mount -a"\n    echo "3. Verify the changes:"\n    echo "   # mount | grep /var/log/audit"\nfi', '#!/bin/bash\n\npartition="/var/log/audit"\noption="nosuid"\n\nif mount | grep -qw "$partition"; then\n    if mount | grep "$partition" | grep -qw "$option"; then\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Pass"\n        echo "Current Value: $option option is set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Recommendation: No action needed."\n    else\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Fail"\n        echo "Current Value: $option option is not set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Remediation Steps:"\n        echo "1. Open the /etc/fstab file for editing:"\n        echo "   # sudo nano /etc/fstab"\n        echo "2. Add or modify the entry for /var/log/audit to include $option. For example:"\n        echo "   /dev/<partition_name>  /var/log/audit  ext4  defaults,nodev,nosuid,noexec  0  2"\n        echo "3. Remount the /var/log/audit partition:"\n        echo "   # sudo mount -o remount /var/log/audit"\n        echo "4. Verify the changes:"\n        echo "   # mount | grep /var/log/audit"\n    fi\nelse\n    echo "Check: Ensure $option option is set on $partition partition"\n    echo "Status: Fail"\n    echo "Current Value: $partition is not mounted."\n    echo "Expected Value: $partition should be mounted with $option."\n    echo "Remediation Steps:"\n    echo "1. Ensure $partition is mounted by adding it to /etc/fstab as shown:"\n    echo "   /dev/<partition_name>  /var/log/audit  ext4  defaults,nodev,nosuid,noexec  0  2"\n    echo "2. Mount the partition with:"\n    echo "   # sudo mount -a"\n    echo "3. Verify the changes:"\n    echo "   # mount | grep /var/log/audit"\nfi', '#!/bin/bash\n\npartition="/var/log/audit"\noption="noexec"\n\nif mount | grep -qw "$partition"; then\n    if mount | grep "$partition" | grep -qw "$option"; then\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Pass"\n        echo "Current Value: $option option is set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Recommendation: No action needed."\n    else\n        echo "Check: Ensure $option option is set on $partition partition"\n        echo "Status: Fail"\n        echo "Current Value: $option option is not set on $partition."\n        echo "Expected Value: $option option should be set on $partition."\n        echo "Remediation Steps:"\n        echo "1. Open the /etc/fstab file for editing:"\n        echo "   # sudo nano /etc/fstab"\n        echo "2. Add or modify the entry for /var/log/audit to include $option. For example:"\n        echo "   /dev/<partition_name>  /var/log/audit  ext4  defaults,nodev,nosuid,noexec  0  2"\n        echo "3. Remount the /var/log/audit partition:"\n        echo "   # sudo mount -o remount /var/log/audit"\n        echo "4. Verify the changes:"\n        echo "   # mount | grep /var/log/audit"\n    fi\nelse\n    echo "Check: Ensure $option option is set on $partition partition"\n    echo "Status: Fail"\n    echo "Current Value: $partition is not mounted."\n    echo "Expected Value: $partition should be mounted with $option."\n    echo "Remediation Steps:"\n    echo "1. Ensure $partition is mounted by adding it to /etc/fstab as shown:"\n    echo "   /dev/<partition_name>  /var/log/audit  ext4  defaults,nodev,nosuid,noexec  0  2"\n    echo "2. Mount the partition with:"\n    echo "   # sudo mount -a"\n    echo "3. Verify the changes:"\n    echo "   # mount | grep /var/log/audit"\nfi', '#!/bin/bash\n\n# Check for GPG keys configuration\n\ngpg_keys=$(gpg --list-keys)\n\nif [[ -z "$gpg_keys" ]]; then\n    echo "Check: Ensure GPG keys are configured"\n    echo "Status: Fail"\n    echo "Current Value: No GPG keys are configured."\n    echo "Expected Value: GPG keys should be configured for package signing."\n    echo "Remediation Steps:"\n    echo "1. Import the GPG key for the package repository (replace <KEY_URL> with actual key URL):"\n    echo "   # wget -qO - <KEY_URL> | sudo gpg --dearmor -o /usr/share/keyrings/<repo_name>-archive-keyring.gpg"\n    echo "2. Verify the keys have been added:"\n    echo "   # gpg --list-keys"\n    echo "3. For package manager (APT in this example), configure GPG key for secure packages:"\n    echo "   # echo \'deb [signed-by=/usr/share/keyrings/<repo_name>-archive-keyring.gpg] <repo_url> <distribution> <components>\' | sudo tee /etc/apt/sources.list.d/<repo_name>.list"\n    echo "4. Update the package list:"\n    echo "   # sudo apt update"\n    echo "5. Confirm secure repository usage."\nelse\n    echo "Check: Ensure GPG keys are configured"\n    echo "Status: Pass"\n    echo "Current Value: GPG keys are configured."\n    echo "Expected Value: GPG keys should be configured for package signing."\n    echo "Recommendation: No action needed."\nfi', '#!/bin/bash\n\n# Check if package manager repositories are configured (APT in this example)\nrepo_config="/etc/apt/sources.list"\n\nif [[ -f "$repo_config" ]]; then\n    echo "Check: Ensure package manager repositories are configured"\n    echo "Status: Pass"\n    echo "Current Value: Repositories are configured in $repo_config."\n    echo "Expected Value: Package manager repositories should be configured."\n    echo "Recommendation: No action needed."\nelse\n    echo "Check: Ensure package manager repositories are configured"\n    echo "Status: Fail"\n    echo "Current Value: Repositories are not configured."\n    echo "Expected Value: Package manager repositories should be configured."\n    echo "Remediation Steps:"\n    echo "1. Edit the repository configuration file ($repo_config) to include official repositories:"\n    echo "   # sudo nano /etc/apt/sources.list"\n    echo "   Example repositories for Ubuntu/Debian systems:"\n    echo "   deb http://archive.ubuntu.com/ubuntu/ focal main restricted"\n    echo "   deb-src http://archive.ubuntu.com/ubuntu/ focal main restricted"\n    echo "2. Save the file and update the package manager:"\n    echo "   # sudo apt update"\n    echo "3. Verify that the repositories are configured correctly:"\n    echo "   # cat /etc/apt/sources.list"\n    echo "4. Run a test to ensure the system is able to fetch updates:"\n    echo "   # sudo apt upgrade"\nfi', '#!/bin/bash\n\n# Check for available updates\navailable_updates=$(apt list --upgradable 2>/dev/null)\n\n# Check if security packages are installed (e.g., unattended-upgrades, clamav, fail2ban)\nsecurity_packages_installed=$(dpkg -l | grep -E \'unattended-upgrades|clamav|fail2ban\')\n\n# Check if there are available updates\nif [[ -n "$available_updates" ]]; then\n    updates_status="Updates are available"\nelse\n    updates_status="System is up-to-date"\nfi\n\n# Check if security packages are installed\nif [[ -n "$security_packages_installed" ]]; then\n    security_status="Security packages are installed"\nelse\n    security_status="Security packages are not installed"\nfi\n\n# Report overall status\nif [[ "$updates_status" == "System is up-to-date" && "$security_status" == "Security packages are installed" ]]; then\n    echo "Check: Ensure updates, patches, and additional security software are installed"\n    echo "Status: Pass"\n    echo "Current Value: System is up to date with updates and security packages installed."\n    echo "Expected Value: System should have the latest updates, patches, and security software installed."\n    echo "Recommendation: No action needed."\nelse\n    echo "Check: Ensure updates, patches, and additional security software are installed"\n    echo "Status: Fail"\n    echo "Current Value: $updates_status. $security_status."\n    echo "Expected Value: System should have the latest updates, patches, and security software installed."\n    echo "Remediation Steps:"\n    echo "1. Update the package list and install available updates:"\n    echo "   # sudo apt update"\n    echo "   # sudo apt upgrade"\n    echo "2. Install any available security patches:"\n    echo "   # sudo apt install unattended-upgrades"\n    echo "3. Ensure automatic updates are enabled for security patches:"\n    echo "   # sudo dpkg-reconfigure --priority=low unattended-upgrades"\n    echo "4. Verify that the latest patches and updates have been applied:"\n    echo "   # sudo apt list --upgradable"\n    echo "5. Check for installed security packages:"\n    echo "   # dpkg -l | grep security"\n    echo "6. If additional security tools are needed, install them:"\n    echo "   # sudo apt install clamav  # Example for ClamAV"\n    echo "   # sudo apt install fail2ban  # Example for Fail2Ban"\n    echo "7. For other package managers (e.g., yum, dnf), use the equivalent commands."\nfi', '#!/bin/bash\n\n# Check if AppArmor is installed\napp_armor_installed=$(dpkg -l | grep -E \'apparmor\')\n\nif [[ -z "$app_armor_installed" ]]; then\n    echo "Check: Ensure AppArmor is installed"\n    echo "Status: Fail"\n    echo "Current Value: AppArmor is not installed."\n    echo "Expected Value: AppArmor should be installed."\n    echo "Remediation Steps:"\n    echo "1. Install AppArmor:"\n    echo "   # sudo apt install apparmor"\n    echo "2. Verify that AppArmor is installed:"\n    echo "   # dpkg -l | grep apparmor"\nelse\n    echo "Check: Ensure AppArmor is installed"\n    echo "Status: Pass"\n    echo "Current Value: AppArmor is installed."\n    echo "Expected Value: AppArmor should be installed."\n    echo "Recommendation: No action needed."\nfi', '#!/bin/bash\n\n# Check if AppArmor is enabled in the bootloader configuration\nboot_loader_config="/etc/default/grub"\napparmor_enabled=$(grep -i "apparmor=1" $boot_loader_config)\n\nif [[ -z "$apparmor_enabled" ]]; then\n    echo "Check: Ensure AppArmor is enabled in the bootloader configuration"\n    echo "Status: Fail"\n    echo "Current Value: AppArmor is not enabled in the bootloader configuration."\n    echo "Expected Value: AppArmor should be enabled in the bootloader."\n    echo "Remediation Steps:"\n    echo "1. Edit the GRUB configuration file:"\n    echo "   # sudo nano /etc/default/grub"\n    echo "2. Ensure the line contains \'apparmor=1\' in the GRUB_CMDLINE_LINUX line:"\n    echo "   GRUB_CMDLINE_LINUX=\\"apparmor=1 security=apparmor\\""\n    echo "3. Update GRUB and reboot:"\n    echo "   # sudo update-grub"\n    echo "   # sudo reboot"\nelse\n    echo "Check: Ensure AppArmor is enabled in the bootloader configuration"\n    echo "Status: Pass"\n    echo "Current Value: AppArmor is enabled in the bootloader configuration."\n    echo "Expected Value: AppArmor should be enabled in the bootloader."\n    echo "Recommendation: No action needed."\nfi', '#!/bin/bash\n\n# Check if all AppArmor profiles are in enforce or complain mode\nprofiles=$(apparmor_status | grep -E \'enforce|complain\')\n\nif [[ -z "$profiles" ]]; then\n    echo "Check: Ensure all AppArmor profiles are in enforce or complain mode"\n    echo "Status: Fail"\n    echo "Current Value: No AppArmor profiles are in enforce or complain mode."\n    echo "Expected Value: All AppArmor profiles should be in enforce or complain mode."\n    echo "Remediation Steps:"\n    echo "1. Set the profile to complain or enforce mode:"\n    echo "   # sudo aa-enforce /path/to/profile"\n    echo "   # sudo aa-complain /path/to/profile"\n    echo "2. Verify the profile is in enforce or complain mode:"\n    echo "   # sudo apparmor_status"\nelse\n    echo "Check: Ensure all AppArmor profiles are in enforce or complain mode"\n    echo "Status: Pass"\n    echo "Current Value: All AppArmor profiles are in enforce or complain mode."\n    echo "Expected Value: All AppArmor profiles should be in enforce or complain mode."\n    echo "Recommendation: No action needed."\nfi', '#!/bin/bash\n\n# Check if all AppArmor profiles are enforcing\nenforcing_profiles=$(sudo apparmor_status | grep \'enforce\')\n\nif [[ -z "$enforcing_profiles" ]]; then\n    echo "Check: Ensure all AppArmor profiles are enforcing"\n    echo "Status: Fail"\n    echo "Current Value: No AppArmor profiles are enforcing."\n    echo "Expected Value: All AppArmor profiles should be in enforcing mode."\n    echo "Remediation Steps:"\n    echo "1. Set the profile to enforcing mode:"\n    echo "   # sudo aa-enforce /path/to/profile"\n    echo "2. Verify the profile is in enforcing mode:"\n    echo "   # sudo apparmor_status"\nelse\n    echo "Check: Ensure all AppArmor profiles are enforcing"\n    echo "Status: Pass"\n    echo "Current Value: All AppArmor profiles are enforcing."\n    echo "Expected Value: All AppArmor profiles should be enforcing."\n    echo "Recommendation: No action needed."\nfi', '#!/bin/bash\n\n# Check if the bootloader password is set (GRUB in this case)\ngrub_config="/etc/grub.d/40_custom"\n\n# Check for the presence of the password line in GRUB config\nbootloader_password_set=$(grep -i "set superusers" $grub_config)\n\nif [[ -z "$bootloader_password_set" ]]; then\n    echo "Check: Ensure bootloader password is set"\n    echo "Status: Fail"\n    echo "Current Value: Bootloader password is not set."\n    echo "Expected Value: Bootloader password should be set."\n    echo "Remediation Steps:"\n    echo "1. Set a GRUB password:"\n    echo "   # sudo grub-mkpasswd-pbkdf2"\n    echo "2. Copy the resulting hash into the GRUB configuration:"\n    echo "   # sudo nano /etc/grub.d/40_custom"\n    echo "   # set superusers=\\\\\\"root\\\\\\""\n    echo "   # password_pbkdf2 root <hash>"\n    echo "3. Update GRUB and reboot:"\n    echo "   # sudo update-grub"\n    echo "   # sudo reboot"\nelse\n    echo "Check: Ensure bootloader password is set"\n    echo "Status: Pass"\n    echo "Current Value: Bootloader password is set."\n    echo "Expected Value: Bootloader password should be set."\n    echo "Recommendation: No action needed."\nfi', '#!/bin/bash\n\n# GRUB configuration files\n\ngrub_config="/etc/default/grub"\n\ngrub_file="/boot/grub/grub.cfg"\n\n# Check if "GRUB_HIDDEN_TIMEOUT" is set (hides the GRUB menu)\n\ngrub_hidden_timeout=$(grep -i "GRUB_HIDDEN_TIMEOUT" $grub_config)\n\n# Check if "GRUB_DISABLE_RECOVERY" is set (disables recovery mode)\n\ngrub_disable_recovery=$(grep -i "GRUB_DISABLE_RECOVERY" $grub_config)\n\n# Check if GRUB config files have restricted permissions\n\nconfig_permissions=$(stat -c "%a %U %G" $grub_config)\n\nfile_permissions=$(stat -c "%a %U %G" $grub_file)\n\nrestricted_permissions="600 root root"\n\n# Verify configuration settings and permissions\n\nif [[ -z "$grub_hidden_timeout" || -z "$grub_disable_recovery" || "$config_permissions" != "$restricted_permissions" || "$file_permissions" != "$restricted_permissions" ]]; then\n\n    echo "Check: Ensure access to bootloader config is configured"\n\n    echo "Status: Fail"\n\n    echo "Current Value:"\n\n    [[ -z "$grub_hidden_timeout" ]] && echo "- GRUB_HIDDEN_TIMEOUT is not set."\n\n    [[ -z "$grub_disable_recovery" ]] && echo "- GRUB_DISABLE_RECOVERY is not set."\n\n    [[ "$config_permissions" != "$restricted_permissions" ]] && echo "- Incorrect permissions on $grub_config: $config_permissions."\n\n    [[ "$file_permissions" != "$restricted_permissions" ]] && echo "- Incorrect permissions on $grub_file: $file_permissions."\n\n    echo "Expected Value: Access to bootloader config should be restricted."\n\n    echo "Remediation Steps:"\n\n    echo "1. Edit the GRUB configuration file to disable recovery mode and hide the GRUB menu:"\n\n    echo "   # sudo nano /etc/default/grub"\n\n    echo "   # Set GRUB_HIDDEN_TIMEOUT=0"\n\n    echo "   # Set GRUB_DISABLE_RECOVERY=true"\n\n    echo "2. Update GRUB configuration:"\n\n    echo "   # sudo update-grub"\n\n    echo "3. Verify the GRUB configuration file is properly set up:"\n\n    echo "   # cat /boot/grub/grub.cfg"\n\nelse\n\n    echo "Check: Ensure access to bootloader config is configured"\n\n    echo "Status: Pass"\n\n    echo "Current Value: Access to bootloader config is restricted."\n\n    echo "Expected Value: Access to bootloader config should be restricted."\n\n    echo "Recommendation: No action needed."\n\nfi\n', '# Check if time synchronization is in use\ncheck_time_sync() {\n    if systemctl is-enabled chronyd >/dev/null 2>&1 || systemctl is-enabled ntpd >/dev/null 2>&1; then\n        echo "Check: Ensure time synchronization is in use"\n        echo "Status: Pass"\n        echo "Current Value: Time synchronization service is enabled."\n        echo "Expected Value: Time synchronization service should be enabled."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure time synchronization is in use"\n        echo "Status: Fail"\n        echo "Current Value: Time synchronization service is not enabled."\n        echo "Expected Value: Time synchronization service should be enabled."\n        echo "Recommendation: Enable time synchronization service to harden the system."\n        echo "Remediation:"\n        echo "# sudo systemctl enable chronyd  # For RedHat-based systems"\n        echo "# sudo systemctl start chronyd   # For RedHat-based systems"\n        echo "# sudo systemctl enable ntpd    # For Debian-based systems"\n        echo "# sudo systemctl start ntpd     # For Debian-based systems"\n    fi\n}\n\n# Execute the check\ncheck_time_sync\n', '#!/bin/bash\n\n# Check if Address Space Layout Randomization (ASLR) is enabled\n\naslr_status=$(cat /proc/sys/kernel/randomize)\n\nif [[ "$aslr_status" -eq 2 ]]; then\n\n    echo "Check: Ensure address space layout randomization is enabled"\n\n    echo "Status: Pass"\n\n    echo "Current Value: ASLR is enabled (Value: 2)."\n\n    echo "Expected Value: ASLR should be enabled."\n\n    echo "Recommendation: No action needed."\n\nelse\n\n    echo "Check: Ensure address space layout randomization is enabled"\n\n    echo "Status: Fail"\n\n    echo "Current Value: ASLR is not enabled."\n\n    echo "Expected Value: ASLR should be enabled."\n\n    echo "Remediation Steps:"\n\n    echo "1. Enable ASLR by running:"\n\n    echo "   # sudo sysctl -w kernel.randomize=2"\n\n    echo "2. To make the change permanent, add the following line to /etc/sysctl.conf:"\n\n    echo "   kernel.randomize=2"\n\n    echo "3. Reload sysctl settings:"\n\n    echo "   # sudo sysctl -p"\n\nfi\n', '#!/bin/bash\n\n# Check if ptrace_scope is restricted\n\nptrace_scope=$(cat /proc/sys/kernel/yama/ptrace_scope)\n\nif [[ "$ptrace_scope" -eq 1 ]]; then\n\n    echo "Check: Ensure ptrace_scope is restricted"\n\n    echo "Status: Pass"\n\n    echo "Current Value: ptrace_scope is restricted (Value: 1)."\n\n    echo "Expected Value: ptrace_scope should be restricted."\n\n    echo "Recommendation: No action needed."\n\nelse\n\n    echo "Check: Ensure ptrace_scope is restricted"\n\n    echo "Status: Fail"\n\n    echo "Current Value: ptrace_scope is not restricted."\n\n    echo "Expected Value: ptrace_scope should be restricted."\n\n    echo "Remediation Steps:"\n\n    echo "1. Restrict ptrace_scope by running:"\n\n    echo "   # sudo sysctl -w kernel.yama.ptrace_scope=1"\n\n    echo "2. To make the change permanent, add the following line to /etc/sysctl.conf:"\n\n    echo "   kernel.yama.ptrace_scope=1"\n\n    echo "3. Reload sysctl settings:"\n\n    echo "   # sudo sysctl -p"\n\nfi\n', '# Check if systemd-timesyncd is configured with an authorized timeserver\ncheck_timesyncd_authorized_timeserver() {\n    # Check if systemd-timesyncd is installed\n    if systemctl is-enabled systemd-timesyncd >/dev/null 2>&1; then\n        # Check if the timeservers are configured in /etc/systemd/timesyncd.conf\n        authorized_timeserver=$(grep -i \'NTP=\' /etc/systemd/timesyncd.conf)\n\n        if [[ -n "$authorized_timeserver" ]]; then\n            echo "Check: Ensure systemd-timesyncd configured with authorized timeserver"\n            echo "Status: Pass"\n            echo "Current Value: systemd-timesyncd is configured with an authorized timeserver."\n            echo "Expected Value: systemd-timesyncd should be configured with an authorized timeserver."\n            echo "Recommendation: No remediation required."\n        else\n            echo "Check: Ensure systemd-timesyncd configured with authorized timeserver"\n            echo "Status: Fail"\n            echo "Current Value: systemd-timesyncd is not configured with an authorized timeserver."\n            echo "Expected Value: systemd-timesyncd should be configured with an authorized timeserver."\n            echo "Recommendation: Configure an authorized NTP server."\n            echo "Remediation:"\n            echo "# sudo nano /etc/systemd/timesyncd.conf"\n            echo "Add the following line under [Time]:"\n            echo "NTP=your.authorized.timeserver"\n            echo "# sudo systemctl restart systemd-timesyncd"\n        fi\n    else\n        echo "Check: Ensure systemd-timesyncd configured with authorized timeserver"\n        echo "Status: Fail"\n        echo "Current Value: systemd-timesyncd is not installed or enabled."\n        echo "Expected Value: systemd-timesyncd should be installed and configured with an authorized timeserver."\n        echo "Recommendation: Install and configure systemd-timesyncd with an authorized timeserver."\n        echo "Remediation:"\n        echo "# sudo apt install systemd-timesyncd"  # For Debian-based systems"\n        echo "# sudo yum install systemd-timesyncd"  # For RedHat-based systems"\n    fi\n}\n\n# Execute the check\ncheck_timesyncd_authorized_timeserver\n', '#!/bin/bash\n\n# Check if core dumps are restricted\n\ncore_pattern=$(cat /proc/sys/kernel/core_pattern)\n\nif [[ "$core_pattern" == "|/bin/false" || "$core_pattern" == "none" ]]; then\n\n    echo "Check: Ensure core dumps are restricted"\n\n    echo "Status: Pass"\n\n    echo "Current Value: Core dumps are restricted."\n\n    echo "Expected Value: Core dumps should be restricted."\n\n    echo "Recommendation: No action needed."\n\nelse\n\n    echo "Check: Ensure core dumps are restricted"\n\n    echo "Status: Fail"\n\n    echo "Current Value: Core dumps are not restricted."\n\n    echo "Expected Value: Core dumps should be restricted."\n\n    echo "Remediation Steps:"\n\n    echo "1. Restrict core dumps by setting core_pattern to none or to a restricted path:"\n\n    echo "   # sudo sysctl -w kernel.core_pattern=none"\n\n    echo "2. To make the change permanent, add the following line to /etc/sysctl.conf:"\n\n    echo "   kernel.core_pattern=none"\n\n    echo "3. Reload sysctl settings:"\n\n    echo "   # sudo sysctl -p"\n\nfi\n', '# Check if systemd-timesyncd is enabled and running\ncheck_timesyncd_enabled_running() {\n    if systemctl is-enabled systemd-timesyncd >/dev/null 2>&1; then\n        # Check if the service is running\n        if systemctl is-active systemd-timesyncd >/dev/null 2>&1; then\n            echo "Check: Ensure systemd-timesyncd is enabled and running"\n            echo "Status: Pass"\n            echo "Current Value: systemd-timesyncd is enabled and running."\n            echo "Expected Value: systemd-timesyncd should be enabled and running."\n            echo "Recommendation: No remediation required."\n        else\n            echo "Check: Ensure systemd-timesyncd is enabled and running"\n            echo "Status: Fail"\n            echo "Current Value: systemd-timesyncd is enabled but not running."\n            echo "Expected Value: systemd-timesyncd should be enabled and running."\n            echo "Recommendation: Start and enable systemd-timesyncd."\n            echo "Remediation:"\n            echo "# sudo systemctl start systemd-timesyncd"\n            echo "# sudo systemctl enable systemd-timesyncd"\n        fi\n    else\n        echo "Check: Ensure systemd-timesyncd is enabled and running"\n        echo "Status: Fail"\n        echo "Current Value: systemd-timesyncd is not enabled."\n        echo "Expected Value: systemd-timesyncd should be enabled and running."\n        echo "Recommendation: Enable and start systemd-timesyncd."\n        echo "Remediation:"\n        echo "# sudo systemctl enable systemd-timesyncd"\n        echo "# sudo systemctl start systemd-timesyncd"\n    fi\n}\n\n# Execute the check\ncheck_timesyncd_enabled_running\n', '#!/bin/bash\n\n# Check if core dumps are restricted\n\ncore_pattern=$(cat /proc/sys/kernel/core_pattern)\n\nif [[ "$core_pattern" == "|/bin/false" || "$core_pattern" == "none" ]]; then\n\n    echo "Check: Ensure core dumps are restricted"\n\n    echo "Status: Pass"\n\n    echo "Current Value: Core dumps are restricted."\n\n    echo "Expected Value: Core dumps should be restricted."\n\n    echo "Recommendation: No action needed."\n\nelse\n\n    echo "Check: Ensure core dumps are restricted"\n\n    echo "Status: Fail"\n\n    echo "Current Value: Core dumps are not restricted."\n\n    echo "Expected Value: Core dumps should be restricted."\n\n    echo "Remediation Steps:"\n\n    echo "1. Restrict core dumps by setting core_pattern to none or to a restricted path:"\n\n    echo "   # sudo sysctl -w kernel.core_pattern=none"\n\n    echo "2. To make the change permanent, add the following line to /etc/sysctl.conf:"\n\n    echo "   kernel.core_pattern=none"\n\n    echo "3. Reload sysctl settings:"\n\n    echo "   # sudo sysctl -p"\n\nfi\n', '# Check if chrony is configured with an authorized timeserver\ncheck_chrony_authorized_timeserver() {\n    # Check if chrony is installed\n    if systemctl is-enabled chronyd >/dev/null 2>&1; then\n        # Check if the timeservers are configured in /etc/chrony.conf\n        authorized_timeserver=$(grep -i \'server \' /etc/chrony.conf)\n\n        if [[ -n "$authorized_timeserver" ]]; then\n            echo "Check: Ensure chrony is configured with an authorized timeserver"\n            echo "Status: Pass"\n            echo "Current Value: chrony is configured with an authorized timeserver."\n            echo "Expected Value: chrony should be configured with an authorized timeserver."\n            echo "Recommendation: No remediation required."\n        else\n            echo "Check: Ensure chrony is configured with an authorized timeserver"\n            echo "Status: Fail"\n            echo "Current Value: chrony is not configured with an authorized timeserver."\n            echo "Expected Value: chrony should be configured with an authorized timeserver."\n            echo "Recommendation: Configure an authorized NTP server."\n            echo "Remediation:"\n            echo "# sudo nano /etc/chrony.conf"\n            echo "Add the following line under the server section:"\n            echo "server your.authorized.timeserver iburst"\n            echo "# sudo systemctl restart chronyd"\n        fi\n    else\n        echo "Check: Ensure chrony is configured with an authorized timeserver"\n        echo "Status: Fail"\n        echo "Current Value: chrony is not installed or enabled."\n        echo "Expected Value: chrony should be installed and configured with an authorized timeserver."\n        echo "Recommendation: Install and configure chrony with an authorized timeserver."\n        echo "Remediation:"\n        echo "# sudo apt install chrony"  # For Debian-based systems\n        echo "# sudo yum install chrony"  # For RedHat-based systems\n    fi\n}\n\n# Execute the check\ncheck_chrony_authorized_timeserver\n', '# Check if chrony is running as user _chrony\ncheck_chrony_user() {\n    # Check if chronyd service is running\n    if systemctl is-active chronyd >/dev/null 2>&1; then\n        # Check the user running the chronyd service\n        chrony_user=$(ps -eo user,comm | grep \'[c]hronyd\' | awk \'{print $1}\')\n        \n        if [[ "$chrony_user" == "_chrony" ]]; then\n            echo "Check: Ensure chrony is running as user _chrony"\n            echo "Status: Pass"\n            echo "Current Value: chrony is running as user _chrony."\n            echo "Expected Value: chrony should run as user _chrony."\n            echo "Recommendation: No remediation required."\n        else\n            echo "Check: Ensure chrony is running as user _chrony"\n            echo "Status: Fail"\n            echo "Current Value: chrony is not running as user _chrony."\n            echo "Expected Value: chrony should run as user _chrony."\n            echo "Recommendation: Ensure that the chronyd service runs with the correct user."\n            echo "Remediation:"\n            echo "# sudo usermod -a -G _chrony chrony"\n            echo "# sudo systemctl restart chronyd"\n        fi\n    else\n        echo "Check: Ensure chrony is running as user _chrony"\n        echo "Status: Fail"\n        echo "Current Value: chrony service is not running."\n        echo "Expected Value: chrony should be running as user _chrony."\n        echo "Recommendation: Start the chronyd service."\n        echo "Remediation:"\n        echo "# sudo systemctl start chronyd"\n    fi\n}\n\n# Execute the check\ncheck_chrony_user\n', '# Check if chrony is enabled and running\ncheck_chrony_enabled_running() {\n    if systemctl is-enabled chronyd >/dev/null 2>&1; then\n        # Check if the service is running\n        if systemctl is-active chronyd >/dev/null 2>&1; then\n            echo "Check: Ensure chrony is enabled and running"\n            echo "Status: Pass"\n            echo "Current Value: chrony is enabled and running."\n            echo "Expected Value: chrony should be enabled and running."\n            echo "Recommendation: No remediation required."\n        else\n            echo "Check: Ensure chrony is enabled and running"\n            echo "Status: Fail"\n            echo "Current Value: chrony is enabled but not running."\n            echo "Expected Value: chrony should be enabled and running."\n            echo "Recommendation: Start and enable chrony."\n            echo "Remediation:"\n            echo "# sudo systemctl start chronyd"\n            echo "# sudo systemctl enable chronyd"\n        fi\n    else\n        echo "Check: Ensure chrony is enabled and running"\n        echo "Status: Fail"\n        echo "Current Value: chrony is not enabled."\n        echo "Expected Value: chrony should be enabled and running."\n        echo "Recommendation: Enable and start chrony."\n        echo "Remediation:"\n        echo "# sudo systemctl enable chronyd"\n        echo "# sudo systemctl start chronyd"\n    fi\n}\n\n# Execute the check\ncheck_chrony_enabled_running\n', '#!/bin/bash\n\n# Check if automatic error reporting is enabled (e.g., Apport on Ubuntu)\n\napport_status=$(systemctl is-active apport)\n\nif [[ "$apport_status" == "inactive" ]]; then\n\n    echo "Check: Ensure automatic error reporting is not enabled"\n\n    echo "Status: Pass"\n\n    echo "Current Value: Automatic error reporting is disabled."\n\n    echo "Expected Value: Automatic error reporting should be disabled."\n\n    echo "Recommendation: No action needed."\n\nelse\n\n    echo "Check: Ensure automatic error reporting is not enabled"\n\n    echo "Status: Fail"\n\n    echo "Current Value: Automatic error reporting is enabled."\n\n    echo "Expected Value: Automatic error reporting should be disabled."\n\n    echo "Remediation Steps:"\n\n    echo "1. Disable Apport error reporting (for Ubuntu/Debian systems):"\n\n    echo "   # sudo systemctl stop apport"\n\n    echo "   # sudo systemctl disable apport"\n\n    echo "2. Check that Apport is disabled:"\n\n    echo "   # systemctl is-active apport"\n\n    echo "3. For other distributions, verify the equivalent error reporting service and disable it."\n\nfi\n', '# Check if cron daemon is enabled and active\ncheck_cron_enabled_active() {\n    if systemctl is-enabled cron >/dev/null 2>&1; then\n        # Check if the service is running\n        if systemctl is-active cron >/dev/null 2>&1; then\n            echo "Check: Ensure cron daemon is enabled and active"\n            echo "Status: Pass"\n            echo "Current Value: cron daemon is enabled and running."\n            echo "Expected Value: cron daemon should be enabled and running."\n            echo "Recommendation: No remediation required."\n        else\n            echo "Check: Ensure cron daemon is enabled and active"\n            echo "Status: Fail"\n            echo "Current Value: cron daemon is enabled but not running."\n            echo "Expected Value: cron daemon should be enabled and running."\n            echo "Recommendation: Start and enable the cron daemon."\n            echo "Remediation:"\n            echo "# sudo systemctl start cron"\n            echo "# sudo systemctl enable cron"\n        fi\n    else\n        echo "Check: Ensure cron daemon is enabled and active"\n        echo "Status: Fail"\n        echo "Current Value: cron daemon is not enabled."\n        echo "Expected Value: cron daemon should be enabled and running."\n        echo "Recommendation: Enable and start the cron daemon."\n        echo "Remediation:"\n        echo "# sudo systemctl enable cron"\n        echo "# sudo systemctl start cron"\n    fi\n}\n\n# Execute the check\ncheck_cron_enabled_active\n', '#!/bin/bash\n\n# Check if /etc/motd exists and is configured\n\nmotd_status=$(cat /etc/motd)\n\nif [[ -n "$motd_status" ]]; then\n\n    echo "Check: Ensure message of the day is configured properly"\n\n    echo "Status: Pass"\n\n    echo "Current Value: /etc/motd is configured."\n\n    echo "Expected Value: /etc/motd should be configured with the organization\'s message."\n\n    echo "Recommendation: No action needed."\n\nelse\n\n    echo "Check: Ensure message of the day is configured properly"\n\n    echo "Status: Fail"\n\n    echo "Current Value: /etc/motd is not configured."\n\n    echo "Expected Value: /etc/motd should be configured with the organization\'s message."\n\n    echo "Remediation Steps:"\n\n    echo "1. Configure the message of the day by editing /etc/motd:"\n\n    echo "   # sudo nano /etc/motd"\n\n    echo "2. Add an appropriate message for users logging in."\n\nfi\n', '# Check if permissions on /etc/crontab are configured correctly\ncheck_crontab_permissions() {\n    crontab_permissions=$(stat -c "%a" /etc/crontab)\n    \n    if [[ "$crontab_permissions" == "644" ]]; then\n        echo "Check: Ensure permissions on /etc/crontab are configured"\n        echo "Status: Pass"\n        echo "Current Value: /etc/crontab has correct permissions (644)."\n        echo "Expected Value: /etc/crontab should have permissions 644."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure permissions on /etc/crontab are configured"\n        echo "Status: Fail"\n        echo "Current Value: /etc/crontab has incorrect permissions ($crontab_permissions)."\n        echo "Expected Value: /etc/crontab should have permissions 644."\n        echo "Recommendation: Fix the permissions."\n        echo "Remediation:"\n        echo "# sudo chmod 644 /etc/crontab"\n    fi\n}\n\n# Execute the check\ncheck_crontab_permissions\n', '# Check if permissions on /etc/cron.hourly are configured correctly\ncheck_cron_hourly_permissions() {\n    cron_hourly_permissions=$(stat -c "%a" /etc/cron.hourly)\n    \n    if [[ "$cron_hourly_permissions" == "755" ]]; then\n        echo "Check: Ensure permissions on /etc/cron.hourly are configured"\n        echo "Status: Pass"\n        echo "Current Value: /etc/cron.hourly has correct permissions (755)."\n        echo "Expected Value: /etc/cron.hourly should have permissions 755."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure permissions on /etc/cron.hourly are configured"\n        echo "Status: Fail"\n        echo "Current Value: /etc/cron.hourly has incorrect permissions ($cron_hourly_permissions)."\n        echo "Expected Value: /etc/cron.hourly should have permissions 755."\n        echo "Recommendation: Fix the permissions."\n        echo "Remediation:"\n        echo "# sudo chmod 755 /etc/cron.hourly"\n    fi\n}\n\n# Execute the check\ncheck_cron_hourly_permissions\n', '#!/bin/bash\n\n# Check if /etc/issue exists and is configured\n\nlocal_login_banner=$(cat /etc/issue)\n\nif [[ -n "$local_login_banner" ]]; then\n\n    echo "Check: Ensure local login warning banner is configured properly"\n\n    echo "Status: Pass"\n\n    echo "Current Value: /etc/issue is configured."\n\n    echo "Expected Value: /etc/issue should be configured with a local login warning banner."\n\n    echo "Recommendation: No action needed."\n\nelse\n\n    echo "Check: Ensure local login warning banner is configured properly"\n\n    echo "Status: Fail"\n\n    echo "Current Value: /etc/issue is not configured."\n\n    echo "Expected Value: /etc/issue should be configured with a local login warning banner."\n\n    echo "Remediation Steps:"\n\n    echo "1. Configure the local login warning banner by editing /etc/issue:"\n\n    echo "   # sudo nano /etc/issue"\n\n    echo "2. Add a local login banner with appropriate information, such as system use policies."\n\nfi\n', '# Check if permissions on /etc/cron.daily are configured correctly\ncheck_cron_daily_permissions() {\n    cron_daily_permissions=$(stat -c "%a" /etc/cron.daily)\n    \n    if [[ "$cron_daily_permissions" == "755" ]]; then\n        echo "Check: Ensure permissions on /etc/cron.daily are configured"\n        echo "Status: Pass"\n        echo "Current Value: /etc/cron.daily has correct permissions (755)."\n        echo "Expected Value: /etc/cron.daily should have permissions 755."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure permissions on /etc/cron.daily are configured"\n        echo "Status: Fail"\n        echo "Current Value: /etc/cron.daily has incorrect permissions ($cron_daily_permissions)."\n        echo "Expected Value: /etc/cron.daily should have permissions 755."\n        echo "Recommendation: Fix the permissions."\n        echo "Remediation:"\n        echo "# sudo chmod 755 /etc/cron.daily"\n    fi\n}\n\n# Execute the check\ncheck_cron_daily_permissions\n', '#!/bin/bash\n\n# Check if /etc/issue.net exists and is configured\n\nremote_login_banner=$(cat /etc/issue.net)\n\nif [[ -n "$remote_login_banner" ]]; then\n\n    echo "Check: Ensure remote login warning banner is configured properly"\n\n    echo "Status: Pass"\n\n    echo "Current Value: /etc/issue.net is configured."\n\n    echo "Expected Value: /etc/issue.net should be configured with a remote login warning banner."\n\n    echo "Recommendation: No action needed."\n\nelse\n\n    echo "Check: Ensure remote login warning banner is configured properly"\n\n    echo "Status: Fail"\n\n    echo "Current Value: /etc/issue.net is not configured."\n\n    echo "Expected Value: /etc/issue.net should be configured with a remote login warning banner."\n\n    echo "Remediation Steps:"\n\n    echo "1. Configure the remote login warning banner by editing /etc/issue.net:"\n\n    echo "   # sudo nano /etc/issue.net"\n\n    echo "2. Add a remote login banner with appropriate information, such as system access policies."\n\nfi\n', '# Check if permissions on /etc/cron.weekly are configured correctly\ncheck_cron_weekly_permissions() {\n    cron_weekly_permissions=$(stat -c "%a" /etc/cron.weekly)\n    \n    if [[ "$cron_weekly_permissions" == "755" ]]; then\n        echo "Check: Ensure permissions on /etc/cron.weekly are configured"\n        echo "Status: Pass"\n        echo "Current Value: /etc/cron.weekly has correct permissions (755)."\n        echo "Expected Value: /etc/cron.weekly should have permissions 755."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure permissions on /etc/cron.weekly are configured"\n        echo "Status: Fail"\n        echo "Current Value: /etc/cron.weekly has incorrect permissions ($cron_weekly_permissions)."\n        echo "Expected Value: /etc/cron.weekly should have permissions 755."\n        echo "Recommendation: Fix the permissions."\n        echo "Remediation:"\n        echo "# sudo chmod 755 /etc/cron.weekly"\n    fi\n}\n\n# Execute the check\ncheck_cron_weekly_permissions\n', '# Check if permissions on /etc/cron.monthly are configured correctly\ncheck_cron_monthly_permissions() {\n    cron_monthly_permissions=$(stat -c "%a" /etc/cron.monthly)\n    \n    if [[ "$cron_monthly_permissions" == "755" ]]; then\n        echo "Check: Ensure permissions on /etc/cron.monthly are configured"\n        echo "Status: Pass"\n        echo "Current Value: /etc/cron.monthly has correct permissions (755)."\n        echo "Expected Value: /etc/cron.monthly should have permissions 755."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure permissions on /etc/cron.monthly are configured"\n        echo "Status: Fail"\n        echo "Current Value: /etc/cron.monthly has incorrect permissions ($cron_monthly_permissions)."\n        echo "Expected Value: /etc/cron.monthly should have permissions 755."\n        echo "Recommendation: Fix the permissions."\n        echo "Remediation:"\n        echo "# sudo chmod 755 /etc/cron.monthly"\n    fi\n}\n\n# Execute the check\ncheck_cron_monthly_permissions\n', '#!/bin/bash\n\n# Check if /etc/motd has appropriate permissions\n\nmotd_permissions=$(stat -c "%a %n" /etc/motd)\n\nif [[ "$motd_permissions" == "644 /etc/motd" ]]; then\n\n    echo "Check: Ensure access to /etc/motd is configured"\n\n    echo "Status: Pass"\n\n    echo "Current Value: /etc/motd has correct permissions."\n\n    echo "Expected Value: /etc/motd should have permissions set to 644."\n\n    echo "Recommendation: No action needed."\n\nelse\n\n    echo "Check: Ensure access to /etc/motd is configured"\n\n    echo "Status: Fail"\n\n    echo "Current Value: /etc/motd has incorrect permissions."\n\n    echo "Expected Value: /etc/motd should have permissions set to 644."\n\n    echo "Remediation Steps:"\n\n    echo "1. Set the correct permissions for /etc/motd by running:"\n\n    echo "   # sudo chmod 644 /etc/motd"\n\n    echo "2. Verify the permissions are correct:"\n\n    echo "   # ls -l /etc/motd"\n\nfi\n', '# Check if permissions on /etc/cron.d are configured correctly\ncheck_cron_d_permissions() {\n    cron_d_permissions=$(stat -c "%a" /etc/cron.d)\n    \n    if [[ "$cron_d_permissions" == "755" ]]; then\n        echo "Check: Ensure permissions on /etc/cron.d are configured"\n        echo "Status: Pass"\n        echo "Current Value: /etc/cron.d has correct permissions (755)."\n        echo "Expected Value: /etc/cron.d should have permissions 755."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure permissions on /etc/cron.d are configured"\n        echo "Status: Fail"\n        echo "Current Value: /etc/cron.d has incorrect permissions ($cron_d_permissions)."\n        echo "Expected Value: /etc/cron.d should have permissions 755."\n        echo "Recommendation: Fix the permissions."\n        echo "Remediation:"\n        echo "# sudo chmod 755 /etc/cron.d"\n    fi\n}\n\n# Execute the check\ncheck_cron_d_permissions\n', '#!/bin/bash\n\n# Check if /etc/issue has appropriate permissions\n\nissue_permissions=$(stat -c "%a %n" /etc/issue)\n\nif [[ "$issue_permissions" == "644 /etc/issue" ]]; then\n\n    echo "Check: Ensure access to /etc/issue is configured"\n\n    echo "Status: Pass"\n\n    echo "Current Value: /etc/issue has correct permissions."\n\n    echo "Expected Value: /etc/issue should have permissions set to 644."\n\n    echo "Recommendation: No action needed."\n\nelse\n\n    echo "Check: Ensure access to /etc/issue is configured"\n\n    echo "Status: Fail"\n\n    echo "Current Value: /etc/issue has incorrect permissions."\n\n    echo "Expected Value: /etc/issue should have permissions set to 644."\n\n    echo "Remediation Steps:"\n\n    echo "1. Set the correct permissions for /etc/issue by running:"\n\n    echo "   # sudo chmod 644 /etc/issue"\n\n    echo "2. Verify the permissions are correct:"\n\n    echo "   # ls -l /etc/issue"\n\nfi\n', '# Check if crontab is restricted to authorized users\ncheck_crontab_restriction() {\n    crontab_restriction=$(grep -E \'^cron\' /etc/cron.allow)\n    \n    if [[ -n "$crontab_restriction" ]]; then\n        echo "Check: Ensure crontab is restricted to authorized users"\n        echo "Status: Pass"\n        echo "Current Value: Crontab access is restricted to authorized users."\n        echo "Expected Value: Only authorized users should have access to crontab."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure crontab is restricted to authorized users"\n        echo "Status: Fail"\n        echo "Current Value: Crontab access is not restricted."\n        echo "Expected Value: Crontab access should be restricted to authorized users."\n        echo "Recommendation: Restrict crontab access."\n        echo "Remediation:"\n        echo "# sudo touch /etc/cron.allow"\n        echo "# sudo echo \'username\' >> /etc/cron.allow"\n    fi\n}\n\n# Execute the check\ncheck_crontab_restriction\n', '#!/bin/bash\n\n# Check if /etc/issue.net has appropriate permissions\n\nissue_net_permissions=$(stat -c "%a %n" /etc/issue.net)\n\nif [[ "$issue_net_permissions" == "644 /etc/issue.net" ]]; then\n\n    echo "Check: Ensure access to /etc/issue.net is configured"\n\n    echo "Status: Pass"\n\n    echo "Current Value: /etc/issue.net has correct permissions."\n\n    echo "Expected Value: /etc/issue.net should have permissions set to 644."\n\n    echo "Recommendation: No action needed."\n\nelse\n\n    echo "Check: Ensure access to /etc/issue.net is configured"\n\n    echo "Status: Fail"\n\n    echo "Current Value: /etc/issue.net has incorrect permissions."\n\n    echo "Expected Value: /etc/issue.net should have permissions set to 644."\n\n    echo "Remediation Steps:"\n\n    echo "1. Set the correct permissions for /etc/issue.net by running:"\n\n    echo "   # sudo chmod 644 /etc/issue.net"\n\n    echo "2. Verify the permissions are correct:"\n\n    echo "   # ls -l /etc/issue.net"\n\nfi\n', '# Check if at is restricted to authorized users\ncheck_at_restriction() {\n    # Check if /etc/at.allow exists and has users listed\n    if [ -f /etc/at.allow ]; then\n        at_allow_users=$(cat /etc/at.allow)\n        if [[ -n "$at_allow_users" ]]; then\n            echo "Check: Ensure at is restricted to authorized users"\n            echo "Status: Pass"\n            echo "Current Value: /etc/at.allow contains authorized users."\n            echo "Expected Value: Only authorized users should have access to at."\n            echo "Recommendation: No remediation required."\n        else\n            echo "Check: Ensure at is restricted to authorized users"\n            echo "Status: Fail"\n            echo "Current Value: /etc/at.allow is empty."\n            echo "Expected Value: /etc/at.allow should contain authorized users."\n            echo "Recommendation: Add authorized users to /etc/at.allow."\n            echo "Remediation:"\n            echo "# sudo echo \'username\' > /etc/at.allow"\n        fi\n    # If /etc/at.allow does not exist, check /etc/at.deny for restrictions\n    elif [ -f /etc/at.deny ]; then\n        at_deny_users=$(cat /etc/at.deny)\n        if [[ -n "$at_deny_users" ]]; then\n            echo "Check: Ensure at is restricted to authorized users"\n            echo "Status: Pass"\n            echo "Current Value: /etc/at.deny contains users who are denied access to at."\n            echo "Expected Value: Only unauthorized users should be denied access to at."\n            echo "Recommendation: No remediation required."\n        else\n            echo "Check: Ensure at is restricted to authorized users"\n            echo "Status: Fail"\n            echo "Current Value: /etc/at.deny is empty."\n            echo "Expected Value: /etc/at.deny should contain users who are denied access to at."\n            echo "Recommendation: Add users to /etc/at.deny."\n            echo "Remediation:"\n            echo "# sudo echo \'username\' > /etc/at.deny"\n        fi\n    else\n        echo "Check: Ensure at is restricted to authorized users"\n        echo "Status: Fail"\n        echo "Current Value: Neither /etc/at.allow nor /etc/at.deny exists."\n        echo "Expected Value: /etc/at.allow or /etc/at.deny should exist to restrict access."\n        echo "Recommendation: Create and configure /etc/at.allow or /etc/at.deny."\n        echo "Remediation:"\n        echo "# sudo touch /etc/at.allow"\n        echo "# sudo echo \'username\' > /etc/at.allow"\n    fi\n}\n\n# Execute the check\ncheck_at_restriction\n', '#!/bin/bash\n\n# Check if GDM (GNOME Display Manager) is installed\ngdm_status=$(dpkg -l | grep -i gdm)\n\nif [[ -z "$gdm_status" ]]; then\n\n    echo "Check: Ensure GDM is removed"\n\n    echo "Status: Pass"\n\n    echo "Current Value: GDM is not installed."\n\n    echo "Expected Value: GDM should not be installed."\n\n    echo "Recommendation: No action needed."\n\nelse\n\n    echo "Check: Ensure GDM is removed"\n\n    echo "Status: Fail"\n\n    echo "Current Value: GDM is installed."\n\n    echo "Expected Value: GDM should not be installed."\n\n    echo "Remediation Steps:"\n\n    echo "1. Remove GDM by running:"\n\n    echo "   # sudo apt-get remove --purge gdm3"\n\n    echo "2. Optionally, disable GDM at startup:"\n\n    echo "   # sudo systemctl disable gdm3"\n\nfi\n', '#!/bin/bash\n\n# Check if the GDM login banner is configured\ngdm_banner_status=$(cat /etc/gdm3/greeter.dconf-defaults | grep -i banner-message)\n\nif [[ -n "$gdm_banner_status" ]]; then\n\n    echo "Check: Ensure GDM login banner is configured"\n\n    echo "Status: Pass"\n\n    echo "Current Value: GDM login banner is configured."\n\n    echo "Expected Value: GDM login banner should be configured."\n\n    echo "Recommendation: No action needed."\n\nelse\n\n    echo "Check: Ensure GDM login banner is configured"\n\n    echo "Status: Fail"\n\n    echo "Current Value: GDM login banner is not configured."\n\n    echo "Expected Value: GDM login banner should be configured."\n\n    echo "Remediation Steps:"\n\n    echo "1. Edit the GDM configuration to set a login banner:"\n\n    echo "   # sudo nano /etc/gdm3/greeter.dconf-defaults"\n\n    echo "2. Add the following line to configure the login banner:"\n\n    echo "   banner-message-enable=true"\n\n    echo "   banner-message-text=\'This system is for authorized users only.\'"\n\n    echo "3. Save the file and restart GDM:"\n\n    echo "   # sudo systemctl restart gdm3"\n\nfi\n', '#!/bin/bash\n\n# Check if the \'disable-user-list\' option is enabled in GDM\ngdm_disable_user_list=$(gsettings get org.gnome.login-screen disable-user-list)\n\nif [[ "$gdm_disable_user_list" == "true" ]]; then\n\n    echo "Check: Ensure GDM disable-user-list option is enabled"\n\n    echo "Status: Pass"\n\n    echo "Current Value: \'disable-user-list\' is enabled."\n\n    echo "Expected Value: \'disable-user-list\' should be enabled."\n\n    echo "Recommendation: No action needed."\n\nelse\n\n    echo "Check: Ensure GDM disable-user-list option is enabled"\n\n    echo "Status: Fail"\n\n    echo "Current Value: \'disable-user-list\' is not enabled."\n\n    echo "Expected Value: \'disable-user-list\' should be enabled."\n\n    echo "Remediation Steps:"\n\n    echo "1. Enable the \'disable-user-list\' option by running:"\n\n    echo "   # sudo gsettings set org.gnome.login-screen disable-user-list true"\n\nfi\n', '#!/bin/bash\n\n# Check if GDM screen lock is enabled after idle time\ngdm_screen_lock=$(gsettings get org.gnome.desktop.screensaver lock-enabled)\n\nif [[ "$gdm_screen_lock" == "true" ]]; then\n    echo "Check: Ensure GDM screen locks when the user is idle"\n    echo "Status: Pass"\n    echo "Current Value: Screen lock is enabled after idle time."\n    echo "Expected Value: Screen lock should be enabled after idle time."\n    echo "Recommendation: No action needed."\nelse\n    echo "Check: Ensure GDM screen locks when the user is idle"\n    echo "Status: Fail"\n    echo "Current Value: Screen lock is not enabled after idle time."\n    echo "Expected Value: Screen lock should be enabled after idle time."\n    echo "Remediation Steps:"\n    echo "1. Enable the screen lock by running:"\n    echo "   # sudo gsettings set org.gnome.desktop.screensaver lock-enabled true"\n    echo "2. Optionally, set the idle time before locking (in seconds):"\n    echo "   # sudo gsettings set org.gnome.desktop.screensaver lock-delay 0"\nfi', '#!/bin/bash\n\n# Check if the option to prevent overriding screen lock is enabled\ngdm_lock_override=$(gsettings get org.gnome.desktop.screensaver lock-interactive)\n\nif [[ "$gdm_lock_override" == "false" ]]; then\n    echo "Check: Ensure GDM screen locks cannot be overridden"\n    echo "Status: Pass"\n    echo "Current Value: Screen lock cannot be overridden."\n    echo "Expected Value: Screen lock should not be overridden."\n    echo "Recommendation: No action needed."\nelse\n    echo "Check: Ensure GDM screen locks cannot be overridden"\n    echo "Status: Fail"\n    echo "Current Value: Screen lock can be overridden."\n    echo "Expected Value: Screen lock should not be overridden."\n    echo "Remediation Steps:"\n    echo "1. Prevent screen lock override by running:"\n    echo "   # sudo gsettings set org.gnome.desktop.screensaver lock-interactive false"\nfi', '#!/bin/bash\n\n# Check if GDM automatic mounting of removable media is disabled\ngdm_auto_mount=$(gsettings get org.gnome.desktop.media-handling automount)\n\nif [[ "$gdm_auto_mount" == "false" ]]; then\n    echo "Check: Ensure GDM automatic mounting of removable media is disabled"\n    echo "Status: Pass"\n    echo "Current Value: Automatic mounting of removable media is disabled."\n    echo "Expected Value: Automatic mounting of removable media should be disabled."\n    echo "Recommendation: No action needed."\nelse\n    echo "Check: Ensure GDM automatic mounting of removable media is disabled"\n    echo "Status: Fail"\n    echo "Current Value: Automatic mounting of removable media is enabled."\n    echo "Expected Value: Automatic mounting of removable media should be disabled."\n    echo "Remediation Steps:"\n    echo "1. Disable automatic mounting of removable media by running:"\n    echo "   # sudo gsettings set org.gnome.desktop.media-handling automount false"\nfi', '#!/bin/bash\n\n# Check if the GDM auto-mount setting is not overridden\ngdm_auto_mount_override=$(gsettings get org.gnome.desktop.media-handling automount-open)\n\nif [[ "$gdm_auto_mount_override" == "false" ]]; then\n    echo "Check: Ensure GDM disabling automatic mounting of removable media is not overridden"\n    echo "Status: Pass"\n    echo "Current Value: Auto-mounting of removable media is not overridden."\n    echo "Expected Value: Auto-mounting of removable media should not be overridden."\n    echo "Recommendation: No action needed."\nelse\n    echo "Check: Ensure GDM disabling automatic mounting of removable media is not overridden"\n    echo "Status: Fail"\n    echo "Current Value: Auto-mounting of removable media is overridden."\n    echo "Expected Value: Auto-mounting of removable media should not be overridden."\n    echo "Remediation Steps:"\n    echo "1. Ensure automatic mounting of removable media is disabled by running:"\n    echo "   # sudo gsettings set org.gnome.desktop.media-handling automount-open false"\nfi', '#!/bin/bash\n\n# Check if autorun-never is enabled in GDM\ngdm_autorun_never=$(gsettings get org.gnome.desktop.media-handling autorun-never)\n\nif [[ "$gdm_autorun_never" == "true" ]]; then\n    echo "Check: Ensure GDM autorun-never is enabled"\n    echo "Status: Pass"\n    echo "Current Value: Autorun-never is enabled."\n    echo "Expected Value: Autorun-never should be enabled."\n    echo "Recommendation: No action needed."\nelse\n    echo "Check: Ensure GDM autorun-never is enabled"\n    echo "Status: Fail"\n    echo "Current Value: Autorun-never is not enabled."\n    echo "Expected Value: Autorun-never should be enabled."\n    echo "Remediation Steps:"\n    echo "1. Enable autorun-never by running:"\n    echo "   # sudo gsettings set org.gnome.desktop.media-handling autorun-never true"\nfi', '#!/bin/bash\n\n# Check if autorun-never is not overridden in GDM\ngdm_autorun_never_override=$(gsettings get org.gnome.desktop.media-handling autorun-never)\n\nif [[ "$gdm_autorun_never_override" == "true" ]]; then\n    echo "Check: Ensure GDM autorun-never is not overridden"\n    echo "Status: Pass"\n    echo "Current Value: Autorun-never is not overridden."\n    echo "Expected Value: Autorun-never should not be overridden."\n    echo "Recommendation: No action needed."\nelse\n    echo "Check: Ensure GDM autorun-never is not overridden"\n    echo "Status: Fail"\n    echo "Current Value: Autorun-never is overridden."\n    echo "Expected Value: Autorun-never should not be overridden."\n    echo "Remediation Steps:"\n    echo "1. Ensure autorun-never is enabled by running:"\n    echo "   # sudo gsettings set org.gnome.desktop.media-handling autorun-never true"\nfi', '#!/bin/bash\n\n# Check if XDMCP (X Display Manager Control Protocol) is enabled\nxdmcp_status=$(cat /etc/gdm3/custom.conf | grep -i "Enable=true")\n\nif [[ -z "$xdmcp_status" ]]; then\n    echo "Check: Ensure XDMCP is not enabled"\n    echo "Status: Pass"\n    echo "Current Value: XDMCP is not enabled."\n    echo "Expected Value: XDMCP should not be enabled."\n    echo "Recommendation: No action needed."\nelse\n    echo "Check: Ensure XDMCP is not enabled"\n    echo "Status: Fail"\n    echo "Current Value: XDMCP is enabled."\n    echo "Expected Value: XDMCP should not be enabled."\n    echo "Remediation Steps:"\n    echo "1. Disable XDMCP by editing /etc/gdm3/custom.conf:"\n    echo "   # sudo nano /etc/gdm3/custom.conf"\n    echo "2. Ensure the line \'Enable=false\' is present in the file."\n    echo "3. Restart GDM after making changes:"\n    echo "   # sudo systemctl restart gdm3"\nfi', '#!/bin/bash \n\n# Check if nftables package is installed using rpm or dpkg\nif command -v rpm &>/dev/null; then\n    nftables_check=$(rpm -q nftables)\nelif command -v dpkg &>/dev/null; then\n    nftables_check=$(dpkg -l | grep -i nftables)\nelse\n    echo "Package manager not found, cannot check nftables installation."\n    exit 1\nfi\n\nif [[ -n "$nftables_check" ]]; then\n    echo "Check: Ensure nftables is not installed with iptables"\n    echo "Status: Fail"\n    echo "Current Value: nftables package is installed"\n    echo "Recommendation: nftables should not be installed alongside iptables. Remove nftables to use iptables exclusively for firewall services."\n    echo "Remediation Steps:"\n    echo "1. Remove nftables package: sudo yum remove nftables (for RPM-based systems) or sudo apt-get remove nftables (for Debian-based systems)"\nelse\n    echo "Check: Ensure nftables is not installed with iptables"\n    echo "Status: Pass"\n    echo "Current Value: nftables package is not installed"\n    echo "Recommendation: No action needed."\nfi', '#!/bin/bash \n\n# Check if ufw package is installed using rpm or dpkg\nif command -v rpm &>/dev/null; then\n    ufw_check=$(rpm -q ufw)\nelif command -v dpkg &>/dev/null; then\n    ufw_check=$(dpkg -l | grep -i ufw)\nelse\n    echo "Package manager not found, cannot check ufw installation."\n    exit 1\nfi\n\nif [[ -n "$ufw_check" ]]; then\n    echo "Check: Ensure ufw is uninstalled or disabled with iptables"\n    echo "Status: Fail"\n    echo "Current Value: ufw package is installed"\n    echo "Recommendation: You should disable or remove the ufw package to ensure iptables is used for firewall management."\n    echo "Remediation Steps:"\n    echo "1. Uninstall ufw: sudo yum remove ufw (for RPM-based systems) or sudo apt-get remove ufw (for Debian-based systems)"\nelse\n    echo "Check: Ensure ufw is uninstalled or disabled with iptables"\n    echo "Status: Pass"\n    echo "Current Value: ufw package is not installed"\n    echo "Recommendation: No action needed."\nfi', '#!/bin/bash\n\n# Function to check if iptables default policy is set to DENY\ncheck_iptables_default_policy() {\n    # Check if iptables is installed\n    if ! command -v iptables &> /dev/null; then\n        echo "Check: Ensure iptables default deny firewall policy"\n        echo "Status: Fail"\n        echo "Current Value: iptables command not found."\n        echo "Expected Value: iptables should be installed."\n        echo "Recommendation: Install iptables using the following command:"\n        echo "# sudo apt-get install iptables"\n        echo "Remediation:"\n        echo "# To install iptables, use the command: sudo apt-get install iptables"\n        return\n    fi\n\n    # Check for the default policy of the INPUT, FORWARD, and OUTPUT chains\n    input_policy=$(sudo iptables -L INPUT -n | grep "Chain INPUT" | awk "{print $4}")\n    forward_policy=$(sudo iptables -L FORWARD -n | grep "Chain FORWARD" | awk "{print $4}")\n    output_policy=$(sudo iptables -L OUTPUT -n | grep "Chain OUTPUT" | awk "{print $4}")\n\n    # Check if all policies are set to DROP or REJECT (denying traffic)\n    if [[ "$input_policy" == "DROP" || "$input_policy" == "REJECT" ]] &&\n       [[ "$forward_policy" == "DROP" || "$forward_policy" == "REJECT" ]] &&\n       [[ "$output_policy" == "DROP" || "$output_policy" == "REJECT" ]]; then\n        echo "Check: Ensure iptables default deny firewall policy"\n        echo "Status: Pass"\n        echo "Current Value: Default policy is set to DENY (DROP/REJECT) for all chains."\n        echo "Expected Value: Default policy should be DENY (DROP/REJECT) for INPUT, FORWARD, and OUTPUT chains."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure iptables default deny firewall policy"\n        echo "Status: Fail"\n        echo "Current Value: Default policy is not set to DENY (DROP/REJECT) for all chains."\n        echo "Expected Value: Default policy should be DENY (DROP/REJECT) for INPUT, FORWARD, and OUTPUT chains."\n        echo "Recommendation: Set the default policy to DROP or REJECT for all chains."\n        echo "Remediation:"\n        echo "# To set the default policy to DROP, use the following commands:"\n        echo "# sudo iptables -P INPUT DROP"\n        echo "# sudo iptables -P FORWARD DROP"\n        echo "# sudo iptables -P OUTPUT DROP"\n        echo "# To set the default policy to REJECT, use the following commands:"\n        echo "# sudo iptables -P INPUT REJECT"\n        echo "# sudo iptables -P FORWARD REJECT"\n        echo "# sudo iptables -P OUTPUT REJECT"\n    fi\n}\n\n# Execute the check\ncheck_iptables_default_policy', '#!/bin/bash \n\n# Check if iptables loopback traffic is allowed\nloopback_check=$(sudo iptables -L INPUT -n | grep -i "lo")\n\nif [[ -n "$loopback_check" ]]; then\n    echo "Check: Ensure iptables loopback traffic is configured"\n    echo "Status: Pass"\n    echo "Current Value: Loopback traffic is allowed"\n    echo "Recommendation: No action needed."\nelse\n    echo "Check: Ensure iptables loopback traffic is configured"\n    echo "Status: Fail"\n    echo "Current Value: Loopback traffic is not allowed"\n    echo "Recommendation: Allow loopback traffic to ensure proper system functioning."\n    echo "Remediation Steps:"\n    echo "1. Allow loopback traffic: sudo iptables -A INPUT -i lo -j ACCEPT"\n    echo "2. Allow loopback traffic for OUTPUT chain: sudo iptables -A OUTPUT -o lo -j ACCEPT"\nfi', '#!/bin/bash \n\n# Check if outbound and established connections are configured\noutbound_check=$(sudo iptables -L OUTPUT -n | grep -i "ACCEPT")\nestablished_check=$(sudo iptables -L INPUT -n | grep -i "ESTABLISHED")\n\nif [[ -n "$outbound_check" && -n "$established_check" ]]; then\n    echo "Check: Ensure iptables outbound and established connections are configured"\n    echo "Status: Pass"\n    echo "Current Value: Outbound and established connections are configured"\n    echo "Recommendation: No action needed."\nelse\n    echo "Check: Ensure iptables outbound and established connections are configured"\n    echo "Status: Fail"\n    echo "Current Value: Outbound or established connections are not configured"\n    echo "Recommendation: Configure outbound and established connections to ensure normal traffic flow."\n    echo "Remediation Steps:"\n    echo "1. Allow outbound connections: sudo iptables -A OUTPUT -j ACCEPT"\n    echo "2. Allow established connections: sudo iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT"\nfi', '#!/bin/bash\n\n# Check for open ports and ensure rules are configured for them\nopen_ports_check=$(ss -tuln | grep -Eo \':[0-9]{1,5}\' | awk -F: \'{print $2}\')\n\nif [[ -z "$open_ports_check" ]]; then\n    echo "Check: Ensure iptables firewall rules exist for all open ports"\n    echo "Status: Fail"\n    echo "Current Value: No open ports found"\n    echo "Recommendation: Ensure that iptables rules are configured for all open ports."\n    echo "Remediation Steps:"\n    echo "1. Identify open ports using: ss -tuln"\n    echo "2. Add iptables rules for each open port, e.g., sudo iptables -A INPUT -p tcp --dport 80 -j ACCEPT"\nelse\n    echo "Check: Ensure iptables firewall rules exist for all open ports"\n    echo "Status: Pass"\n    echo "Current Value: iptables rules exist for open ports"\n    echo "Recommendation: No action needed."\nfi', '#!/bin/bash\n\n# Check if ip6tables default policy is set to DENY\ndefault_policy=$(sudo ip6tables -L INPUT -n | grep "default" | grep -i drop)\n\nif [[ -n "$default_policy" ]]; then\n    echo "Check: Ensure ip6tables default deny firewall policy"\n    echo "Status: Pass"\n    echo "Current Value: Default policy is set to DENY"\n    echo "Recommendation: No action needed."\nelse\n    echo "Check: Ensure ip6tables default deny firewall policy"\n    echo "Status: Fail"\n    echo "Current Value: Default policy is not set to DENY"\n    echo "Recommendation: Set the default policy to DENY for increased security."\n    echo "Remediation Steps:"\n    echo "1. Set default deny policy: sudo ip6tables -P INPUT DROP"\n    echo "2. Set default deny policy for OUTPUT and FORWARD chains as needed: sudo ip6tables -P OUTPUT DROP && sudo ip6tables -P FORWARD DROP"\nfi', '#!/bin/bash\n\n# Check if ip6tables loopback traffic is allowed\nloopback_check=$(sudo ip6tables -L INPUT -n | grep -i "lo")\n\nif [[ -n "$loopback_check" ]]; then\n    echo "Check: Ensure ip6tables loopback traffic is configured"\n    echo "Status: Pass"\n    echo "Current Value: Loopback traffic is allowed"\n    echo "Recommendation: No action needed."\nelse\n    echo "Check: Ensure ip6tables loopback traffic is configured"\n    echo "Status: Fail"\n    echo "Current Value: Loopback traffic is not allowed"\n    echo "Recommendation: Allow loopback traffic to ensure proper system functioning."\n    echo "Remediation Steps:"\n    echo "1. Allow loopback traffic: sudo ip6tables -A INPUT -i lo -j ACCEPT"\n    echo "2. Allow loopback traffic for OUTPUT chain: sudo ip6tables -A OUTPUT -o lo -j ACCEPT"\nfi', '#!/bin/bash\n\n# Check if outbound and established connections are configured\noutbound_check=$(sudo ip6tables -L OUTPUT -n | grep -i "ACCEPT")\nestablished_check=$(sudo ip6tables -L INPUT -n | grep -i "ESTABLISHED")\n\nif [[ -n "$outbound_check" && -n "$established_check" ]]; then\n    echo "Check: Ensure ip6tables outbound and established connections are configured"\n    echo "Status: Pass"\n    echo "Current Value: Outbound and established connections are configured"\n    echo "Recommendation: No action needed."\nelse\n    echo "Check: Ensure ip6tables outbound and established connections are configured"\n    echo "Status: Fail"\n    echo "Current Value: Outbound or established connections are not configured"\n    echo "Recommendation: Configure outbound and established connections to ensure normal traffic flow."\n    echo "Remediation Steps:"\n    echo "1. Allow outbound connections: sudo ip6tables -A OUTPUT -j ACCEPT"\n    echo "2. Allow established connections: sudo ip6tables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT"\nfi', '#!/bin/bash\n\n# Check for open ports and ensure rules are configured for them\nopen_ports_check=$(ss -tuln6 | grep -Eo \':(0-9]{1,5})\' | awk -F: \'{print $2}\')\n\nif [[ -z "$open_ports_check" ]]; then\n    echo "Check: Ensure ip6tables firewall rules exist for all open ports"\n    echo "Status: Fail"\n    echo "Current Value: No open ports found"\n    echo "Recommendation: Ensure that ip6tables rules are configured for all open ports."\n    echo "Remediation Steps:"\n    echo "1. Identify open ports using: ss -tuln6"\n    echo "2. Add ip6tables rules for each open port, e.g., sudo ip6tables -A INPUT -p tcp --dport 80 -j ACCEPT"\nelse\n    echo "Check: Ensure ip6tables firewall rules exist for all open ports"\n    echo "Status: Pass"\n    echo "Current Value: ip6tables rules exist for open ports"\n    echo "Recommendation: No action needed."\nfi', '# Check the permissions on /etc/ssh/sshd_config\ncheck_sshd_config_permissions() {\n    sshd_config="/etc/ssh/sshd_config"\n    if [ -f "$sshd_config" ]; then\n        current_permissions=$(stat -c "%a" "$sshd_config")\n        if [ "$current_permissions" != "600" ]; then\n            echo "Check: Ensure permissions on /etc/ssh/sshd_config are configured"\n            echo "Status: Fail"\n            echo "Current Value: Permissions are $current_permissions"\n            echo "Expected Value: Permissions should be 600"\n            echo "Recommendation: Set permissions to 600"\n            echo "Remediation:"\n            echo "# sudo chmod 600 /etc/ssh/sshd_config"\n        else\n            echo "Check: Ensure permissions on /etc/ssh/sshd_config are configured"\n            echo "Status: Pass"\n            echo "Current Value: Permissions are $current_permissions"\n            echo "Expected Value: Permissions should be 600"\n            echo "Recommendation: No remediation required."\n        fi\n    else\n        echo "Check: Ensure permissions on /etc/ssh/sshd_config are configured"\n        echo "Status: Fail"\n        echo "Current Value: /etc/ssh/sshd_config file does not exist"\n        echo "Expected Value: /etc/ssh/sshd_config should exist"\n        echo "Recommendation: Ensure the file exists and has correct permissions."\n    fi\n}\n\n# Execute the check\ncheck_sshd_config_permissions\n', 'check_sudo_installed() {\n    if command -v sudo >/dev/null 2>&1; then\n        echo Check: Ensure sudo is installed\n        echo Status: Pass\n        echo Current Value: sudo is installed\n        echo Recommendation: No remediation required.\n    else\n        echo Check: Ensure sudo is installed\n        echo Status: Fail\n        echo Current Value: sudo is not installed\n        echo Recommendation: Install sudo\n        echo Remediation:\n        echo # sudo apt update\n        echo # sudo apt install sudo\n    fi\n}\n\n# Execute the check\ncheck_sudo_installed\n', 'check_sudo_use_pty() {\n    sudo_config="/etc/sudoers"\n    pty_check=$(grep -E "Defaults\\s+use_pty" "$sudo_config")\n    \n    if [ -z "$pty_check" ]; then\n        echo Check: Ensure sudo commands use pty\n        echo Status: Fail\n        echo Current Value: use_pty is not configured\n        echo Recommendation: Configure sudo to use pty\n        echo Remediation:\n        echo # sudo nano /etc/sudoers\n        echo # Defaults    use_pty\n    else\n        echo Check: Ensure sudo commands use pty\n        echo Status: Pass\n        echo Current Value: $pty_check\n        echo Recommendation: No remediation required.\n    fi\n}\n\n# Execute the check\ncheck_sudo_use_pty\n', 'check_sudo_log_file() {\n    sudo_config="/etc/sudoers"\n    log_file_check=$(grep -E "Defaults\\s+logfile" "$sudo_config")\n    \n    if [ -z "$log_file_check" ]; then\n        echo Check: Ensure sudo log file exists\n        echo Status: Fail\n        echo Current Value: logfile is not configured\n        echo Recommendation: Configure sudo log file\n        echo Remediation:\n        echo # sudo nano /etc/sudoers\n        echo # Defaults    logfile=/var/log/sudo.log\n    else\n        echo Check: Ensure sudo log file exists\n        echo Status: Pass\n        echo Current Value: $log_file_check\n        echo Recommendation: No remediation required.\n    fi\n}\n\n# Execute the check\ncheck_sudo_log_file\n', 'check_sudo_password_required() {\n    sudo_config="/etc/sudoers"\n    password_required=$(grep -E "^\\s*Defaults\\s+authenticate" "$sudo_config")\n    \n    if [ -z "$password_required" ]; then\n        echo Check: Ensure users must provide password for privilege escalation\n        echo Status: Fail\n        echo Current Value: Password authentication is not required\n        echo Recommendation: Ensure users must provide a password\n        echo Remediation:\n        echo # sudo nano /etc/sudoers\n        echo # Defaults    authenticate\n    else\n        echo Check: Ensure users must provide password for privilege escalation\n        echo Status: Pass\n        echo Current Value: $password_required\n        echo Recommendation: No remediation required.\n    fi\n}\n\n# Execute the check\ncheck_sudo_password_required\n', 'check_sudo_reauthentication() {\n    sudo_config="/etc/sudoers"\n    reauth_check=$(grep -E "^s*Defaultss+timestamp_timeout=0" "$sudo_config")\n    \n    if [ -n "$reauth_check" ]; then\n        echo "Check: Ensure re-authentication for privilege escalation is not disabled globally"\n        echo "Status: Fail"\n        echo "Current Value: timestamp_timeout is configured to 0 (disabling re-authentication)"\n        echo "Recommendation: Ensure re-authentication is enabled"\n        echo "Remediation:"\n        echo "# sudo nano /etc/sudoers"\n        echo "# Defaults    timestamp_timeout=-1"\n    else\n        echo "Check: Ensure re-authentication for privilege escalation is not disabled globally"\n        echo "Status: Pass"\n        echo "Recommendation: No remediation required."\n    fi\n}\n\n# Execute the check\ncheck_sudo_reauthentication\n', 'check_sudo_auth_timeout() {\n    sudo_config="/etc/sudoers"\n    auth_timeout=$(grep -E "^\\s*Defaults\\s+timestamp_timeout" "$sudo_config")\n    \n    if [ -z "$auth_timeout" ]; then\n        echo Check: Ensure sudo authentication timeout is configured correctly\n        echo Status: Fail\n        echo Current Value: timestamp_timeout is not configured\n        echo Recommendation: Configure sudo authentication timeout\n        echo Remediation:\n        echo # sudo nano /etc/sudoers\n        echo # Defaults    timestamp_timeout=15\n    else\n        echo Check: Ensure sudo authentication timeout is configured correctly\n        echo Status: Pass\n        echo Current Value: $auth_timeout\n        echo Recommendation: No remediation required.\n    fi\n}\n\n# Execute the check\ncheck_sudo_auth_timeout\n', 'check_su_access() {\n    su_access_check=$(grep -E "^wheel" /etc/group)\n    \n    if [ -z "$su_access_check" ]; then\n        echo Check: Ensure access to the su command is restricted\n        echo Status: Fail\n        echo Current Value: The wheel group does not exist or is not configured\n        echo Recommendation: Restrict access to the su command\n        echo Remediation:\n        echo # sudo groupadd wheel\n        echo # sudo usermod -aG wheel <username>\n    else\n        echo Check: Ensure access to the su command is restricted\n        echo Status: Pass\n        echo Recommendation: No remediation required.\n    fi\n}\n\n# Execute the check\ncheck_su_access\n', "check_pam_installed() {\n    pam_version=$(dpkg-query -W -f='${Version}' libpam-modules)\n    \n    # Check if pam is installed and compare version\n    if dpkg-query -W libpam-modules >/dev/null 2>&1; then\n        echo Check: Ensure latest version of pam is installed\n        echo Status: Pass\n        echo Current Version: $pam_version\n        echo Recommendation: No remediation required.\n    else\n        echo Check: Ensure latest version of pam is installed\n        echo Status: Fail\n        echo Current Version: Not installed\n        echo Recommendation: Install the latest version of pam\n        echo Remediation:\n        echo # sudo apt update\n        echo # sudo apt install libpam-modules\n    fi\n}\n\n# Execute the check\ncheck_pam_installed\n", 'check_libpam_modules() {\n    if dpkg-query -W libpam-modules >/dev/null 2>&1; then\n        echo Check: Ensure libpam-modules is installed\n        echo Status: Pass\n        echo Current Value: libpam-modules is installed\n        echo Recommendation: No remediation required.\n    else\n        echo Check: Ensure libpam-modules is installed\n        echo Status: Fail\n        echo Current Value: libpam-modules is not installed\n        echo Recommendation: Install libpam-modules\n        echo Remediation:\n        echo # sudo apt update\n        echo # sudo apt install libpam-modules\n    fi\n}\n\n# Execute the check\ncheck_libpam_modules\n', 'check_libpam_pwquality() {\n    if dpkg-query -W libpam-pwquality >/dev/null 2>&1; then\n        echo Check: Ensure libpam-pwquality is installed\n        echo Status: Pass\n        echo Current Value: libpam-pwquality is installed\n        echo Recommendation: No remediation required.\n    else\n        echo Check: Ensure libpam-pwquality is installed\n        echo Status: Fail\n        echo Current Value: libpam-pwquality is not installed\n        echo Recommendation: Install libpam-pwquality\n        echo Remediation:\n        echo # sudo apt update\n        echo # sudo apt install libpam-pwquality\n    fi\n}\n\n# Execute the check\ncheck_libpam_pwquality\n', '# Check the permissions on SSH private host key files\ncheck_ssh_private_key_permissions() {\n    private_keys=("/etc/ssh/ssh_host_rsa_key" "/etc/ssh/ssh_host_dsa_key" "/etc/ssh/ssh_host_ecdsa_key" "/etc/ssh/ssh_host_ed25519_key")\n    for key in "${private_keys[@]}"; do\n        if [ -f "$key" ]; then\n            current_permissions=$(stat -c "%a" "$key")\n            if [ "$current_permissions" != "600" ]; then\n                echo "Check: Ensure permissions on SSH private host key files are configured"\n                echo "Status: Fail"\n                echo "Current Value: Permissions on $key are $current_permissions"\n                echo "Expected Value: Permissions should be 600"\n                echo "Recommendation: Set permissions to 600 for $key"\n                echo "Remediation:"\n                echo "# sudo chmod 600 $key"\n            else\n                echo "Check: Ensure permissions on SSH private host key files are configured"\n                echo "Status: Pass"\n                echo "Current Value: Permissions on $key are $current_permissions"\n                echo "Expected Value: Permissions should be 600"\n                echo "Recommendation: No remediation required."\n            fi\n        else\n            echo "Check: Ensure permissions on SSH private host key files are configured"\n            echo "Status: Fail"\n            echo "Current Value: $key file does not exist"\n            echo "Expected Value: $key should exist"\n            echo "Recommendation: Ensure the SSH private host key files exist and have correct permissions."\n        fi\n    done\n}\n\n# Execute the check\ncheck_ssh_private_key_permissions\n', '# Check the permissions on SSH public host key files\ncheck_ssh_public_key_permissions() {\n    public_keys=("/etc/ssh/ssh_host_rsa_key.pub" "/etc/ssh/ssh_host_dsa_key.pub" "/etc/ssh/ssh_host_ecdsa_key.pub" "/etc/ssh/ssh_host_ed25519_key.pub")\n    for key in "${public_keys[@]}"; do\n        if [ -f "$key" ]; then\n            current_permissions=$(stat -c "%a" "$key")\n            if [ "$current_permissions" != "644" ]; then\n                echo "Check: Ensure permissions on SSH public host key files are configured"\n                echo "Status: Fail"\n                echo "Current Value: Permissions on $key are $current_permissions"\n                echo "Expected Value: Permissions should be 644"\n                echo "Recommendation: Set permissions to 644 for $key"\n                echo "Remediation:"\n                echo "# sudo chmod 644 $key"\n            else\n                echo "Check: Ensure permissions on SSH public host key files are configured"\n                echo "Status: Pass"\n                echo "Current Value: Permissions on $key are $current_permissions"\n                echo "Expected Value: Permissions should be 644"\n                echo "Recommendation: No remediation required."\n            fi\n        else\n            echo "Check: Ensure permissions on SSH public host key files are configured"\n            echo "Status: Fail"\n            echo "Current Value: $key file does not exist"\n            echo "Expected Value: $key should exist"\n            echo "Recommendation: Ensure the SSH public host key files exist and have correct permissions."\n        fi\n    done\n}\n\n# Execute the check\ncheck_ssh_public_key_permissions\n', 'check_sshd_ignore_rhosts() {\n    sshd_config="/etc/ssh/sshd_config"\n    ignore_rhosts=$(grep -E "^IgnoreRhosts" "$sshd_config")\n    \n    if [ -z "$ignore_rhosts" ]; then\n        echo Check: Ensure sshd IgnoreRhosts is enabled\n        echo Status: Fail\n        echo Current Value: IgnoreRhosts is not configured\n        echo Expected Value: IgnoreRhosts yes\n        echo Recommendation: Enable IgnoreRhosts\n        echo Remediation:\n        echo # sudo nano /etc/ssh/sshd_config\n        echo # IgnoreRhosts yes\n    else\n        echo Check: Ensure sshd IgnoreRhosts is enabled\n        echo Status: Pass\n        echo Current Value: $ignore_rhosts\n        echo Expected Value: IgnoreRhosts yes\n        echo Recommendation: No remediation required.\n    fi\n}\n\n# Execute the check\ncheck_sshd_ignore_rhosts\n', '# Check if sshd access is properly configured\ncheck_sshd_access() {\n    sshd_config="/etc/ssh/sshd_config"\n    if grep -q "^AllowUsers" "$sshd_config" || grep -q "^DenyUsers" "$sshd_config" || grep -q "^AllowGroups" "$sshd_config" || grep -q "^DenyGroups" "$sshd_config"; then\n        echo "Check: Ensure sshd access is configured"\n        echo "Status: Pass"\n        echo "Current Value: sshd access is configured"\n        echo "Expected Value: Access should be configured in /etc/ssh/sshd_config"\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure sshd access is configured"\n        echo "Status: Fail"\n        echo "Current Value: sshd access is not configured"\n        echo "Expected Value: Access should be configured"\n        echo "Recommendation: Add \'AllowUsers\' or \'DenyUsers\' in the sshd_config file."\n        echo "Remediation:"\n        echo "# sudo nano /etc/ssh/sshd_config"\n        echo "# AllowUsers user1 user2"\n    fi\n}\n\n# Execute the check\ncheck_sshd_access\n', 'check_sshd_kex_algorithms() {\n    sshd_config="/etc/ssh/sshd_config"\n    kex_algorithms=$(grep -E "^KexAlgorithms" "$sshd_config")\n    \n    if [ -z "$kex_algorithms" ]; then\n        echo "Check: Ensure sshd KexAlgorithms is configured"\n        echo "Status: Fail"\n        echo "Current Value: KexAlgorithms is not configured"\n        echo "Expected Value: KexAlgorithms diffie-hellman-group14-sha1,diffie-hellman-group-exchange-sha256"\n        echo "Recommendation: Configure KexAlgorithms"\n        echo "Remediation:"\n        echo "# sudo nano /etc/ssh/sshd_config"\n        echo "# KexAlgorithms diffie-hellman-group14-sha1,diffie-hellman-group-exchange-sha256"\n    else\n        echo "Check: Ensure sshd KexAlgorithms is configured"\n        echo "Status: Pass"\n        echo "Current Value: $kex_algorithms"\n        echo "Expected Value: KexAlgorithms diffie-hellman-group14-sha1,diffie-hellman-group-exchange-sha256"\n        echo "Recommendation: No remediation required."\n    fi\n}\n\n# Execute the check\ncheck_sshd_kex_algorithms\n', '# Check if sshd Banner is configured\ncheck_sshd_banner() {\n    sshd_config="/etc/ssh/sshd_config"\n    if grep -q "^Banner" "$sshd_config"; then\n        echo "Check: Ensure sshd Banner is configured"\n        echo "Status: Pass"\n        echo "Current Value: Banner is configured"\n        echo "Expected Value: Banner should be configured"\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure sshd Banner is configured"\n        echo "Status: Fail"\n        echo "Current Value: Banner is not configured"\n        echo "Expected Value: Banner should be configured"\n        echo "Recommendation: Configure the banner in /etc/ssh/sshd_config"\n        echo "Remediation:"\n        echo "# sudo nano /etc/ssh/sshd_config"\n        echo "# Banner /etc/issue.net"\n    fi\n}\n\n# Execute the check\ncheck_sshd_banner\n', '# Check if Ciphers are configured in /etc/ssh/sshd_config\ncheck_sshd_ciphers() {\n    sshd_config="/etc/ssh/sshd_config"\n    if grep -q "^Ciphers" "$sshd_config"; then\n        echo "Check: Ensure sshd Ciphers are configured"\n        echo "Status: Pass"\n        echo "Current Value: Ciphers are configured"\n        echo "Expected Value: Ciphers should be configured as per security policy"\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure sshd Ciphers are configured"\n        echo "Status: Fail"\n        echo "Current Value: Ciphers are not configured"\n        echo "Expected Value: Ciphers should be configured"\n        echo "Recommendation: Add Ciphers configuration in /etc/ssh/sshd_config"\n        echo "Remediation:"\n        echo "# sudo nano /etc/ssh/sshd_config"\n        echo "# Ciphers aes256-ctr,aes192-ctr,aes128-ctr"\n    fi\n}\n\n# Execute the check\ncheck_sshd_ciphers\n', 'check_sshd_login_gracetime() {\n    sshd_config="/etc/ssh/sshd_config"\n    login_gracetime=$(grep -E "^LoginGraceTime" "$sshd_config")\n    \n    if [ -z "$login_gracetime" ]; then\n        echo "Check: Ensure sshd LoginGraceTime is configured"\n        echo "Status: Fail"\n        echo "Current Value: LoginGraceTime is not configured"\n        echo "Expected Value: LoginGraceTime 60"\n        echo "Recommendation: Configure LoginGraceTime"\n        echo "Remediation:"\n        echo "# sudo nano /etc/ssh/sshd_config"\n        echo "# LoginGraceTime 60"\n    else\n        echo "Check: Ensure sshd LoginGraceTime is configured"\n        echo "Status: Pass"\n        echo "Current Value: $login_gracetime"\n        echo "Expected Value: LoginGraceTime 60"\n        echo "Recommendation: No remediation required."\n    fi\n}\n\n# Execute the check\ncheck_sshd_login_gracetime\n', '# Check if ClientAliveInterval and ClientAliveCountMax are configured\ncheck_sshd_alive_settings() {\n    sshd_config="/etc/ssh/sshd_config"\n    client_alive_interval=$(grep -E "^ClientAliveInterval" "$sshd_config")\n    client_alive_count_max=$(grep -E "^ClientAliveCountMax" "$sshd_config")\n    \n    if [ -z "$client_alive_interval" ] || [ -z "$client_alive_count_max" ]; then\n        echo "Check: Ensure sshd ClientAliveInterval and ClientAliveCountMax are configured"\n        echo "Status: Fail"\n        echo "Current Value: ClientAliveInterval or ClientAliveCountMax are not configured"\n        echo "Expected Value: ClientAliveInterval=300, ClientAliveCountMax=0"\n        echo "Recommendation: Configure ClientAliveInterval and ClientAliveCountMax"\n        echo "Remediation:"\n        echo "# sudo nano /etc/ssh/sshd_config"\n        echo "# ClientAliveInterval 300"\n        echo "# ClientAliveCountMax 0"\n    else\n        echo "Check: Ensure sshd ClientAliveInterval and ClientAliveCountMax are configured"\n        echo "Status: Pass"\n        echo "Current Value: $client_alive_interval, $client_alive_count_max"\n        echo "Expected Value: ClientAliveInterval=300, ClientAliveCountMax=0"\n        echo "Recommendation: No remediation required."\n    fi\n}\n\n# Execute the check\ncheck_sshd_alive_settings\n', 'check_sshd_log_level() {\n    sshd_config="/etc/ssh/sshd_config"\n    log_level=$(grep -E "^LogLevel" "$sshd_config")\n    \n    if [ -z "$log_level" ]; then\n        echo "Check: Ensure sshd LogLevel is configured"\n        echo "Status: Fail"\n        echo "Current Value: LogLevel is not configured"\n        echo "Expected Value: LogLevel INFO"\n        echo "Recommendation: Configure LogLevel"\n        echo "Remediation:"\n        echo "# sudo nano /etc/ssh/sshd_config"\n        echo "# LogLevel INFO"\n    else\n        echo "Check: Ensure sshd LogLevel is configured"\n        echo "Status: Pass"\n        echo "Current Value: $log_level"\n        echo "Expected Value: LogLevel INFO"\n        echo "Recommendation: No remediation required."\n    fi\n}\n\n# Execute the check\ncheck_sshd_log_level\n', 'check_sshd_macs() {\n    sshd_config="/etc/ssh/sshd_config"\n    macs=$(grep -E "^MACs" "$sshd_config")\n    \n    if [ -z "$macs" ]; then\n        echo "Check: Ensure sshd MACs are configured"\n        echo "Status: Fail"\n        echo "Current Value: MACs are not configured"\n        echo "Expected Value: MACs hmac-sha2-256,hmac-sha2-512"\n        echo "Recommendation: Configure MACs"\n        echo "Remediation:"\n        echo "# sudo nano /etc/ssh/sshd_config"\n        echo "# MACs hmac-sha2-256,hmac-sha2-512"\n    else\n        echo "Check: Ensure sshd MACs are configured"\n        echo "Status: Pass"\n        echo "Current Value: $macs"\n        echo "Expected Value: MACs hmac-sha2-256,hmac-sha2-512"\n        echo "Recommendation: No remediation required."\n    fi\n}\n\n# Execute the check\ncheck_sshd_macs\n', '# Check if DisableForwarding is enabled in /etc/ssh/sshd_config\ncheck_sshd_disable_forwarding() {\n    sshd_config="/etc/ssh/sshd_config"\n    disable_forwarding=$(grep -E "^DisableForwarding" "$sshd_config")\n    \n    if [ -z "$disable_forwarding" ]; then\n        echo "Check: Ensure sshd DisableForwarding is enabled"\n        echo "Status: Fail"\n        echo "Current Value: DisableForwarding is not configured"\n        echo "Expected Value: DisableForwarding yes"\n        echo "Recommendation: Configure DisableForwarding"\n        echo "Remediation:"\n        echo "# sudo nano /etc/ssh/sshd_config"\n        echo "# DisableForwarding yes"\n    else\n        echo "Check: Ensure sshd DisableForwarding is enabled"\n        echo "Status: Pass"\n        echo "Current Value: $disable_forwarding"\n        echo "Expected Value: DisableForwarding yes"\n        echo "Recommendation: No remediation required."\n    fi\n}\n\n# Execute the check\ncheck_sshd_disable_forwarding\n', 'check_sshd_max_auth_tries() {\n    sshd_config="/etc/ssh/sshd_config"\n    max_auth_tries=$(grep -E "^MaxAuthTries" "$sshd_config")\n    \n    if [ -z "$max_auth_tries" ]; then\n        echo "Check: Ensure sshd MaxAuthTries is configured"\n        echo "Status: Fail"\n        echo "Current Value: MaxAuthTries is not configured"\n        echo "Expected Value: MaxAuthTries 3"\n        echo "Recommendation: Configure MaxAuthTries"\n        echo "Remediation:"\n        echo "# sudo nano /etc/ssh/sshd_config"\n        echo "# MaxAuthTries 3"\n    else\n        echo "Check: Ensure sshd MaxAuthTries is configured"\n        echo "Status: Pass"\n        echo "Current Value: $max_auth_tries"\n        echo "Expected Value: MaxAuthTries 3"\n        echo "Recommendation: No remediation required."\n    fi\n}\n\n# Execute the check\ncheck_sshd_max_auth_tries\n', 'check_sshd_max_sessions() {\n    sshd_config="/etc/ssh/sshd_config"\n    max_sessions=$(grep -E "^MaxSessions" "$sshd_config")\n    \n    if [ -z "$max_sessions" ]; then\n        echo "Check: Ensure sshd MaxSessions is configured"\n        echo "Status: Fail"\n        echo "Current Value: MaxSessions is not configured"\n        echo "Expected Value: MaxSessions 2"\n        echo "Recommendation: Configure MaxSessions"\n        echo "Remediation:"\n        echo "# sudo nano /etc/ssh/sshd_config"\n        echo "# MaxSessions 2"\n    else\n        echo "Check: Ensure sshd MaxSessions is configured"\n        echo "Status: Pass"\n        echo "Current Value: $max_sessions"\n        echo "Expected Value: MaxSessions 2"\n        echo "Recommendation: No remediation required."\n    fi\n}\n\n# Execute the check\ncheck_sshd_max_sessions\n', 'check_sshd_max_startups() {\n    sshd_config="/etc/ssh/sshd_config"\n    max_startups=$(grep -E "^MaxStartups" "$sshd_config")\n    \n    if [ -z "$max_startups" ]; then\n        echo "Check: Ensure sshd MaxStartups is configured"\n        echo "Status: Fail"\n        echo "Current Value: MaxStartups is not configured"\n        echo "Expected Value: MaxStartups 10:30:60"\n        echo "Recommendation: Configure MaxStartups"\n        echo "Remediation:"\n        echo "# sudo nano /etc/ssh/sshd_config"\n        echo "# MaxStartups 10:30:60"\n    else\n        echo "Check: Ensure sshd MaxStartups is configured"\n        echo "Status: Pass"\n        echo "Current Value: $max_startups"\n        echo "Expected Value: MaxStartups 10:30:60"\n        echo "Recommendation: No remediation required."\n    fi\n}\n\n# Execute the check\ncheck_sshd_max_startups\n', 'check_sshd_gssapi_authentication() {\n    sshd_config="/etc/ssh/sshd_config"\n    gssapi_authentication=$(grep -E "^GSSAPIAuthentication" "$sshd_config")\n    \n    if [ -z "$gssapi_authentication" ]; then\n        echo "Check: Ensure sshd GSSAPIAuthentication is disabled"\n        echo "Status: Fail"\n        echo "Current Value: GSSAPIAuthentication is not configured"\n        echo "Expected Value: GSSAPIAuthentication no"\n        echo "Recommendation: Disable GSSAPIAuthentication"\n        echo "Remediation:"\n        echo "# sudo nano /etc/ssh/sshd_config"\n        echo "# GSSAPIAuthentication no"\n    else\n        echo "Check: Ensure sshd GSSAPIAuthentication is disabled"\n        echo "Status: Pass"\n        echo "Current Value: $gssapi_authentication"\n        echo "Expected Value: GSSAPIAuthentication no"\n        echo "Recommendation: No remediation required."\n    fi\n}\n\n# Execute the check\ncheck_sshd_gssapi_authentication\n ', 'check_sshd_hostbased_authentication() {\n    sshd_config="/etc/ssh/sshd_config"\n    hostbased_authentication=$(grep -E "^HostbasedAuthentication" "$sshd_config")\n    \n    if [ -z "$hostbased_authentication" ]; then\n        echo "Check: Ensure sshd HostbasedAuthentication is disabled"\n        echo "Status: Fail"\n        echo "Current Value: HostbasedAuthentication is not configured"\n        echo "Expected Value: HostbasedAuthentication no"\n        echo "Recommendation: Disable HostbasedAuthentication"\n        echo "Remediation:"\n        echo "# sudo nano /etc/ssh/sshd_config"\n        echo "# HostbasedAuthentication no"\n    else\n        echo "Check: Ensure sshd HostbasedAuthentication is disabled"\n        echo "Status: Pass"\n        echo "Current Value: $hostbased_authentication"\n        echo "Expected Value: HostbasedAuthentication no"\n        echo "Recommendation: No remediation required."\n    fi\n}\n\n# Execute the check\ncheck_sshd_hostbased_authentication\n ', 'check_sshd_permit_empty_passwords() {\n    sshd_config="/etc/ssh/sshd_config"\n    permit_empty_passwords=$(grep -E "^PermitEmptyPasswords" "$sshd_config")\n    \n    if [ -z "$permit_empty_passwords" ]; then\n        echo "Check: Ensure sshd PermitEmptyPasswords is disabled"\n        echo "Status: Fail"\n        echo "Current Value: PermitEmptyPasswords is not configured"\n        echo "Expected Value: PermitEmptyPasswords no"\n        echo "Recommendation: Disable PermitEmptyPasswords"\n        echo "Remediation:"\n        echo "# sudo nano /etc/ssh/sshd_config"\n        echo "# PermitEmptyPasswords no"\n    else\n        echo "Check: Ensure sshd PermitEmptyPasswords is disabled"\n        echo "Status: Pass"\n        echo "Current Value: $permit_empty_passwords"\n        echo "Expected Value: PermitEmptyPasswords no"\n        echo "Recommendation: No remediation required."\n    fi\n}\n\n# Execute the check\ncheck_sshd_permit_empty_passwords\n', 'check_sshd_permit_root_login() {\n    sshd_config="/etc/ssh/sshd_config"\n    permit_root_login=$(grep -E "^PermitRootLogin" "$sshd_config")\n    \n    if [ -z "$permit_root_login" ]; then\n        echo "Check: Ensure sshd PermitRootLogin is disabled"\n        echo "Status: Fail"\n        echo "Current Value: PermitRootLogin is not configured"\n        echo "Expected Value: PermitRootLogin no"\n        echo "Recommendation: Disable PermitRootLogin"\n        echo "Remediation:"\n        echo "# sudo nano /etc/ssh/sshd_config"\n        echo "# PermitRootLogin no"\n    else\n        echo "Check: Ensure sshd PermitRootLogin is disabled"\n        echo "Status: Pass"\n        echo "Current Value: $permit_root_login"\n        echo "Expected Value: PermitRootLogin no"\n        echo "Recommendation: No remediation required."\n    fi\n}\n\n# Execute the check\ncheck_sshd_permit_root_login\n', 'check_sshd_permit_user_environment() {\n    sshd_config="/etc/ssh/sshd_config"\n    permit_user_environment=$(grep -E "^PermitUserEnvironment" "$sshd_config")\n    \n    if [ -z "$permit_user_environment" ]; then\n        echo "Check: Ensure sshd PermitUserEnvironment is disabled"\n        echo "Status: Fail"\n        echo "Current Value: PermitUserEnvironment is not configured"\n        echo "Expected Value: PermitUserEnvironment no"\n        echo "Recommendation: Disable PermitUserEnvironment"\n        echo "Remediation:"\n        echo "# sudo nano /etc/ssh/sshd_config"\n        echo "# PermitUserEnvironment no"\n    else\n        echo "Check: Ensure sshd PermitUserEnvironment is disabled"\n        echo "Status: Pass"\n        echo "Current Value: $permit_user_environment"\n        echo "Expected Value: PermitUserEnvironment no"\n        echo "Recommendation: No remediation required."\n    fi\n}\n\n# Execute the check\ncheck_sshd_permit_user_environment\n', 'check_sshd_use_pam() {\n    sshd_config="/etc/ssh/sshd_config"\n    use_pam=$(grep -E "^UsePAM" "$sshd_config")\n    \n    if [ -z "$use_pam" ]; then\n        echo "Check: Ensure sshd UsePAM is enabled"\n        echo "Status: Fail"\n        echo "Current Value: UsePAM is not configured"\n        echo "Expected Value: UsePAM yes"\n        echo "Recommendation: Enable UsePAM"\n        echo "Remediation:"\n        echo "# sudo nano /etc/ssh/sshd_config"\n        echo "# UsePAM yes"\n    else\n        echo "Check: Ensure sshd UsePAM is enabled"\n        echo "Status: Pass"\n        echo "Current Value: $use_pam"\n        echo "Expected Value: UsePAM yes"\n        echo "Recommendation: No remediation required."\n    fi\n}\n\n# Execute the check\ncheck_sshd_use_pam\n', '#!/bin/bash\n\n# Function to check permissions on /etc/passwd\ncheck_passwd_permissions() {\n    passwd_permissions=$(stat -c "%a" /etc/passwd)\n\n    if [[ "$passwd_permissions" == "644" ]]; then\n        echo "Check: Ensure permissions on /etc/passwd are configured\n"\n        echo "Status: Pass\n"\n        echo "Current Value: Permissions on /etc/passwd are 644.\n"\n        echo "Expected Value: Permissions on /etc/passwd should be 644.\n"\n        echo "Recommendation: No remediation required.\n"\n    else\n        echo "Check: Ensure permissions on /etc/passwd are configured\n"\n        echo "Status: Fail\n"\n        echo "Current Value: Permissions on /etc/passwd are $passwd_permissions.\n"\n        echo "Expected Value: Permissions on /etc/passwd should be 644.\n"\n        echo "Recommendation: Set the correct permissions on /etc/passwd.\n"\n        echo "Remediation:\n"\n        echo "# sudo chmod 644 /etc/passwd\n"\n    fi\n}\n\n# Execute the check\ncheck_passwd_permissions\n', '# Check if permissions on /etc/passwd- are configured correctly\ncheck_passwd_dash_permissions() {\n    file="/etc/passwd-"\n    if [ -e "$file" ]; then\n        perms=$(stat -c "%a" "$file")\n        if [ "$perms" -eq 644 ]; then\n            echo "Check: Ensure permissions on /etc/passwd- are configured\n"\n            echo "Status: Pass\n"\n            echo "Current Value: Permissions are set to $perms\n"\n            echo "Recommendation: No remediation required.\n"\n        else\n            echo "Check: Ensure permissions on /etc/passwd- are configured\n"\n            echo "Status: Fail\n"\n            echo "Current Value: Permissions are set to $perms\n"\n            echo "Recommendation: Set permissions to 644\n"\n            echo "Remediation:\n"\n            echo "# sudo chmod 644 /etc/passwd-\n"\n        fi\n    else\n            echo "Check: Ensure permissions on /etc/passwd- are configured\n"\n            echo "Status: Fail\n"\n            echo "Current Value: Permissions are set to $perms\n"\n            echo "Recommendation: Set permissions to 644\n"\n            echo "Remediation:\n"\n            echo "# sudo chmod 644 /etc/passwd-\n"\n    fi\n}\n\n# Execute the check\ncheck_passwd_dash_permissions\n', '#!/bin/bash\n\n# Function to check permissions on /etc/group\ncheck_group_permissions() {\n    group_permissions=$(stat -c "%a" /etc/group)\n\n    if [[ "$group_permissions" == "644" ]]; then\n        echo "Check: Ensure permissions on /etc/group are configured\n"\n        echo "Status: Pass\n"\n        echo "Current Value: Permissions on /etc/group are 644.\n"\n        echo "Expected Value: Permissions on /etc/group should be 644.\n"\n        echo "Recommendation: No remediation required.\n"\n    else\n        echo "Check: Ensure permissions on /etc/group are configured\n"\n        echo "Status: Fail\n"\n        echo "Current Value: Permissions on /etc/group are $group_permissions.\n"\n        echo "Expected Value: Permissions on /etc/group should be 644.\n"\n        echo "Recommendation: Set the correct permissions on /etc/group.\n"\n        echo "Remediation:\n"\n        echo "# sudo chmod 644 /etc/group\n"\n    fi\n}\n\n# Execute the check\ncheck_group_permissions\n', '#!/bin/bash\n\n# Function to check permissions on /etc/group-\ncheck_group_dash_permissions() {\n    group_dash_permissions=$(stat -c "%a" /etc/group-)\n\n    if [[ "$group_dash_permissions" == "644" ]]; then\n        echo "Check: Ensure permissions on /etc/group- are configured\n"\n        echo "Status: Pass\n"\n        echo "Current Value: Permissions on /etc/group- are 644.\n"\n        echo "Expected Value: Permissions on /etc/group- should be 644.\n"\n        echo "Recommendation: No remediation required.\n"\n    else\n        echo "Check: Ensure permissions on /etc/group- are configured\n"\n        echo "Status: Fail\n"\n        echo "Current Value: Permissions on /etc/group- are $group_dash_permissions.\n"\n        echo "Expected Value: Permissions on /etc/group- should be 644.\n"\n        echo "Recommendation: Set the correct permissions on /etc/group-.\n"\n        echo "Remediation:\n"\n        echo "# sudo chmod 644 /etc/group-\n"\n    fi\n}\n\n# Execute the check\ncheck_group_dash_permissions\n', '#!/bin/bash\n\n# Function to check permissions on /etc/shadow\ncheck_shadow_permissions() {\n    shadow_permissions=$(stat -c "%a" /etc/shadow)\n\n    if [[ "$shadow_permissions" == "0000" ]]; then\n        echo "Check: Ensure permissions on /etc/shadow are configured\n"\n        echo "Status: Pass\n"\n        echo "Current Value: Permissions on /etc/shadow are 0000.\n"\n        echo "Expected Value: Permissions on /etc/shadow should be 0000.\n"\n        echo "Recommendation: No remediation required.\n"\n    else\n        echo "Check: Ensure permissions on /etc/shadow are configured\n"\n        echo "Status: Fail\n"\n        echo "Current Value: Permissions on /etc/shadow are $shadow_permissions.\n"\n        echo "Expected Value: Permissions on /etc/shadow should be 0000.\n"\n        echo "Recommendation: Set the correct permissions on /etc/shadow.\n"\n        echo "Remediation:\n"\n        echo "# sudo chmod 0000 /etc/shadow\n"\n    fi\n}\n\n# Execute the check\ncheck_shadow_permissions\n', '#!/bin/bash\n# Function to check if accounts in /etc/passwd use shadowed passwords\ncheck_shadowed_passwords() {\n    # Check if /etc/passwd exists\n    if [ ! -f /etc/passwd ]; then\n        echo "Check: Ensure accounts in /etc/passwd use shadowed passwords"\n        echo "Status: Fail"\n        echo "Current Value: /etc/passwd not found."\n        echo "Expected Value: /etc/passwd should exist."\n        echo "Recommendation: Ensure the system has a valid /etc/passwd file."\n        echo "Remediation:"\n        echo "# Ensure the system has a valid /etc/passwd file or restore it from backup."\n        return\n    fi\n\n    # Check for accounts with non-shadowed passwords\n    non_shadowed_accounts=$(awk -F: "($2 != "x" && $2 != "!") {print $1}" /etc/passwd 2>/dev/null)\n\n    if [ -z "$non_shadowed_accounts" ]; then\n        echo "Check: Ensure accounts in /etc/passwd use shadowed passwords"\n        echo "Status: Pass"\n        echo "Current Value: All accounts in /etc/passwd use shadowed passwords."\n        echo "Expected Value: All accounts should use shadowed passwords."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure accounts in /etc/passwd use shadowed passwords"\n        echo "Status: Fail"\n        echo "Accounts Without Shadowed Passwords:"\n        echo "$non_shadowed_accounts"\n        echo "Recommendation: Migrate these accounts to use shadowed passwords."\n        echo "Remediation:"\n        echo "# Use the following command to enable shadowed passwords for each account:"\n        echo "# sudo pwconv"\n    fi\n}\n\n# Execute the check\ncheck_shadowed_passwords\n ', '#!/bin/bash\n\n# Function to check permissions on /etc/shadow-\ncheck_shadow_dash_permissions() {\n    shadow_dash_permissions=$(stat -c "%a" /etc/shadow-)\n\n    if [[ "$shadow_dash_permissions" == "0000" ]]; then\n        echo "Check: Ensure permissions on /etc/shadow- are configured\n"\n        echo "Status: Pass\n"\n        echo "Current Value: Permissions on /etc/shadow- are 0000.\n"\n        echo "Expected Value: Permissions on /etc/shadow- should be 0000.\n"\n        echo "Recommendation: No remediation required.\n"\n    else\n        echo "Check: Ensure permissions on /etc/shadow- are configured\n"\n        echo "Status: Fail\n"\n        echo "Current Value: Permissions on /etc/shadow- are $shadow_dash_permissions.\n"\n        echo "Expected Value: Permissions on /etc/shadow- should be 0000.\n"\n        echo "Recommendation: Set the correct permissions on /etc/shadow-.\n"\n        echo "Remediation:\n"\n        echo "# sudo chmod 0000 /etc/shadow-\n"\n    fi\n}\n\n# Execute the check\ncheck_shadow_dash_permissions\n', '#!/bin/bash\n\n# Function to check if /etc/shadow password fields are not empty\ncheck_shadow_password_fields() {\n    # Check if /etc/shadow exists\n    if [ ! -f /etc/shadow ]; then\n        echo "Check: Ensure /etc/shadow password fields are not empty"\n        echo "Status: Fail"\n        echo "Current Value: /etc/shadow not found."\n        echo "Expected Value: /etc/shadow should exist."\n        echo "Recommendation: Ensure the system has a valid /etc/shadow file."\n        echo "Remediation:"\n        echo "# Ensure the system has a valid /etc/shadow file or restore it from backup."\n        return\n    fi\n\n    # Check if the script has read permissions for /etc/shadow\n    if [ ! -r /etc/shadow ]; then\n        echo "Check: Ensure /etc/shadow password fields are not empty"\n        echo "Status: Fail"\n        echo "Current Value: Permission denied to read /etc/shadow."\n        echo "Expected Value: The script should have permission to read /etc/shadow."\n        echo "Recommendation: Run the script with elevated privileges (sudo)."\n        echo "Remediation:"\n        echo "# Execute the script as a user with the necessary permissions using sudo."\n        return\n    fi\n\n    # Check for accounts with empty password fields in /etc/shadow\n    empty_passwords=$(awk -F: "($2 == "" || $2 == "!!") {print $1}" /etc/shadow)\n\n    if [ -z "$empty_passwords" ]; then\n        echo "Check: Ensure /etc/shadow password fields are not empty"\n        echo "Status: Pass"\n        echo "Current Value: No accounts with empty password fields in /etc/shadow."\n        echo "Expected Value: All password fields in /etc/shadow should be non-empty."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure /etc/shadow password fields are not empty"\n        echo "Status: Fail"\n        echo "Accounts with Empty Password Fields:"\n        echo "$empty_passwords"\n        echo "Recommendation: Assign a secure password to accounts with empty password fields."\n        echo "Remediation:"\n        echo "# To set a password for an account, use the following command:"\n        echo "# sudo passwd <username>"\n    fi\n}\n\n# Execute the check\ncheck_shadow_password_fields\n', '#!/bin/bash\n\n# Function to check permissions on /etc/gshadow\ncheck_gshadow_permissions() {\n    gshadow_permissions=$(stat -c "%a" /etc/gshadow)\n\n    if [[ "$gshadow_permissions" == "0000" ]]; then\n        echo "Check: Ensure permissions on /etc/gshadow are configured\n"\n        echo "Status: Pass\n"\n        echo "Current Value: Permissions on /etc/gshadow are 0000.\n"\n        echo "Expected Value: Permissions on /etc/gshadow should be 0000.\n"\n        echo "Recommendation: No remediation required.\n"\n    else\n        echo "Check: Ensure permissions on /etc/gshadow are configured\n"\n        echo "Status: Fail\n"\n        echo "Current Value: Permissions on /etc/gshadow are $gshadow_permissions.\n"\n        echo "Expected Value: Permissions on /etc/gshadow should be 0000.\n"\n        echo "Recommendation: Set the correct permissions on /etc/gshadow.\n"\n        echo "Remediation:\n"\n        echo "# sudo chmod 0000 /etc/gshadow\n"\n    fi\n}\n\n# Execute the check\ncheck_gshadow_permissions\n', '#!/bin/bash\n\n# Function to check permissions on /etc/gshadow-\ncheck_gshadow_dash_permissions() {\n    gshadow_dash_permissions=$(stat -c "%a" /etc/gshadow-)\n\n    if [[ "$gshadow_dash_permissions" == "0000" ]]; then\n        echo "Check: Ensure permissions on /etc/gshadow- are configured\n"\n        echo "Status: Pass\n"\n        echo "Current Value: Permissions on /etc/gshadow- are 0000.\n"\n        echo "Expected Value: Permissions on /etc/gshadow- should be 0000.\n"\n        echo "Recommendation: No remediation required.\n"\n    else\n        echo "Check: Ensure permissions on /etc/gshadow- are configured\n"\n        echo "Status: Fail\n"\n        echo "Current Value: Permissions on /etc/gshadow- are $gshadow_dash_permissions.\n"\n        echo "Expected Value: Permissions on /etc/gshadow- should be 0000.\n"\n        echo "Recommendation: Set the correct permissions on /etc/gshadow-.\n"\n        echo "Remediation:\n"\n        echo "# sudo chmod 0000 /etc/gshadow-\n"\n    fi\n}\n\n# Execute the check\ncheck_gshadow_dash_permissions\n', '#!/bin/bash\n# Function to check if all groups in /etc/passwd exist in /etc/group\ncheck_groups_in_passwd_exist_in_group() {\n    # Check if /etc/passwd exists\n    if [ ! -f /etc/passwd ]; then\n        echo "Check: Ensure all groups in /etc/passwd exist in /etc/group"\n        echo "Status: Fail"\n        echo "Current Value: /etc/passwd not found."\n        echo "Expected Value: /etc/passwd should exist."\n        echo "Recommendation: Ensure the system has a valid /etc/passwd file."\n        echo "Remediation:"\n        echo "# Ensure the system has a valid /etc/passwd file or restore it from backup."\n        return\n    fi\n\n    # Check if /etc/group exists\n    if [ ! -f /etc/group ]; then\n        echo "Check: Ensure all groups in /etc/passwd exist in /etc/group"\n        echo "Status: Fail"\n        echo "Current Value: /etc/group not found."\n        echo "Expected Value: /etc/group should exist."\n        echo "Recommendation: Ensure the system has a valid /etc/group file."\n        echo "Remediation:"\n        echo "# Ensure the system has a valid /etc/group file or restore it from backup."\n        return\n    fi\n\n    # Check if the script has read permissions for /etc/passwd and /etc/group\n    if [ ! -r /etc/passwd ] || [ ! -r /etc/group ]; then\n        echo "Check: Ensure all groups in /etc/passwd exist in /etc/group"\n        echo "Status: Fail"\n        echo "Current Value: Permission denied to read /etc/passwd or /etc/group."\n        echo "Expected Value: The script should have permission to read both files."\n        echo "Recommendation: Run the script with elevated privileges (sudo)."\n        echo "Remediation:"\n        echo "# Execute the script as a user with the necessary permissions using sudo."\n        return\n    fi\n\n    # Check for groups in /etc/passwd that do not exist in /etc/group\n    missing_groups=$(awk -F: "NR==FNR {groups[$1]; next} !($4 in groups)" /etc/group /etc/passwd)\n\n    if [ -z "$missing_groups" ]; then\n        echo "Check: Ensure all groups in /etc/passwd exist in /etc/group"\n        echo "Status: Pass"\n        echo "Current Value: All groups in /etc/passwd exist in /etc/group."\n        echo "Expected Value: All groups in /etc/passwd should exist in /etc/group."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure all groups in /etc/passwd exist in /etc/group"\n        echo "Status: Fail"\n        echo "Current Value: Some groups in /etc/passwd do not exist in /etc/group."\n        echo "Expected Value: All groups in /etc/passwd should exist in /etc/group."\n        echo "Recommendation: Add missing groups to /etc/group to match the groups in /etc/passwd."\n        echo "Remediation:"\n        echo "# To add missing groups, use the following command:"\n        echo "# sudo groupadd -g <group_id> <group_name>"\n    fi\n}\n\n# Execute the check\ncheck_groups_in_passwd_exist_in_group', '#!/bin/bash\n\n# Function to check permissions on /etc/shells\ncheck_shells_permissions() {\n    shells_permissions=$(stat -c "%a" /etc/shells)\n\n    if [[ "$shells_permissions" == "644" ]]; then\n        echo "Check: Ensure permissions on /etc/shells are configured\n"\n        echo "Status: Pass\n"\n        echo "Current Value: Permissions on /etc/shells are 644.\n"\n        echo "Expected Value: Permissions on /etc/shells should be 644.\n"\n        echo "Recommendation: No remediation required.\n"\n    else\n        echo "Check: Ensure permissions on /etc/shells are configured\n"\n        echo "Status: Fail\n"\n        echo "Current Value: Permissions on /etc/shells are $shells_permissions.\n"\n        echo "Expected Value: Permissions on /etc/shells should be 644.\n"\n        echo "Recommendation: Set the correct permissions on /etc/shells.\n"\n        echo "Remediation:\n"\n        echo "# sudo chmod 644 /etc/shells\n"\n    fi\n}\n\n# Execute the check\ncheck_shells_permissions\n', '#!/bin/bash\n\n# Function to check permissions on /etc/shells\ncheck_shells_permissions() {\n    shells_permissions=$(stat -c "%a" /etc/shells)\n\n    if [[ "$shells_permissions" == "644" ]]; then\n        echo "Check: Ensure permissions on /etc/shells are configured\n"\n        echo "Status: Pass\n"\n        echo "Current Value: Permissions on /etc/shells are 644.\n"\n        echo "Expected Value: Permissions on /etc/shells should be 644.\n"\n        echo "Recommendation: No remediation required.\n"\n    else\n        echo "Check: Ensure permissions on /etc/shells are configured\n"\n        echo "Status: Fail\n"\n        echo "Current Value: Permissions on /etc/shells are $shells_permissions.\n"\n        echo "Expected Value: Permissions on /etc/shells should be 644.\n"\n        echo "Recommendation: Set the correct permissions on /etc/shells.\n"\n        echo "Remediation:\n"\n        echo "# sudo chmod 644 /etc/shells\n"\n    fi\n}\n\n# Execute the check\ncheck_shells_permissions\n', '#!/bin/bash\n\n# Function to check world writable files and directories\ncheck_world_writable() {\n    world_writable_files=$(find / -type f -perm -0002)\n\n    if [[ -z "$world_writable_files" ]]; then\n        echo "Check: Ensure world writable files and directories are secured"\n        echo "Status: Pass"\n        echo "Current Value: No world writable files or directories."\n        echo "Expected Value: No world writable files or directories."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure world writable files and directories are secured"\n        echo "Status: Fail"\n        echo "Current Value: Found world writable files and directories."\n        echo "Expected Value: No world writable files or directories."\n        echo "Recommendation: Secure or remove world writable files."\n        echo "Remediation:"\n        echo "# sudo chmod o-w <file/directory>"\n    fi\n}\n\n# Execute the check\ncheck_world_writable\n', '#!/bin/bash\n\n# Function to check for files or directories without owner/group\ncheck_no_owner_or_group() {\n    missing_owner_group=$(find / -nouser -o -nogroup)\n\n    if [[ -z "$missing_owner_group" ]]; then\n        echo "Check: Ensure no files or directories without an owner and a group exist"\n        echo "Status: Pass"\n        echo "Current Value: No files or directories without owner and group."\n        echo "Expected Value: No files or directories without an owner and group."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure no files or directories without an owner and a group exist"\n        echo "Status: Fail"\n        echo "Current Value: Found files or directories without owner/group."\n        echo "Expected Value: No files or directories without owner/group."\n        echo "Recommendation: Assign owner/group to files."\n        echo "Remediation:"\n        echo "# sudo chown <owner>:<group> <file/directory>"\n    fi\n}\n\n# Execute the check\ncheck_no_owner_or_group\n', '#!/bin/bash\n\n# Function to check for SUID and SGID files\ncheck_suid_sgid_files() {\n    suid_files=$(find / -type f -perm /4000)\n    sgid_files=$(find / -type f -perm /2000)\n\n    if [[ -z "$suid_files" && -z "$sgid_files" ]]; then\n        echo "Check: Ensure SUID and SGID files are reviewed"\n        echo "Status: Pass"\n        echo "Current Value: No SUID or SGID files."\n        echo "Expected Value: No SUID or SGID files."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure SUID and SGID files are reviewed"\n        echo "Status: Fail"\n        echo "Current Value: Found SUID or SGID files."\n        echo "Expected Value: No SUID or SGID files."\n        echo "Recommendation: Review and remove unnecessary SUID/SGID files."\n        echo "Remediation:"\n        echo "# sudo chmod u-s <file>"\n        echo "# sudo chmod g-s <file>"\n    fi\n}\n\n# Execute the check\ncheck_suid_sgid_files\n', '#!/bin/bash\n\n# Function to check if the shadow group is empty\ncheck_shadow_group_empty() {\n    \n    # Check if /etc/group exists\n    if [ ! -f /etc/group ]; then\n        echo "Check: Ensure shadow group is empty"\n        echo "Status: Fail"\n        echo "Current Value: /etc/group not found."\n        echo "Expected Value: /etc/group should exist."\n        echo "Recommendation: Ensure the /etc/group file exists."\n        echo "Remediation:"\n        echo "# Ensure the system has a valid /etc/group file or restore it from backup."\n        return\n    fi\n\n    # Check if any users belong to the \'shadow\' group\n    shadow_group_members=$(grep "^shadow:" /etc/group 2>/dev/null | cut -d: -f4)\n\n    if [ -z "$shadow_group_members" ]; then\n        echo "Check: Ensure shadow group is empty"\n        echo "Status: Pass"\n        echo "Current Value: The shadow group is empty."\n        echo "Expected Value: The shadow group should be empty."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure shadow group is empty"\n        echo "Status: Fail"\n        echo "Shadow Group Members:"\n        echo "$shadow_group_members"\n        echo "Recommendation: Ensure that no users belong to the shadow group."\n        echo "Remediation:"\n        echo "# For each user in the shadow group, remove them from the group using the following command:"\n        echo "# sudo gpasswd -d <username> shadow"\n    fi\n}\n\n# Execute the check\ncheck_shadow_group_empty', '#!/bin/bash\n\n# Function to check for duplicate UIDs in /etc/passwd\ncheck_duplicate_uids() {\n    # Check if /etc/passwd exists\n    if [ ! -f /etc/passwd ]; then\n        echo "Check: Ensure no duplicate UIDs exist"\n        echo "Status: Fail"\n        echo "Current Value: /etc/passwd not found."\n        echo "Expected Value: /etc/passwd should exist."\n        echo "Recommendation: Ensure the system has a valid /etc/passwd file."\n        echo "Remediation:"\n        echo "# Ensure the system has a valid /etc/passwd file or restore it from backup."\n        return\n    fi\n\n    # Check for duplicate UIDs\n    duplicate_uids=$(awk -F: \'{print $3}\' /etc/passwd 2>/dev/null | sort | uniq -d)\n\n    if [ -z "$duplicate_uids" ]; then\n        echo "Check: Ensure no duplicate UIDs exist"\n        echo "Status: Pass"\n        echo "Current Value: No duplicate UIDs found."\n        echo "Expected Value: UIDs should be unique."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure no duplicate UIDs exist"\n        echo "Status: Fail"\n        echo "Duplicate UIDs:"\n        echo "$duplicate_uids"\n        echo "Recommendation: Resolve the duplicate UIDs by ensuring each user has a unique UID."\n        echo "Remediation:"\n        echo "# To fix duplicate UIDs, change the UID for each conflicting user using the following command:"\n        echo "# sudo usermod -u <new_uid> <username>"\n    fi\n}\n\n# Execute the check\ncheck_duplicate_uids', '#!/bin/bash\n\n# Function to check for duplicate GIDs in /etc/group\ncheck_duplicate_gids() {\n    # Check if /etc/group exists\n    if [ ! -f /etc/group ]; then\n        echo "Check: Ensure no duplicate GIDs exist"\n        echo "Status: Fail"\n        echo "Current Value: /etc/group not found."\n        echo "Expected Value: /etc/group should exist."\n        echo "Recommendation: Ensure the system has a valid /etc/group file."\n        echo "Remediation:"\n        echo "# Ensure the system has a valid /etc/group file or restore it from backup."\n        return\n    fi\n\n    # Check for duplicate GIDs\n    duplicate_gids=$(awk -F: \'{print $3}\' /etc/group 2>/dev/null | sort | uniq -d)\n\n    if [ -z "$duplicate_gids" ]; then\n        echo "Check: Ensure no duplicate GIDs exist"\n        echo "Status: Pass"\n        echo "Current Value: No duplicate GIDs found."\n        echo "Expected Value: GIDs should be unique."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure no duplicate GIDs exist"\n        echo "Status: Fail"\n        echo "Duplicate GIDs:"\n        echo "$duplicate_gids"\n        echo "Recommendation: Resolve the duplicate GIDs by ensuring each group has a unique GID."\n        echo "Remediation:"\n        echo "# To fix duplicate GIDs, change the GID for each conflicting group using the following command:"\n        echo "# sudo groupmod -g <new_gid> <groupname>"\n    fi\n}\n\n# Execute the check\ncheck_duplicate_gids', '#!/bin/bash\n\n# Function to check for duplicate user names in /etc/passwd\ncheck_duplicate_usernames() {\n    # Check if /etc/passwd exists\n    if [ ! -f /etc/passwd ]; then\n        echo "Check: Ensure no duplicate user names exist"\n        echo "Status: Fail"\n        echo "Current Value: /etc/passwd not found."\n        echo "Expected Value: /etc/passwd should exist."\n        echo "Recommendation: Ensure the system has a valid /etc/passwd file."\n        echo "Remediation:"\n        echo "# Ensure the system has a valid /etc/passwd file or restore it from backup."\n        return\n    fi\n\n    # Check for duplicate usernames\n    duplicate_usernames=$(awk -F: \'{print $1}\' /etc/passwd 2>/dev/null | sort | uniq -d)\n\n    if [ -z "$duplicate_usernames" ]; then\n        echo "Check: Ensure no duplicate user names exist"\n        echo "Status: Pass"\n        echo "Current Value: No duplicate usernames found."\n        echo "Expected Value: Usernames should be unique."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure no duplicate user names exist"\n        echo "Status: Fail"\n        echo "Duplicate User Names:"\n        echo "$duplicate_usernames"\n        echo "Recommendation: Resolve the duplicate usernames by ensuring each username is unique."\n        echo "Remediation:"\n        echo "# To fix duplicate usernames, change the username for each conflicting user using the following command:"\n        echo "# sudo usermod -l <new_username> <old_username>"\n    fi\n}\n\n# Execute the check\ncheck_duplicate_usernames', '#!/bin/bash\n\n# Function to check for duplicate group names in /etc/group\ncheck_duplicate_groupnames() {\n    # Check if /etc/group exists\n    if [ ! -f /etc/group ]; then\n        echo "Check: Ensure no duplicate group names exist"\n        echo "Status: Fail"\n        echo "Current Value: /etc/group not found."\n        echo "Expected Value: /etc/group should exist."\n        echo "Recommendation: Ensure the system has a valid /etc/group file."\n        echo "Remediation:"\n        echo "# Ensure the system has a valid /etc/group file or restore it from backup."\n        return\n    fi\n\n    # Check for duplicate group names\n    duplicate_groupnames=$(awk -F: \'{print $1}\' /etc/group 2>/dev/null | sort | uniq -d)\n\n    if [ -z "$duplicate_groupnames" ]; then\n        echo "Check: Ensure no duplicate group names exist"\n        echo "Status: Pass"\n        echo "Current Value: No duplicate group names found."\n        echo "Expected Value: Group names should be unique."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure no duplicate group names exist"\n        echo "Status: Fail"\n        echo "Duplicate Group Names:"\n        echo "$duplicate_groupnames"\n        echo "Recommendation: Resolve the duplicate group names by ensuring each group name is unique."\n        echo "Remediation:"\n        echo "# To fix duplicate group names, change the group name for each conflicting group using the following command:"\n        echo "# sudo groupmod -n <new_groupname> <old_groupname>"\n    fi\n}\n\n# Execute the check\ncheck_duplicate_groupnames', '#!/bin/bash\n\n# Function to check if local interactive user home directories are configured\ncheck_local_user_home_directories() {\n    # Check if /etc/passwd exists\n    if [ ! -f /etc/passwd ]; then\n        echo "Check: Ensure local interactive user home directories are configured"\n        echo "Status: Fail"\n        echo "Current Value: /etc/passwd not found."\n        echo "Expected Value: /etc/passwd should exist."\n        echo "Recommendation: Ensure the system has a valid /etc/passwd file."\n        echo "Remediation:"\n        echo "# Ensure the system has a valid /etc/passwd file or restore it from backup."\n        return\n    fi\n\n    # Check for users without home directories configured\n    users_without_home=$(awk -F: \'($7 != "/usr/sbin/nologin" && $7 != "/bin/false" && $6 == "") {print $1}\' /etc/passwd 2>/dev/null)\n\n    if [ -z "$users_without_home" ]; then\n        echo "Check: Ensure local interactive user home directories are configured"\n        echo "Status: Pass"\n        echo "Current Value: All interactive users have home directories configured."\n        echo "Expected Value: Interactive users should have home directories."\n        echo "Recommendation: No remediation required."\n    else\n        echo "Check: Ensure local interactive user home directories are configured"\n        echo "Status: Fail"\n        echo "Users Without Home Directories:"\n        echo "$users_without_home"\n        echo "Recommendation: Ensure all interactive users have their home directories configured."\n        echo "Remediation:"\n        echo "# To fix this, set a home directory for users using the following command:"\n        echo "# sudo usermod -m -d /home/<username> <username>"\n    fi\n}\n\n# Execute the check\ncheck_local_user_home_directories', '#!/bin/bash\n\n# Function to check if local interactive user dot files access is configured\ncheck_local_user_dot_files_access() {\n    # Check if /etc/passwd exists\n    if [ ! -f /etc/passwd ]; then\n        echo "Check: Ensure local interactive user dot files access is configured"\n        echo "Status: Fail"\n        echo "Current Value: /etc/passwd not found."\n        echo "Expected Value: /etc/passwd should exist."\n        echo "Recommendation: Ensure the system has a valid /etc/passwd file."\n        echo "Remediation:"\n        echo "# Ensure the system has a valid /etc/passwd file or restore it from backup."\n        return\n    fi\n\n    # Check for interactive users with home directories\n    interactive_users=$(awk -F: \'($7 != "/usr/sbin/nologin" && $7 != "/bin/false" && $6 != "") {print $1, $6}\' /etc/passwd)\n\n    if [ -z "$interactive_users" ]; then\n        echo "Check: Ensure local interactive user dot files access is configured"\n        echo "Status: Pass"\n        echo "Current Value: No interactive users found with home directories."\n        echo "Expected Value: Interactive users should have home directories."\n        echo "Recommendation: No remediation required."\n        return\n    fi\n\n    # Check if dot files (.bashrc, .profile) are accessible for each interactive user\n    for user_info in $interactive_users; do\n        username=$(echo $user_info | awk \'{print $1}\')\n        user_home_dir=$(echo $user_info | awk \'{print $2}\')\n        \n        # Check if .bashrc and .profile exist and have appropriate permissions\n        for file in .bashrc .profile; do\n            file_path="$user_home_dir/$file"\n            \n            if [ -e "$file_path" ]; then\n                file_permissions=$(stat -c "%a" "$file_path")\n                \n                if [[ $file_permissions != "644" && $file_permissions != "600" ]]; then\n                    echo "Check: Ensure local interactive user dot files access is configured"\n                    echo "Status: Fail"\n                    echo "Current Value: Incorrect permissions for $file on $username\'s home directory."\n                    echo "Expected Value: Permissions for $file should be 644 or 600."\n                    echo "Recommendation: Ensure the permissions for dot files are configured properly."\n                    echo "Remediation:"\n                    echo "# To fix permissions for $file, use the following command:"\n                    echo "# sudo chmod 644 $file_path  # or sudo chmod 600 $file_path"\n                    return\n                fi\n            else\n                echo "Check: Ensure local interactive user dot files access is configured"\n                echo "Status: Fail"\n                echo "Current Value: $file does not exist for $username."\n                echo "Expected Value: $file should exist in the home directory."\n                echo "Recommendation: Create the missing dot file ($file) for $username."\n                echo "Remediation:"\n                echo "# To create the missing dot file, use the following command:"\n                echo "# sudo touch $file_path"\n                return\n            fi\n        done\n    done\n\n    echo "Check: Ensure local interactive user dot files access is configured"\n    echo "Status: Pass"\n    echo "Current Value: All interactive users\' dot files have appropriate permissions."\n    echo "Expected Value: Dot files should have correct permissions (644 or 600)."\n    echo "Recommendation: No remediation required."\n}\n\n# Execute the check\ncheck_local_user_dot_files_access', 'check_pam_installed() { pam_version=$(dpkg-query -W -f=\'${Version}\' libpam-modules); /n if dpkg-query -W libpam-modules >/dev/null 2>&1; then /n echo "Check: Ensure latest version of pam is installed"; /n echo "Status: Pass"; /n echo "Current Version: $pam_version"; /n echo "Recommendation: No remediation required."; /n else /n echo "Check: Ensure latest version of pam is installed"; /n echo "Status: Fail"; /n echo "Current Version: Not installed"; /n echo "Recommendation: Install the latest version of pam"; /n echo "Remediation:"; /n echo "# sudo apt update"; /n echo "# sudo apt install libpam-modules"; /n fi; /n }; /n check_pam_installed /n', 'check_libpam_modules() { /n if dpkg-query -W libpam-modules >/dev/null 2>&1; then /n echo "Check: Ensure libpam-modules is installed"; /n echo "Status: Pass"; /n echo "Current Value: libpam-modules is installed"; /n echo "Recommendation: No remediation required."; /n else /n echo "Check: Ensure libpam-modules is installed"; /n echo "Status: Fail"; /n echo "Current Value: libpam-modules is not installed"; /n echo "Recommendation: Install libpam-modules"; /n echo "Remediation:"; /n echo "# sudo apt update"; /n echo "# sudo apt install libpam-modules"; /n fi; /n } /n check_libpam_modules /n', '#!/bin/bash /n pam_unix=$(grep -E \'^password.*required.*pam_unix.so\' /etc/pam.d/system-auth /etc/pam.d/password-auth) /n if [[ -n "$pam_unix" ]]; then /n echo "Check: Ensure pam_unix module is enabled" /n echo "Status: Pass" /n else /n echo "Check: Ensure pam_unix module is enabled" /n echo "Status: Fail" /n echo "Recommendation: Ensure \'pam_unix\' is included to handle traditional password management for user authentication." /n echo "Remediation: Add the following line to both /etc/pam.d/system-auth and /etc/pam.d/password-auth:" /n echo "Remediation Command: echo \'password required pam_unix.so\' >> /etc/pam.d/system-auth && echo \'password required pam_unix.so\' >> /etc/pam.d/password-auth" /n fi /n', '#!/bin/bash /n pam_faillock=$(grep -E \'auth.*required.*pam_faillock.so\' /etc/pam.d/system-auth /etc/pam.d/password-auth) /n if [[ -n "$pam_faillock" ]]; then /n echo "Check: Ensure pam_faillock module is enabled" /n echo "Status: Pass" /n else /n echo "Check: Ensure pam_faillock module is enabled" /n echo "Status: Fail" /n echo "Recommendation: Enable the \'pam_faillock\' module to lock accounts after repeated authentication failures." /n echo "Remediation: Add the following line to both /etc/pam.d/system-auth and /etc/pam.d/password-auth:" /n echo "Remediation Command: echo \'auth required pam_faillock.so\' >> /etc/pam.d/system-auth && echo \'auth required pam_faillock.so\' >> /etc/pam.d/password-auth" /n fi /n', '#!/bin/bash /n pam_pwquality=$(grep -E \'^password.*requisite.*pam_pwquality.so\' /etc/pam.d/system-auth /etc/pam.d/password-auth) /n if [[ -n "$pam_pwquality" ]]; then /n echo "Check: Ensure pam_pwquality module is enabled" /n echo "Status: Pass" /n else /n echo "Check: Ensure pam_pwquality module is enabled" /n echo "Status: Fail" /n echo "Recommendation: Include the \'pam_pwquality\' module to enforce password complexity policies." /n echo "Remediation: Add the following line to both /etc/pam.d/system-auth and /etc/pam.d/password-auth:" /n echo "Remediation Command: echo \'password requisite pam_pwquality.so\' >> /etc/pam.d/system-auth && echo \'password requisite pam_pwquality.so\' >> /etc/pam.d/password-auth" /n fi /n', '#!/bin/bash /n pam_pwhistory=$(grep -E \'^password.*required.*pam_pwhistory.so\' /etc/pam.d/system-auth /etc/pam.d/password-auth) /n if [[ -n "$pam_pwhistory" ]]; then /n echo "Check: Ensure pam_pwhistory module is enabled" /n echo "Status: Pass" /n else /n echo "Check: Ensure pam_pwhistory module is enabled" /n echo "Status: Fail" /n echo "Recommendation: Use the \'pam_pwhistory\' module to prevent password reuse by storing password history." /n echo "Remediation: Add the following line to both /etc/pam.d/system-auth and /etc/pam.d/password-auth:" /n echo "Remediation Command: echo \'password required pam_pwhistory.so\' >> /etc/pam.d/system-auth && echo \'password required pam_pwhistory.so\' >> /etc/pam.d/password-auth" /n fi /n', '#!/bin/bash\n\n# Check if password failed attempts lockout is configured\nlockout_config=$(grep -E "^auths+requireds+pam_tally2.so" /etc/pam.d/common-auth)\n\nif [[ -z "$lockout_config" ]]; then\n    echo "Check: Ensure password failed attempts lockout is configured"\n    echo "Status: Fail"\n    echo "Current Value: Failed attempts lockout is not configured."\n    echo "Expected Value: Password failed attempts lockout should be configured."\n    echo "Recommendation: Configure password failed attempts lockout."\n    echo "Remediation:"\n    echo "# sudo nano /etc/pam.d/common-auth"\n    echo "Add or modify the line: auth required pam_tally2.so deny=5 onerr=fail unlock_time=900"\nelse\n    echo "Check: Ensure password failed attempts lockout is configured"\n    echo "Status: Pass"\n    echo "Current Value: Password failed attempts lockout is configured."\n    echo "Expected Value: Password failed attempts lockout should be configured."\n    echo "Recommendation: No remediation required."\nfi\n', '#!/bin/bash\n\n# Check if password unlock time is configured\nunlock_time_config=$(grep -E "unlock_time=d+" /etc/pam.d/common-auth)\n\nif [[ -z "$unlock_time_config" ]]; then\n    echo "Check: Ensure password unlock time is configured"\n    echo "Status: Fail"\n    echo "Current Value: Password unlock time is not configured."\n    echo "Expected Value: Password unlock time should be configured."\n    echo "Recommendation: Configure password unlock time."\n    echo "Remediation:"\n    echo "# sudo nano /etc/pam.d/common-auth"\n    echo "Add or modify the line: auth required pam_tally2.so deny=5 onerr=fail unlock_time=900"\nelse\n    echo "Check: Ensure password unlock time is configured"\n    echo "Status: Pass"\n    echo "Current Value: Password unlock time is configured."\n    echo "Expected Value: Password unlock time should be configured."\n    echo "Recommendation: No remediation required."\nfi\n', '#!/bin/bash\n\n# Check if password failed attempts lockout includes root account\nroot_lockout_config=$(grep -E "^auths+requireds+pam_tally2.so" /etc/pam.d/common-auth | grep -E "root")\n\nif [[ -z "$root_lockout_config" ]]; then\n    echo "Check: Ensure password failed attempts lockout includes root account"\n    echo "Status: Fail"\n    echo "Current Value: Root account failed attempts lockout is not included."\n    echo "Expected Value: Root account should be included in the failed attempts lockout."\n    echo "Recommendation: Include root account in failed attempts lockout."\n    echo "Remediation:"\n    echo "# sudo nano /etc/pam.d/common-auth"\n    echo "Modify the line to ensure root is included: auth required pam_tally2.so deny=5 onerr=fail unlock_time=900"\nelse\n    echo "Check: Ensure password failed attempts lockout includes root account"\n    echo "Status: Pass"\n    echo "Current Value: Root account failed attempts lockout is configured."\n    echo "Expected Value: Root account should be included in the failed attempts lockout."\n    echo "Recommendation: No remediation required."\nfi\n', '#!/bin/bash\n\n# Check if password number of changed characters is configured\nchanged_chars_config=$(grep -E "^passwords+requireds+pam_pwquality.so" /etc/pam.d/common-password | grep -E "minlen")\n\nif [[ -z "$changed_chars_config" ]]; then\n    echo "Check: Ensure password number of changed characters is configured"\n    echo "Status: Fail"\n    echo "Current Value: Minimum password length is not configured."\n    echo "Expected Value: Minimum password length should be configured."\n    echo "Recommendation: Configure the number of changed characters."\n    echo "Remediation:"\n    echo "# sudo nano /etc/pam.d/common-password"\n    echo "Add or modify the line: password required pam_pwquality.so minlen=8 minclass=4"\nelse\n    echo "Check: Ensure password number of changed characters is configured"\n    echo "Status: Pass"\n    echo "Current Value: Minimum password length is configured."\n    echo "Expected Value: Minimum password length should be configured."\n    echo "Recommendation: No remediation required."\nfi\n', '#!/bin/bash\n\n# Check if minimum password length is configured\nminlen_config=$(grep -E "^passwords+requireds+pam_pwquality.so" /etc/pam.d/common-password | grep -E "minlen")\n\nif [[ -z "$minlen_config" ]]; then\n    echo "Check: Ensure minimum password length is configured"\n    echo "Status: Fail"\n    echo "Current Value: Minimum password length is not configured."\n    echo "Expected Value: Minimum password length should be configured."\n    echo "Recommendation: Configure minimum password length."\n    echo "Remediation:"\n    echo "# sudo nano /etc/pam.d/common-password"\n    echo "Add or modify the line: password required pam_pwquality.so minlen=8"\nelse\n    echo "Check: Ensure minimum password length is configured"\n    echo "Status: Pass"\n    echo "Current Value: Minimum password length is configured."\n    echo "Expected Value: Minimum password length should be configured."\n    echo "Recommendation: No remediation required."\nfi\n', '#!/bin/bash\n\n# Check if password complexity is configured\nminclass_config=$(grep -E "^passwords+requireds+pam_pwquality.so" /etc/pam.d/common-password | grep -E "minclass")\n\nif [[ -z "$minclass_config" ]]; then\n    echo "Check: Ensure password complexity is configured"\n    echo "Status: Fail"\n    echo "Current Value: Password complexity is not configured."\n    echo "Expected Value: Password complexity should be configured."\n    echo "Recommendation: Configure password complexity."\n    echo "Remediation:"\n    echo "# sudo nano /etc/pam.d/common-password"\n    echo "Add or modify the line: password required pam_pwquality.so minclass=4"\nelse\n    echo "Check: Ensure password complexity is configured"\n    echo "Status: Pass"\n    echo "Current Value: Password complexity is configured."\n    echo "Expected Value: Password complexity should be configured."\n    echo "Recommendation: No remediation required."\nfi', '#!/bin/bash\n\n# Check if password same consecutive characters is configured\nmaxrepeat_config=$(grep -E "^passwords+requireds+pam_pwquality.so" /etc/pam.d/common-password | grep -E "maxrepeat")\n\nif [[ -z "$maxrepeat_config" ]]; then\n    echo "Check: Ensure password same consecutive characters is configured"\n    echo "Status: Fail"\n    echo "Current Value: Password same consecutive characters is not configured."\n    echo "Expected Value: Password same consecutive characters should be configured."\n    echo "Recommendation: Configure password same consecutive characters."\n    echo "Remediation:"\n    echo "# sudo nano /etc/pam.d/common-password"\n    echo "Add or modify the line: password required pam_pwquality.so maxrepeat=3"\nelse\n    echo "Check: Ensure password same consecutive characters is configured"\n    echo "Status: Pass"\n    echo "Current Value: Password same consecutive characters is configured."\n    echo "Expected Value: Password same consecutive characters should be configured."\n    echo "Recommendation: No remediation required."\nfi', '#!/bin/bash\n\n# Check if password maximum sequential characters is configured\nmaxseq_config=$(grep -E "^passwords+requireds+pam_pwquality.so" /etc/pam.d/common-password | grep -E "maxsequence")\n\nif [[ -z "$maxseq_config" ]]; then\n    echo "Check: Ensure password maximum sequential characters is configured"\n    echo "Status: Fail"\n    echo "Current Value: Password maximum sequential characters is not configured."\n    echo "Expected Value: Password maximum sequential characters should be configured."\n    echo "Recommendation: Configure password maximum sequential characters."\n    echo "Remediation:"\n    echo "# sudo nano /etc/pam.d/common-password"\n    echo "Add or modify the line: password required pam_pwquality.so maxsequence=3"\nelse\n    echo "Check: Ensure password maximum sequential characters is configured"\n    echo "Status: Pass"\n    echo "Current Value: Password maximum sequential characters is configured."\n    echo "Expected Value: Password maximum sequential characters should be configured."\n    echo "Recommendation: No remediation required."\nfi', '#!/bin/bash\n\n# Check if password dictionary check is enabled\ndict_check_config=$(grep -E "^passwords+requireds+pam_pwquality.so" /etc/pam.d/common-password | grep -E "dict")\n\nif [[ -z "$dict_check_config" ]]; then\n    echo "Check: Ensure password dictionary check is enabled"\n    echo "Status: Fail"\n    echo "Current Value: Password dictionary check is not enabled."\n    echo "Expected Value: Password dictionary check should be enabled."\n    echo "Recommendation: Enable password dictionary check."\n    echo "Remediation:"\n    echo "# sudo nano /etc/pam.d/common-password"\n    echo "Add or modify the line: password required pam_pwquality.so dictcheck=1"\nelse\n    echo "Check: Ensure password dictionary check is enabled"\n    echo "Status: Pass"\n    echo "Current Value: Password dictionary check is enabled."\n    echo "Expected Value: Password dictionary check should be enabled."\n    echo "Recommendation: No remediation required."\nfi', '#!/bin/bash\n\n# Check if password quality checking is enforced\nquality_check_config=$(grep -E "^passwords+requireds+pam_pwquality.so" /etc/pam.d/common-password)\n\nif [[ -z "$quality_check_config" ]]; then\n    echo "Check: Ensure password quality checking is enforced"\n    echo "Status: Fail"\n    echo "Current Value: Password quality checking is not enforced."\n    echo "Expected Value: Password quality checking should be enforced."\n    echo "Recommendation: Enforce password quality checking."\n    echo "Remediation:"\n    echo "# sudo nano /etc/pam.d/common-password"\n    echo "Add or modify the line: password required pam_pwquality.so"\nelse\n    echo "Check: Ensure password quality checking is enforced"\n    echo "Status: Pass"\n    echo "Current Value: Password quality checking is enforced."\n    echo "Expected Value: Password quality checking should be enforced."\n    echo "Recommendation: No remediation required."\nfi', '#!/bin/bash\n\n# Check if password quality is enforced for the root user\nroot_quality_check_config=$(grep -E "^passwords+requireds+pam_pwquality.so" /etc/pam.d/common-password | grep -E "root")\n\nif [[ -z "$root_quality_check_config" ]]; then\n    echo "Check: Ensure password quality is enforced for the root user"\n    echo "Status: Fail"\n    echo "Current Value: Password quality is not enforced for the root user."\n    echo "Expected Value: Password quality should be enforced for the root user."\n    echo "Recommendation: Enforce password quality for the root user."\n    echo "Remediation:"\n    echo "# sudo nano /etc/pam.d/common-password"\n    echo "Ensure the following line is present: password required pam_pwquality.so"\nelse\n    echo "Check: Ensure password quality is enforced for the root user"\n    echo "Status: Pass"\n    echo "Current Value: Password quality is enforced for the root user."\n    echo "Expected Value: Password quality should be enforced for the root user."\n    echo "Recommendation: No remediation required."\nfi', '#!/bin/bash\n\n# Check if password history remember is configured\npassword_history=$(grep -E "^passwords+requireds+pam_pwhistory.so" /etc/pam.d/common-password | grep -E "remember=")\n\nif [[ -z "$password_history" ]]; then\n    echo "Check: Ensure password history remember is configured"\n    echo "Status: Fail"\n    echo "Current Value: Password history remember is not configured."\n    echo "Expected Value: Password history remember should be configured."\n    echo "Recommendation: Configure password history remember."\n    echo "Remediation:"\n    echo "# sudo nano /etc/pam.d/common-password"\n    echo "Add the following option: remember=5 (adjust the number as needed)"\nelse\n    echo "Check: Ensure password history remember is configured"\n    echo "Status: Pass"\n    echo "Current Value: Password history remember is configured."\n    echo "Expected Value: Password history remember should be configured."\n    echo "Recommendation: No remediation required."\nfi', '#!/bin/bash\n\n# Check if password history is enforced for the root user\nroot_password_history=$(grep -E "^passwords+requireds+pam_pwhistory.so" /etc/pam.d/common-password | grep -E "remember=")\n\nif [[ -z "$root_password_history" ]]; then\n    echo "Check: Ensure password history is enforced for the root user"\n    echo "Status: Fail"\n    echo "Current Value: Password history is not enforced for the root user."\n    echo "Expected Value: Password history should be enforced for the root user."\n    echo "Recommendation: Enforce password history for the root user."\n    echo "Remediation:"\n    echo "# sudo nano /etc/pam.d/common-password"\n    echo "Ensure the following line is present: password required pam_pwhistory.so remember=5"\nelse\n    echo "Check: Ensure password history is enforced for the root user"\n    echo "Status: Pass"\n    echo "Current Value: Password history is enforced for the root user."\n    echo "Expected Value: Password history should be enforced for the root user."\n    echo "Recommendation: No remediation required."\nfi', '#!/bin/bash\n\n# Check if pam_pwhistory includes use_authtok\npwhistory_use_authtok=$(grep -E "^passwords+requireds+pam_pwhistory.so" /etc/pam.d/common-password | grep -E "use_authtok")\n\nif [[ -z "$pwhistory_use_authtok" ]]; then\n    echo "Check: Ensure pam_pwhistory includes use_authtok"\n    echo "Status: Fail"\n    echo "Current Value: pam_pwhistory does not include use_authtok."\n    echo "Expected Value: pam_pwhistory should include use_authtok."\n    echo "Recommendation: Add use_authtok to pam_pwhistory."\n    echo "Remediation:"\n    echo "# sudo nano /etc/pam.d/common-password"\n    echo "Add the following option to the line: use_authtok"\nelse\n    echo "Check: Ensure pam_pwhistory includes use_authtok"\n    echo "Status: Pass"\n    echo "Current Value: pam_pwhistory includes use_authtok."\n    echo "Expected Value: pam_pwhistory should include use_authtok."\n    echo "Recommendation: No remediation required."\nfi', '#!/bin/bash\n\n# Check if pam_unix includes nullok\npam_unix_nullok=$(grep -E "^passwords+requireds+pam_unix.so" /etc/pam.d/common-password | grep -E "nullok")\n\nif [[ -n "$pam_unix_nullok" ]]; then\n    echo "Check: Ensure pam_unix does not include nullok"\n    echo "Status: Fail"\n    echo "Current Value: pam_unix includes nullok."\n    echo "Expected Value: pam_unix should not include nullok."\n    echo "Recommendation: Remove nullok from pam_unix."\n    echo "Remediation:"\n    echo "# sudo nano /etc/pam.d/common-password"\n    echo "Remove "nullok" option if present in the line starting with pam_unix.so"\nelse\n    echo "Check: Ensure pam_unix does not include nullok"\n    echo "Status: Pass"\n    echo "Current Value: pam_unix does not include nullok."\n    echo "Expected Value: pam_unix should not include nullok."\n    echo "Recommendation: No remediation required."\nfi', '#!/bin/bash\n\n# Check if pam_unix includes remember\npam_unix_remember=$(grep -E "^passwords+requireds+pam_unix.so" /etc/pam.d/common-password | grep -E "remember")\n\nif [[ -n "$pam_unix_remember" ]]; then\n    echo "Check: Ensure pam_unix does not include remember"\n    echo "Status: Fail"\n    echo "Current Value: pam_unix includes remember."\n    echo "Expected Value: pam_unix should not include remember."\n    echo "Recommendation: Remove remember from pam_unix."\n    echo "Remediation:"\n    echo "# sudo nano /etc/pam.d/common-password"\n    echo "Remove "remember" option if present in the line starting with pam_unix.so"\nelse\n    echo "Check: Ensure pam_unix does not include remember"\n    echo "Status: Pass"\n    echo "Current Value: pam_unix does not include remember."\n    echo "Expected Value: pam_unix should not include remember."\n    echo "Recommendation: No remediation required."\nfi', '#!/bin/bash\n\n# Check if pam_unix includes a strong password hashing algorithm\npam_unix_hash=$(grep -E "^passwords+requireds+pam_unix.so" /etc/pam.d/common-password | grep -E "sha512")\n\nif [[ -z "$pam_unix_hash" ]]; then\n    echo "Check: Ensure pam_unix includes a strong password hashing algorithm"\n    echo "Status: Fail"\n    echo "Current Value: pam_unix does not include a strong password hashing algorithm."\n    echo "Expected Value: pam_unix should include a strong hashing algorithm (e.g., sha512)."\n    echo "Recommendation: Use sha512 for strong password hashing."\n    echo "Remediation:"\n    echo "# sudo nano /etc/pam.d/common-password"\n    echo "Ensure the line contains "sha512" in the pam_unix.so configuration."\nelse\n    echo "Check: Ensure pam_unix includes a strong password hashing algorithm"\n    echo "Status: Pass"\n    echo "Current Value: pam_unix includes a strong hashing algorithm."\n    echo "Expected Value: pam_unix should include a strong password hashing algorithm."\n    echo "Recommendation: No remediation required."\nfi', '#!/bin/bash\n\n# Check if pam_unix includes use_authtok\npam_unix_use_authtok=$(grep -E "^passwords+requireds+pam_unix.so" /etc/pam.d/common-password | grep -E "use_authtok")\n\nif [[ -z "$pam_unix_use_authtok" ]]; then\n    echo "Check: Ensure pam_unix includes use_authtok"\n    echo "Status: Fail"\n    echo "Current Value: pam_unix does not include use_authtok."\n    echo "Expected Value: pam_unix should include use_authtok."\n    echo "Recommendation: Add use_authtok to pam_unix."\n    echo "Remediation:"\n    echo "# sudo nano /etc/pam.d/common-password"\n    echo "Ensure the line contains "use_authtok" in the pam_unix.so configuration."\nelse\n    echo "Check: Ensure pam_unix includes use_authtok"\n    echo "Status: Pass"\n    echo "Current Value: pam_unix includes use_authtok."\n    echo "Expected Value: pam_unix should include use_authtok."\n    echo "Recommendation: No remediation required."\nfi', '#!/bin/bash\n\necho "Check: Ensure auditd packages are installed"\n\n# Check if auditd is installed\nif dpkg -l | grep -q auditd; then\n    echo "Status: Pass"\n    echo "Current Value: auditd package is installed."\n    echo "Expected Value: auditd package should be installed."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Status: Fail"\n    echo "Current Value: auditd package is not installed."\n    echo "Expected Value: auditd package should be installed."\n    echo "Recommendation: Install the auditd package."\n    echo "Remediation:"\n    echo "# To install auditd, run: sudo apt install auditd"\n    echo "# To start and enable the auditd service, run:"\n    echo "# sudo systemctl enable auditd"\n    echo "# sudo systemctl start auditd"\nfi\n', '#!/bin/bash\n\necho "Check: Ensure audit tools group owner is configured"\n\n# List of audit tools to check\naudit_tools=("/sbin/auditctl" "/sbin/ausearch" "/sbin/aureport" "/sbin/autrace" "/sbin/auditd" "/sbin/auditrules")\n\n# Initialize variables\nstatus="Pass"\n\nfor tool in "${audit_tools[@]}"; do\n    if [ -e "$tool" ]; then\n        group_owner=$(stat -c "%G" "$tool")\n        if [ "$group_owner" != "root" ]; then\n            echo "Status: Fail"\n            echo "Current Value: Group owner of $tool is $group_owner."\n            echo "Expected Value: Group owner of audit tools should be root."\n            echo "Recommendation: Configure the group owner of $tool to root."\n            echo "Remediation:"\n            echo "# chgrp root $tool"\n            status="Fail"\n        fi\n    else\n        echo "Status: Fail"\n        echo "Current Value: $tool does not exist on the system."\n        echo "Expected Value: Audit tool $tool should exist and have root as its group owner."\n        echo "Recommendation: Ensure the audit tool $tool is installed and has root as its group owner."\n        echo "Remediation:"\n        echo "# Install the audit tool or verify its location."\n        status="Fail"\n    fi\ndone\n\nif [ "$status" == "Pass" ]; then\n    echo "Status: Pass"\n    echo "Current Value: Group owner of all audit tools is configured as root."\n    echo "Expected Value: Group owner of audit tools should be root."\n    echo "Recommendation: No remediation required."\nfi\n', '#!/bin/bash\n\necho "Check: Ensure auditd service is enabled and active"\n\n# Check if auditd service is enabled and active\nif systemctl is-enabled auditd >/dev/null 2>&1 && systemctl is-active auditd >/dev/null 2>&1; then\n    echo "Status: Pass"\n    echo "Current Value: auditd service is enabled and active."\n    echo "Expected Value: auditd service should be enabled and active."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Status: Fail"\n    echo "Current Value: auditd service is either not enabled or not active."\n    echo "Expected Value: auditd service should be enabled and active."\n    echo "Recommendation: Enable and start the auditd service."\n    echo "Remediation:"\n    echo "# To enable auditd, run: sudo systemctl enable auditd"\n    echo "# To start auditd, run: sudo systemctl start auditd"\nfi\n', '#!/bin/bash\n\necho "Check: Ensure audit tools owner is configured"\n\n# List of audit tools to check\naudit_tools=("/sbin/auditctl" "/sbin/ausearch" "/sbin/aureport" "/sbin/autrace" "/sbin/auditd" "/sbin/auditrules")\n\n# Initialize variables\nstatus="Pass"\n\nfor tool in "${audit_tools[@]}"; do\n    if [ -e "$tool" ]; then\n        owner=$(stat -c "%U" "$tool")\n        if [ "$owner" != "root" ]; then\n            echo "Status: Fail"\n            echo "Current Value: Owner of $tool is $owner."\n            echo "Expected Value: Owner of audit tools should be root."\n            echo "Recommendation: Configure the owner of $tool to root."\n            echo "Remediation:"\n            echo "# chown root $tool"\n            status="Fail"\n        fi\n    else\n        echo "Status: Fail"\n        echo "Current Value: $tool does not exist on the system."\n        echo "Expected Value: Audit tool $tool should exist and have root as its owner."\n        echo "Recommendation: Ensure the audit tool $tool is installed and has root as its owner."\n        echo "Remediation:"\n        echo "# Install the audit tool or verify its location."\n        status="Fail"\n    fi\ndone\n\nif [ "$status" == "Pass" ]; then\n    echo "Status: Pass"\n    echo "Current Value: Owner of all audit tools is configured as root."\n    echo "Expected Value: Owner of audit tools should be root."\n    echo "Recommendation: No remediation required."\nfi\n', '#!/bin/bash\n\necho "Check: Ensure auditing for processes that start prior to auditd is enabled"\n\n# Check if auditing for processes that start before auditd is enabled (boot-time auditing)\nif grep -q "audit=1" /proc/cmdline; then\n    echo "Status: Pass"\n    echo "Current Value: Auditing for processes that start prior to auditd is enabled."\n    echo "Expected Value: Auditing for processes that start prior to auditd should be enabled."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Status: Fail"\n    echo "Current Value: Auditing for processes that start prior to auditd is not enabled."\n    echo "Expected Value: Auditing for processes that start prior to auditd should be enabled."\n    echo "Recommendation: Enable boot-time auditing."\n    echo "Remediation:"\n    echo "# Add \\\'audit=1\\\' to the kernel boot parameters in /etc/default/grub"\n    echo "# Update grub configuration: sudo update-grub"\n    echo "# Reboot the system for the changes to take effect."\nfi\n', '#!/bin/bash\n\necho "Check: Ensure audit tools mode is configured"\n\n# List of audit tools to check\naudit_tools=("/sbin/auditctl" "/sbin/ausearch" "/sbin/aureport" "/sbin/autrace" "/sbin/auditd" "/sbin/auditrules")\n\n# Desired file permissions (mode)\nexpected_mode="0750"\n\n# Initialize variables\nstatus="Pass"\n\nfor tool in "${audit_tools[@]}"; do\n    if [ -e "$tool" ]; then\n        current_mode=$(stat -c "%a" "$tool")\n        if [ "$current_mode" != "$expected_mode" ]; then\n            echo "Status: Fail"\n            echo "Current Value: Mode of $tool is $current_mode."\n    echo "Expected Value: Mode of audit tools should be $expected_mode."\n            echo "Recommendation: Configure the mode of $tool to $expected_mode."\n            echo "Remediation:"\n            echo "# chmod $expected_mode $tool"\n            status="Fail"\n        fi\n    else\n        echo "Status: Fail"\n        echo "Current Value: $tool does not exist on the system."\n        echo "Expected Value: Audit tool $tool should exist and have mode $expected_mode."\n        echo "Recommendation: Ensure the audit tool $tool is installed and configured with mode $expected_mode."\n        echo "Remediation:"\n        echo "# Install the audit tool or verify its location."\n        status="Fail"\n    fi\ndone\n\nif [ "$status" == "Pass" ]; then\n    echo "Status: Pass"\n    echo "Current Value: Mode of all audit tools is configured as $expected_mode."\n    echo "Expected Value: Mode of audit tools should be $expected_mode."\n    echo "Recommendation: No remediation required."\nfi\n', '#!/bin/bash\n\necho "Check: Ensure audit configuration files group owner is configured"\n\n# List of audit configuration files to check\nconfig_files=("/etc/audit/auditd.conf" "/etc/audit/audit.rules" "/etc/audit/rules.d")\n\n# Initialize variables\nstatus="Pass"\n\nfor file in "${config_files[@]}"; do\n    if [ -e "$file" ]; then\n        group_owner=$(stat -c "%G" "$file")\n        if [ "$group_owner" != "root" ]; then\n            echo "Status: Fail"\n            echo "Current Value: Group owner of $file is $group_owner."\n            echo "Expected Value: Group owner of audit configuration files should be root."\n            echo "Recommendation: Configure the group owner of $file to root."\n            echo "Remediation:"\n            echo "# chgrp root $file"\n            status="Fail"\n        fi\n    else\n        echo "Status: Fail"\n        echo "Current Value: $file does not exist on the system."\n        echo "Expected Value: Audit configuration file $file should exist and have root as its group owner."\n        echo "Recommendation: Ensure the audit configuration file $file is present and has root as its group owner."\n        echo "Remediation:"\n        echo "# Verify the file location or reinstall the audit package."\n        status="Fail"\n    fi\ndone\n\nif [ "$status" == "Pass" ]; then\n    echo "Status: Pass"\n    echo "Current Value: Group owner of all audit configuration files is configured as root."\n    echo "Expected Value: Group owner of audit configuration files should be root."\n    echo "Recommendation: No remediation required."\nfi\n', '#!/bin/bash\n\necho "Check: Ensure audit_backlog_limit is sufficient"\n\n# Check the current value of audit_backlog_limit\ncurrent_backlog_limit=$(sysctl -n kernel.audit_backlog_limit)\n\n# Define the minimum required backlog limit\nmin_backlog_limit=8192\n\n# Check if the backlog limit is sufficient\nif [ "$current_backlog_limit" -ge "$min_backlog_limit" ]; then\n    echo "Status: Pass"\n    echo "Current Value: audit_backlog_limit is $current_backlog_limit, which is sufficient."\n    echo "Expected Value: audit_backlog_limit should be at least $min_backlog_limit."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Status: Fail"\n    echo "Current Value: audit_backlog_limit is $current_backlog_limit, which is less than the minimum required ($min_backlog_limit)."\n    echo "Expected Value: audit_backlog_limit should be at least $min_backlog_limit."\n    echo "Recommendation: Increase the audit_backlog_limit."\n    echo "Remediation:"\n    echo "# To increase the audit_backlog_limit, run:"\n    echo "# sudo sysctl -w kernel.audit_backlog_limit=$min_backlog_limit"\n    echo "# To make this change permanent, add the following line to /etc/sysctl.conf:"\n    echo "# kernel.audit_backlog_limit=$min_backlog_limit"\n    echo "# Then run: sudo sysctl -p"\nfi\n', '#!/bin/bash\n\necho "Check: Ensure audit configuration files owner is configured"\n\n# List of audit configuration files to check\nconfig_files=("/etc/audit/auditd.conf" "/etc/audit/audit.rules" "/etc/audit/rules.d")\n\n# Initialize variables\nstatus="Pass"\n\nfor file in "${config_files[@]}"; do\n    if [ -e "$file" ]; then\n        owner=$(stat -c "%U" "$file")\n        if [ "$owner" != "root" ]; then\n            echo "Status: Fail"\n            echo "Current Value: Owner of $file is $owner."\n            echo "Expected Value: Owner of audit configuration files should be root."\n   echo "Recommendation: Configure the owner of $file to root."\n            echo "Remediation:"\n            echo "# chown root $file"\n            status="Fail"\n        fi\n    else\n        echo "Status: Fail"\n        echo "Current Value: $file does not exist on the system."\n        echo "Expected Value: Audit configuration file $file should exist and have root as its owner."\n        echo "Recommendation: Ensure the audit configuration file $file is present and has root as its owner."\n        echo "Remediation:"\n        echo "# Verify the file location or reinstall the audit package."\n        status="Fail"\n    fi\ndone\n\nif [ "$status" == "Pass" ]; then\n    echo "Status: Pass"\n    echo "Current Value: Owner of all audit configuration files is configured as root."\n    echo "Expected Value: Owner of audit configuration files should be root."\n    echo "Recommendation: No remediation required."\nfi\n', '#!/bin/bash\n\necho "Check: Ensure audit configuration files mode is configured"\n\n# List of audit configuration files to check\nconfig_files=("/etc/audit/auditd.conf" "/etc/audit/audit.rules" "/etc/audit/rules.d")\n\n# Desired file permissions (mode)\nexpected_mode="0640"\n\n# Initialize variables\nstatus="Pass"\n\nfor file in "${config_files[@]}"; do\n    if [ -e "$file" ]; then\n        current_mode=$(stat -c "%a" "$file")\n        if [ "$current_mode" != "$expected_mode" ]; then\n            echo "Status: Fail"\n            echo "Current Value: Mode of $file is $current_mode."\n    echo "Expected Value: Mode of audit configuration files should be $expected_mode."\n            echo "Recommendation: Configure the mode of $file to $expected_mode."\n            echo "Remediation:"\n            echo "# chmod $expected_mode $file"\n            status="Fail"\n        fi\n    else\n        echo "Status: Fail"\n        echo "Current Value: $file does not exist on the system."\n        echo "Expected Value: Audit configuration file $file should exist and have mode $expected_mode."\n        echo "Recommendation: Ensure the audit configuration file $file is present and configured with mode $expected_mode."\n        echo "Remediation:"\n        echo "# Verify the file location or reinstall the audit package."\n        status="Fail"\n    fi\ndone\n\nif [ "$status" == "Pass" ]; then\n    echo "Status: Pass"\n    echo "Current Value: Mode of all audit configuration files is configured as $expected_mode."\n    echo "Expected Value: Mode of audit configuration files should be $expected_mode."\n    echo "Recommendation: No remediation required."\nfi\n', '#!/bin/bash\n\necho "Check: Ensure the audit log file directory mode is configured"\n\n# Audit log directory\naudit_log_dir="/var/log/audit"\n\n# Desired directory permissions (mode)\nexpected_mode="0750"\n\nif [ -d "$audit_log_dir" ]; then\n    current_mode=$(stat -c "%a" "$audit_log_dir")\n    if [ "$current_mode" != "$expected_mode" ]; then\n        echo "Status: Fail"\n        echo "Current Value: Mode of $audit_log_dir is $current_mode."\n        echo "Expected Value: Mode of audit log file directory should be $expected_mode."\n        echo "Recommendation: Configure the mode of $audit_log_dir to $expected_mode."\n        echo "Remediation:"\n        echo "# chmod $expected_mode $audit_log_dir"\n    else\n        echo "Status: Pass"\n        echo "Current Value: Mode of $audit_log_dir is configured as $expected_mode."\n        echo "Recommendation: No remediation required."\n    fi\nelse\n    echo "Status: Fail"\n    echo "Current Value: $audit_log_dir does not exist on the system."\n    echo "Expected Value: $audit_log_dir should exist with mode $expected_mode."\n    echo "Recommendation: Ensure the audit log directory is created and configured with the correct mode."\n    echo "Remediation:"\n    echo "# mkdir -p $audit_log_dir && chmod $expected_mode $audit_log_dir"\nfi\n', '#!/bin/bash\n\necho "Check: Ensure all AppArmor profiles are enforcing"\n\n# Check the status of AppArmor profiles\nif aa-status 2>/dev/null | grep -q "profiles are in enforce mode" && \n   ! aa-status 2>/dev/null | grep -q "profiles are in complain mode"; then\n    echo "Status: Pass"\n    echo "Current Value: All AppArmor profiles are in enforcing mode."\n    echo "Expected Value: All AppArmor profiles should be in enforcing mode."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Status: Fail"\n    echo "Current Value: Some AppArmor profiles are not in enforcing mode."\n    echo "Expected Value: All AppArmor profiles should be in enforcing mode."\n    echo "Recommendation: Set all AppArmor profiles to enforcing mode."\n    echo "Remediation:"\n    echo "# sudo aa-enforce /etc/apparmor.d/*"\n    echo "# sudo systemctl restart apparmor"\nfi\n', '#!/bin/bash\n\necho "Check: Ensure audit log files group owner is configured"\n\n# Audit log files directory\naudit_log_dir="/var/log/audit"\n\n# Expected group owner\nexpected_group="root"\n\nstatus="Pass"\n\nif [ -d "$audit_log_dir" ]; then\n    for file in "$audit_log_dir"/*; do\n        if [ -e "$file" ]; then\n            group_owner=$(stat -c "%G" "$file")\n            if [ "$group_owner" != "$expected_group" ]; then\n                echo "Status: Fail"\n   echo "Current Value: Group owner of $file is $group_owner."\n                echo "Expected Value: Group owner of audit log files should be $expected_group."\n                echo "Recommendation: Configure the group owner of $file to $expected_group."\n                echo "Remediation:"\n                echo "# chgrp $expected_group $file"\n    status="Fail"\n            fi\n        fi\n    done\nelse\n    echo "Status: Fail"\n    echo "Current Value: Audit log directory $audit_log_dir does not exist."\n    echo "Expected Value: Audit log directory should exist with files owned by group $expected_group."\n    echo "Recommendation: Ensure the audit log directory exists and files have the correct group ownership."\n    echo "Remediation:"\n    echo "# mkdir -p $audit_log_dir && chgrp -R $expected_group $audit_log_dir"\n    status="Fail"\nfi\n\nif [ "$status" == "Pass" ]; then\n    echo "Status: Pass"\n    echo "Current Value: Group owner of all audit log files is configured as $expected_group."\n    echo "Recommendation: No remediation required."\nfi\n', '#!/bin/bash\n\necho "Check: Ensure GDM automatic mounting of removable media is disabled"\n\n# Check the status of automatic mounting in GDM\nif gsettings get org.gnome.desktop.media-handling automount | grep -q "false" && \n   gsettings get org.gnome.desktop.media-handling automount-open | grep -q "false"; then\n    echo "Status: Pass"\n    echo "Current Value: Automatic mounting of removable media is disabled in GDM."\n    echo "Expected Value: Automatic mounting of removable media should be disabled in GDM."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Status: Fail"\n    echo "Current Value: Automatic mounting of removable media is enabled in GDM."\n    echo "Expected Value: Automatic mounting of removable media should be disabled in GDM."\n    echo "Recommendation: Disable automatic mounting of removable media in GDM."\n    echo "Remediation:"\n    echo "# gsettings set org.gnome.desktop.media-handling automount false"\n    echo "# gsettings set org.gnome.desktop.media-handling automount-open false"\nfi\n', '#!/bin/bash\n\necho "Check: Ensure audit log files owner is configured"\n\n# Audit log files directory\naudit_log_dir="/var/log/audit"\n\n# Expected owner\nexpected_owner="root"\n\nstatus="Pass"\n\nif [ -d "$audit_log_dir" ]; then\n    for file in "$audit_log_dir"/*; do\n        if [ -e "$file" ]; then\n            owner=$(stat -c "%U" "$file")\n  if [ "$owner" != "$expected_owner" ]; then\n                echo "Status: Fail"\n                echo "Current Value: Owner of $file is $owner."\n                echo "Expected Value: Owner of audit log files should be $expected_owner."\n                echo "Recommendation: Configure the owner of $file to $expected_owner."\n                echo "Remediation:"\n                echo "# chown $expected_owner $file"\n                status="Fail"\n            fi\n        fi\n    done\nelse\n    echo "Status: Fail"\n    echo "Current Value: Audit log directory $audit_log_dir does not exist."\n    echo "Expected Value: Audit log directory should exist with files owned by $expected_owner."\n    echo "Recommendation: Ensure the audit log directory exists and files have the correct ownership."\n    echo "Remediation:"\n    echo "# mkdir -p $audit_log_dir && chown -R $expected_owner $audit_log_dir"\n    status="Fail"\nfi\n\nif [ "$status" == "Pass" ]; then\n    echo "Status: Pass"\n    echo "Current Value: Owner of all audit log files is configured as $expected_owner."\n    echo "Recommendation: No remediation required."\nfi\n', '#!/bin/bash\n\necho "Check: Ensure audit log files mode is configured"\n\n# Audit log files directory\naudit_log_dir="/var/log/audit"\n\n# Desired file permissions (mode)\nexpected_mode="0600"\n\nstatus="Pass"\n\nif [ -d "$audit_log_dir" ]; then\n    for file in "$audit_log_dir"/*; do\n        if [ -e "$file" ]; then\n            current_mode=$(stat -c "%a" "$file")\n            if [ "$current_mode" != "$expected_mode" ]; then\n                echo "Status: Fail"\n       echo "Current Value: Mode of $file is $current_mode."\n                echo "Expected Value: Mode of audit log files should be $expected_mode."\n                echo "Recommendation: Configure the mode of $file to $expected_mode."\n                echo "Remediation:"\n                echo "# chmod $expected_mode $file"\n                status="Fail"\n            fi\n        fi\n    done\nelse\n    echo "Status: Fail"\n    echo "Current Value: Audit log directory $audit_log_dir does not exist."\n    echo "Expected Value: Audit log directory should exist with files having mode $expected_mode."\n    echo "Recommendation: Ensure the audit log directory exists and files have the correct mode."\n    echo "Remediation:"\n    echo "# mkdir -p $audit_log_dir && chmod -R $expected_mode $audit_log_dir"\n    status="Fail"\nfi\n\nif [ "$status" == "Pass" ]; then\n    echo "Status: Pass"\n    echo "Current Value: Mode of all audit log files is configured as $expected_mode."\n    echo "Recommendation: No remediation required."\nfi\n', '#!/bin/bash\n\necho "Check: Ensure GDM disabling automatic mounting of removable media is not overridden"\n\n# Check if the automount and automount-open settings are locked\nif gsettings writable org.gnome.desktop.media-handling automount | grep -q "false" && \\\\\n   gsettings writable org.gnome.desktop.media-handling automount-open | grep -q "false"; then\n    echo "Status: Pass"\n    echo "Current Value: GDM disabling of automatic mounting of removable media is not overridden."\n    echo "Expected Value: GDM disabling of automatic mounting of removable media should not be overridden."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Status: Fail"\n    echo "Current Value: GDM disabling of automatic mounting of removable media is overridden."\n    echo "Expected Value: GDM disabling of automatic mounting of removable media should not be overridden."\n    echo "Recommendation: Lock the settings to prevent overrides."\n    echo "Remediation:"\n    echo "# dconf lock /org/gnome/desktop/media-handling/automount"\n    echo "# dconf lock /org/gnome/desktop/media-handling/automount-open"\nfi\n', '#!/bin/bash\n\necho "Check: Ensure the running and on-disk configuration is the same"\n\n# Check if the running audit rules match the on-disk configuration\nrunning_rules=$(auditctl -l)\non_disk_rules=$(cat /etc/audit/rules.d/audit.rules)\n\nif [ "$running_rules" == "$on_disk_rules" ]; then\n    echo "Status: Pass"\n    echo "Current Value: Running and on-disk audit configuration are the same."\n    echo "Expected Value: Running and on-disk audit configuration should be the same."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Status: Fail"\n    echo "Current Value: Running and on-disk audit configuration are different."\n    echo "Expected Value: Running and on-disk audit configuration should be the same."\n    echo "Recommendation: Ensure the audit rules are the same on both running and on-disk configurations."\n    echo "Remediation:"\n    echo "# augenrules --load"\nfi\n', '#!/bin/bash\n\necho "Check: Ensure the audit configuration is immutable"\n\n# Check if audit configuration is immutable\nconfig_file="/etc/audit/rules.d/audit.rules"\n\nif chattr -l "$config_file" | grep -q \\\'i\\\'; then\n    echo "Status: Pass"\n    echo "Current Value: Audit configuration is immutable."\n    echo "Expected Value: Audit configuration should be immutable."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Status: Fail"\n    echo "Current Value: Audit configuration is not immutable."\n    echo "Expected Value: Audit configuration should be immutable."\n    echo "Recommendation: Set the immutable flag on the audit configuration file."\n    echo "Remediation:"\n    echo "# chattr +i $config_file"\nfi\n', '#!/bin/bash\n\necho "Check: Ensure users must provide a password for privilege escalation"\n\n# Check if the sudoers file or included files allow passwordless sudo\nif sudo grep -qP \\\'^\\\\s*Defaults\\\\s+!?\\\\s*authenticate\\\' /etc/sudoers && \\\\\n   ! sudo grep -qP \\\'^\\\\s*Defaults\\\\s+authenticate\\\' /etc/sudoers; then\n    echo "Status: Fail"\n    echo "Current Value: Some users can perform privilege escalation without providing a password."\n    echo "Expected Value: All users should be required to provide a password for privilege escalation."\n    echo "Recommendation: Enforce password authentication for privilege escalation."\n    echo "Remediation:"\n    echo "# Edit the sudoers file by running: sudo visudo"\n    echo "# Ensure the line \\\'Defaults authenticate\\\' is present and not commented out."\n    echo "# Remove or comment out lines with \\\'Defaults !authenticate\\\'."\nelse\n    echo "Status: Pass"\n    echo "Current Value: All users are required to provide a password for privilege escalation."\n    echo "Expected Value: All users should be required to provide a password for privilege escalation."\n    echo "Recommendation: No remediation required."\nfi\n', '#!/bin/bash\n\necho "Check: Ensure kernel module loading, unloading, and modification is collected"\n\n# Audit rule to be checked\naudit_rule="-w /sbin/insmod -p x -k modules"\naudit_rule2="-w /sbin/rmmod -p x -k modules"\naudit_rule3="-w /sbin/modprobe -p x -k modules"\n\nif auditctl -l | grep -q "key=modules"; then\n    echo "Status: Pass"\n    echo "Current Value: Kernel module loading, unloading, and modification events are being collected."\n    echo "Expected Value: Kernel module loading, unloading, and modification events should be collected."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Status: Fail"\n    echo "Current Value: Kernel module loading, unloading, and modification events are not being collected."\n    echo "Expected Value: Kernel module loading, unloading, and modification events should be collected."\n    echo "Recommendation: Add the following rules to /etc/audit/rules.d/audit.rules."\n    echo "Remediation:"\n    echo "# echo \\\'$audit_rule\\\' >> /etc/audit/rules.d/audit.rules"\n    echo "# echo \\\'$audit_rule2\\\' >> /etc/audit/rules.d/audit.rules"\n    echo "# echo \\\'$audit_rule3\\\' >> /etc/audit/rules.d/audit.rules"\n    echo "# augenrules --load"\nfi\n', '#!/bin/bash\n\necho "Check: Ensure successful and unsuccessful attempts to use the usermod command are recorded"\n\n# Audit rule to be checked\naudit_rule="-a always,exit -F arch=b64 -S usermod -F auid>=1000 -F auid!=unset -k user_mgmt"\n\nif auditctl -l | grep -q "key=user_mgmt"; then\n    echo "Status: Pass"\n    echo "Current Value: Attempts to use the usermod command are being recorded."\n    echo "Expected Value: Attempts to use the usermod command should be recorded."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Status: Fail"\n    echo "Current Value: Attempts to use the usermod command are not being recorded."\n    echo "Expected Value: Attempts to use the usermod command should be recorded."\n    echo "Recommendation: Add the following rule to /etc/audit/rules.d/audit.rules."\n    echo "Remediation:"\n    echo "# echo \\\'$audit_rule\\\' >> /etc/audit/rules.d/audit.rules"\n    echo "# augenrules --load"\nfi\n', '#!/bin/bash\n\necho "Check: Ensure password failed attempts lockout includes the root account"\n\n# Variables for PAM configuration files\nAUTH_FILE="/etc/pam.d/common-auth"\nACCOUNT_FILE="/etc/pam.d/common-account"\n\n# Check if pam_tally2 or pam_faillock is configured for lockout\nif grep -qE "pam_tally2|pam_faillock" "$AUTH_FILE" && \\\\\n   grep -qE "pam_tally2|pam_faillock" "$ACCOUNT_FILE"; then\n    echo "Status: Pass"\n    echo "Current Value: Failed password attempts result in lockout, including the root account."\n    echo "Expected Value: Failed password attempts should lock out all accounts, including root."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Status: Fail"\n    echo "Current Value: Failed password attempts lockout is not configured for all accounts or the root account."\n    echo "Expected Value: Failed password attempts should lock out all accounts, including root."\n    echo "Recommendation: Configure PAM to enforce lockout for all accounts, including root."\n    echo "Remediation:"\n    echo "1. Edit the /etc/pam.d/common-auth file to include the following line:"\n    echo "   auth required pam_faillock.so preauth silent deny=5 unlock_time=900 root_unlock_time=900"\n    echo "2. Edit the /etc/pam.d/common-account file to include the following line:"\n    echo "   account required pam_faillock.so"\n    echo "3. Restart any services that rely on PAM authentication, or reboot the system."\nfi\n', '#!/bin/bash\n\necho "Check: Ensure successful and unsuccessful attempts to use the chacl command are recorded"\n\n# Audit rule to be checked\naudit_rule="-a always,exit -F arch=b64 -S chacl -F auid>=1000 -F auid!=unset -k perm_chng"\n\nif auditctl -l | grep -q "key=perm_chng"; then\n    echo "Status: Pass"\n    echo "Current Value: Attempts to use the chacl command are being recorded."\n    echo "Expected Value: Attempts to use the chacl command should be recorded."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Status: Fail"\n    echo "Current Value: Attempts to use the chacl command are not being recorded."\n    echo "Expected Value: Attempts to use the chacl command should be recorded."\n    echo "Recommendation: Add the following rule to /etc/audit/rules.d/audit.rules."\n    echo "Remediation:"\n    echo "# echo \\\'$audit_rule\\\' >> /etc/audit/rules.d/audit.rules"\n    echo "# augenrules --load"\nfi\n', '#!/bin/bash\n\necho "Check: Ensure successful and unsuccessful attempts to use the setfacl command are recorded"\n\n# Audit rule to be checked\naudit_rule="-a always,exit -F arch=b64 -S setfacl -F auid>=1000 -F auid!=unset -k perm_chng"\n\nif auditctl -l | grep -q "key=perm_chng"; then\n    echo "Status: Pass"\n    echo "Current Value: Attempts to use the setfacl command are being recorded."\n    echo "Expected Value: Attempts to use the setfacl command should be recorded."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Status: Fail"\n    echo "Current Value: Attempts to use the setfacl command are not being recorded."\n    echo "Expected Value: Attempts to use the setfacl command should be recorded."\n    echo "Recommendation: Add the following rule to /etc/audit/rules.d/audit.rules."\n    echo "Remediation:"\n    echo "# echo \\\'$audit_rule\\\' >> /etc/audit/rules.d/audit.rules"\n    echo "# augenrules --load"\nfi\n', '#!/bin/bash\n\necho "Check: Ensure successful and unsuccessful attempts to use the chcon command are recorded"\n\n# Audit rule to be checked\naudit_rule="-a always,exit -F arch=b64 -S chcon -F auid>=1000 -F auid!=unset -k perm_chng"\n\nif auditctl -l | grep -q "key=perm_chng"; then\n    echo "Status: Pass"\n    echo "Current Value: Attempts to use the chcon command are being recorded."\n    echo "Expected Value: Attempts to use the chcon command should be recorded."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Status: Fail"\n    echo "Current Value: Attempts to use the chcon command are not being recorded."\n    echo "Expected Value: Attempts to use the chcon command should be recorded."\n    echo "Recommendation: Add the following rule to /etc/audit/rules.d/audit.rules."\n    echo "Remediation:"\n    echo "# echo \\\'$audit_rule\\\' >> /etc/audit/rules.d/audit.rules"\n    echo "# augenrules --load"\nfi\n', '#!/bin/bash\n\necho "Check: Ensure minimum password age is configured"\n\n# Define the minimum password age requirement\nMIN_AGE_REQUIRED=1\n\n# Check the current minimum password age for all users\nif awk -F: -v min_age="$MIN_AGE_REQUIRED" \\\'($4 < min_age) {print $1, $4}\\\' /etc/shadow | grep -q \\\'.\\\'; then\n    echo "Status: Fail"\n    echo "Current Value: Some users have a minimum password age less than $MIN_AGE_REQUIRED."\n    echo "Expected Value: Minimum password age for all users should be at least $MIN_AGE_REQUIRED."\n    echo "Recommendation: Set a minimum password age for all users to prevent frequent password changes."\n    echo "Remediation:"\n    echo "# To set the minimum password age for a specific user, use:"\n    echo "# sudo chage --mindays $MIN_AGE_REQUIRED <username>"\n    echo "# To enforce this for all users, update the /etc/login.defs file by setting:"\n    echo "# PASS_MIN_DAYS $MIN_AGE_REQUIRED"\nelse\n    echo "Status: Pass"\n    echo "Current Value: All users have a minimum password age of at least $MIN_AGE_REQUIRED."\n    echo "Expected Value: Minimum password age for all users should be at least $MIN_AGE_REQUIRED."\n    echo "Recommendation: No remediation required."\nfi\n', '#!/bin/bash\n\necho "Check: Ensure events that modify the system\\\'s Mandatory Access Controls are collected"\n\n# Audit rule to be checked\naudit_rule="-w /etc/selinux/ -p wa -k MAC-policy"\n\nif auditctl -l | grep -q "key=MAC-policy"; then\n    echo "Status: Pass"\n    echo "Current Value: Events modifying the system\\\'s Mandatory Access Controls are being collected."\n    echo "Expected Value: Events modifying the system\\\'s Mandatory Access Controls should be collected."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Status: Fail"\n    echo "Current Value: Events modifying the system\\\'s Mandatory Access Controls are not being collected."\n    echo "Expected Value: Events modifying the system\\\'s Mandatory Access Controls should be collected."\n    echo "Recommendation: Add the following rule to /etc/audit/rules.d/audit.rules."\n    echo "Remediation:"\n    echo "# echo \\\'$audit_rule\\\' >> /etc/audit/rules.d/audit.rules"\n    echo "# augenrules --load"\nfi\n', '#!/bin/bash\n\necho "Check: Ensure file deletion events by users are collected"\n\n# Audit rule to be checked\naudit_rule="-a always,exit -F arch=b64 -S unlink,unlinkat,rename,renameat -F auid>=1000 -F auid!=unset -k delete"\n\nif auditctl -l | grep -q "key=delete"; then\n    echo "Status: Pass"\n    echo "Current Value: File deletion events by users are being collected."\n    echo "Expected Value: File deletion events by users should be collected."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Status: Fail"\n    echo "Current Value: File deletion events by users are not being collected."\n    echo "Expected Value: File deletion events by users should be collected."\n    echo "Recommendation: Add the following rule to /etc/audit/rules.d/audit.rules."\n    echo "Remediation:"\n    echo "# echo \\\'$audit_rule\\\' >> /etc/audit/rules.d/audit.rules"\n    echo "# augenrules --load"\nfi\n', '#!/bin/bash\n\necho "Check: Ensure nologin is not listed in /etc/shells"\n\n# Check if /etc/shells contains \\\'nologin\\\'\nif grep -q \\\'/nologin\\\' /etc/shells; then\n    echo "Status: Fail"\n    echo "Current Value: \\\'nologin\\\' is listed in /etc/shells."\n    echo "Expected Value: \\\'nologin\\\' should not be listed in /etc/shells."\n    echo "Recommendation: Remove \\\'nologin\\\' from /etc/shells."\n    echo "Remediation:"\n    echo "# To remove \\\'nologin\\\' from /etc/shells, run:"\n    echo "# sudo sed -i \\\'/\\\\/nologin/d\\\' /etc/shells"\nelse\n    echo "Status: Pass"\n    echo "Current Value: \\\'nologin\\\' is not listed in /etc/shells."\n    echo "Expected Value: \\\'nologin\\\' should not be listed in /etc/shells."\n    echo "Recommendation: No remediation required."\nfi\n', '#!/bin/bash\n\necho "Check: Ensure login and logout events are collected"\n\n# Audit rule to be checked\nrule_files=(\n    "/var/log/faillog"\n    "/var/log/lastlog"\n    "/var/log/tallylog"\n)\nexpected_permissions="0600"\nstatus="Pass"\n\nfor file in "${rule_files[@]}"; do\n    if [ -e "$file" ]; then\n        current_mode=$(stat -c "%a" "$file")\n        if [ "$current_mode" != "$expected_permissions" ]; then\n            echo "Status: Fail"\n            echo "Current Value: Mode of $file is $current_mode."\n            echo "Expected Value: Mode of $file should be $expected_permissions."\n            echo "Recommendation: Configure the mode of $file to $expected_permissions."\n            echo "Remediation:"\n            echo "# chmod $expected_permissions $file"\n            status="Fail"\n        fi\n    else\n        echo "Status: Fail"\n        echo "Current Value: $file does not exist."\n        echo "Expected Value: $file should exist with mode $expected_permissions."\n        echo "Recommendation: Create the file and configure the correct mode."\n        echo "Remediation:"\n        echo "# touch $file && chmod $expected_permissions $file"\n        status="Fail"\n    fi\ndone\n\nif [ "$status" == "Pass" ]; then\n    echo "Status: Pass"\n    echo "Current Value: Login and logout events are being collected, and files have correct permissions."\n    echo "Recommendation: No remediation required."\nfi\n', '#!/bin/bash\n\necho "Check: Ensure cryptographic mechanisms are used to protect the integrity of audit tools"\n\n# Check if AIDE (Advanced Intrusion Detection Environment) or other file integrity tools are installed\nif command -v aide >/dev/null 2>&1 || command -v samhain >/dev/null 2>&1; then\n    echo "Status: Pass"\n    echo "Current Value: File integrity monitoring tools (AIDE or Samhain) are installed."\n    echo "Expected Value: Cryptographic mechanisms should be used to protect the integrity of audit tools."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Status: Fail"\n    echo "Current Value: File integrity monitoring tools are not installed."\n    echo "Expected Value: Cryptographic mechanisms should be used to protect the integrity of audit tools."\n    echo "Recommendation: Install and configure a file integrity monitoring tool such as AIDE or Samhain."\n    echo "Remediation:"\n    echo "# To install AIDE, run: sudo apt install aide"\n    echo "# To configure AIDE, follow the instructions in /etc/aide/aide.conf."\n    echo "# To initialize AIDE, run: sudo aideinit"\n    echo "# To check the integrity of the system, run: sudo aide --check"\nfi\n', '#!/bin/bash\n\necho "Check: Ensure audit log storage size is configured"\n\n# Check if the audit log storage size is configured in /etc/audit/auditd.conf\nlog_file_size=$(grep -i "^max_log_file" /etc/audit/auditd.conf | awk \\\'{print $2}\\\')\n\n# Define the minimum required log file size in MB (e.g., 100MB)\nmin_log_file_size=100\n\nif [ -n "$log_file_size" ] && [ "$log_file_size" -ge "$min_log_file_size" ]; then\n    echo "Status: Pass"\n    echo "Current Value: audit log storage size is configured to $log_file_size MB."\n    echo "Expected Value: audit log storage size should be at least $min_log_file_size MB."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Status: Fail"\n    echo "Current Value: audit log storage size is configured to $log_file_size MB, which is less than the minimum required ($min_log_file_size MB)."\n    echo "Expected Value: audit log storage size should be at least $min_log_file_size MB."\n    echo "Recommendation: Increase the audit log storage size."\n    echo "Remediation:"\n    echo "# To configure the storage size, edit /etc/audit/auditd.conf and set:"\n    echo "# max_log_file = $min_log_file_size"\n    echo "# Restart the auditd service: sudo systemctl restart auditd"\nfi\n', '#!/bin/bash\n\necho "Check: Ensure audit logs are not automatically deleted"\n\n# Check if audit logs are set to not delete automatically in /etc/audit/auditd.conf\nauto_delete=$(grep -i "^max_log_file_action" /etc/audit/auditd.conf | awk \\\'{print $2}\\\')\n\nif [ "$auto_delete" != "keep_logs" ]; then\n    echo "Status: Fail"\n    echo "Current Value: audit logs are set to delete automatically."\n    echo "Expected Value: audit logs should not be automatically deleted."\n    echo "Recommendation: Set \\\'max_log_file_action\\\' to \\\'keep_logs\\\'."\n    echo "Remediation:"\n    echo "# To prevent automatic deletion of audit logs, edit /etc/audit/auditd.conf and set:"\n    echo "# max_log_file_action = keep_logs"\n    echo "# Restart the auditd service: sudo systemctl restart auditd"\nelse\n    echo "Status: Pass"\n    echo "Current Value: audit logs are not automatically deleted."\n    echo "Expected Value: audit logs should not be automatically deleted."\n    echo "Recommendation: No remediation required."\nfi\n', '#!/bin/bash\n\necho "Check: Ensure system is disabled when audit logs are full"\n\n# Check if system is configured to disable when audit logs are full in /etc/audit/auditd.conf\ndisable_on_full=$(grep -i "^space_left_action" /etc/audit/auditd.conf | awk \\\'{print $2}\\\')\n\nif [ "$disable_on_full" == "halt" ]; then\n    echo "Status: Pass"\n    echo "Current Value: system is disabled (halted) when audit logs are full."\n    echo "Expected Value: system should be disabled when audit logs are full."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Status: Fail"\n    echo "Current Value: system is not configured to halt when audit logs are full."\n    echo "Expected Value: system should be disabled when audit logs are full."\n    echo "Recommendation: Set \\\'space_left_action\\\' to \\\'halt\\\'."\n    echo "Remediation:"\n    echo "# To disable the system when audit logs are full, edit /etc/audit/auditd.conf and set:"\n    echo "# space_left_action = halt"\n    echo "# Restart the auditd service: sudo systemctl restart auditd"\nfi\n', '#!/bin/bash\n\necho "Check: Ensure system warns when audit logs are low on space"\n\n# Check if system is configured to warn when audit logs are low on space in /etc/audit/auditd.conf\nwarn_on_space_left=$(grep -i "^space_left" /etc/audit/auditd.conf | awk \\\'{print $2}\\\')\n\n# Define the minimum space left in bytes for warning\nmin_space_left=10485760  # 10MB in bytes\n\nif [ -n "$warn_on_space_left" ] && [ "$warn_on_space_left" -ge "$min_space_left" ]; then\n    echo "Status: Pass"\n    echo "Current Value: system is configured to warn when audit logs are low on space ($warn_on_space_left bytes)."\n    echo "Expected Value: system should warn when audit logs are low on space (at least $min_space_left bytes)."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Status: Fail"\n    echo "Current Value: system is not configured to warn when audit logs are low on space, or the warning threshold is insufficient."\n    echo "Expected Value: system should warn when audit logs are low on space."\n    echo "Recommendation: Set \\\'space_left\\\' to a value greater than or equal to $min_space_left bytes."\n    echo "Remediation:"\n    echo "# To configure the warning threshold, edit /etc/audit/auditd.conf and set:"\n    echo "# space_left = $min_space_left"\n    echo "# Restart the auditd service: sudo systemctl restart auditd"\nfi\n', '#!/bin/bash  echo "Check: Ensure changes to system administration scope (sudoers) are collected"  # Check if sudoers file changes are being logged if grep -q "sudo" /etc/audit/audit.rules; then     echo "Status: Pass"     echo "Current Value: Changes to sudoers file are being collected."     echo "Expected Value: Changes to sudoers file should be collected."     echo "Recommendation: No remediation required." else     echo "Status: Fail"     echo "Current Value: Changes to sudoers file are not being collected."     echo "Expected Value: Changes to sudoers file should be collected."     echo "Recommendation: Add rule to collect sudoers file changes."     echo "Remediation:"     echo "# To collect sudoers file changes, add the following rule to /etc/audit/rules.d/audit.rules:"     echo "# -w /etc/sudoers -p wa"     echo "# Then restart auditd: sudo systemctl restart auditd" fi', '#!/bin/bash\n\necho "Check: Ensure actions as another user are always logged"\n\n# Check if actions as another user (su command) are logged\nif grep -q "su" /etc/audit/audit.rules; then\n    echo "Status: Pass"\n    echo "Current Value: Actions as another user are being logged."\n    echo "Expected Value: Actions as another user should be logged."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Status: Fail"\n    echo "Current Value: Actions as another user are not being logged."\n    echo "Expected Value: Actions as another user should be logged."\n    echo "Recommendation: Add rule to log actions as another user."\n    echo "Remediation:"\n    echo "# To log actions as another user, add the following rule to /etc/audit/rules.d/audit.rules:"\n    echo "# -w /usr/bin/su -p x"\n    echo "# Then restart auditd: sudo systemctl restart auditd"\nfi\n', '#!/bin/bash\n\necho "Check: Ensure events that modify the sudo log file are collected"\n\n# Check if sudo log file changes are being logged\nif grep -q "sudo" /etc/audit/audit.rules; then\n    echo "Status: Pass"\n    echo "Current Value: Events that modify the sudo log file are being collected."\n    echo "Expected Value: Events that modify the sudo log file should be collected."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Status: Fail"\n    echo "Current Value: Events that modify the sudo log file are not being collected."\n    echo "Expected Value: Events that modify the sudo log file should be collected."\n    echo "Recommendation: Add rule to collect sudo log file changes."\n    echo "Remediation:"\n    echo "# To collect sudo log file changes, add the following rule to /etc/audit/rules.d/audit.rules:"\n    echo "# -w /var/log/sudo.log -p wa"\n    echo "# Then restart auditd: sudo systemctl restart auditd"\nfi\n', '#!/bin/bash\n\naudit_status=$(sudo systemctl is-active auditd)\n\nif [[ "$audit_status" == "active" ]]; then\n    echo "Check: Ensure auditing is enabled"\n    echo "Status: Pass"\n    echo "Current Value: Auditing is enabled"\n    echo "Recommendation: No action needed"\nelse\n    echo "Check: Ensure auditing is enabled"\n    echo "Status: Fail"\n    echo "Current Value: Auditing is not enabled"\n    echo "Recommendation: Enable auditing"\n    echo "Remediation: sudo systemctl enable auditd && sudo systemctl start auditd"\nfi\n', '#!/bin/bash\n\necho "Check: Ensure events that modify date and time information are collected"\n\n# Check if date and time modification events are being logged\nif grep -q "time" /etc/audit/audit.rules; then\n    echo "Status: Pass"\n    echo "Current Value: Events that modify date and time information are being collected."\n    echo "Expected Value: Events that modify date and time information should be collected."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Status: Fail"\n    echo "Current Value: Events that modify date and time information are not being collected."\n    echo "Expected Value: Events that modify date and time information should be collected."\n    echo "Recommendation: Add rule to collect date/time modification events."\n    echo "Remediation:"\n    echo "# To collect date/time modification events, add the following rule to /etc/audit/rules.d/audit.rules:"\n    echo "# -w /etc/localtime -p wa"\n    echo "# Then restart auditd: sudo systemctl restart auditd"\nfi\n', '#!/bin/bash\n\necho "Check: Ensure events that modify the system\\\'s network environment are collected"\n\n# Check if network environment modification events are being logged\nif grep -q "network" /etc/audit/audit.rules; then\n    echo "Status: Pass"\n    echo "Current Value: Events that modify the system\\\'s network environment are being collected."\n    echo "Expected Value: Events that modify the system\\\'s network environment should be collected."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Status: Fail"\n    echo "Current Value: Events that modify the system\\\'s network environment are not being collected."\n    echo "Expected Value: Events that modify the system\\\'s network environment should be collected."\n    echo "Recommendation: Add rule to collect network modification events."\n    echo "Remediation:"\n    echo "# To collect network modification events, add the following rule to /etc/audit/rules.d/audit.rules:"\n    echo "# -w /etc/network/interfaces -p wa"\n    echo "# Then restart auditd: sudo systemctl restart auditd"\nfi\n', '#!/bin/bash\n\necho "Check: Ensure use of privileged commands are collected"\n\n# Check if privileged command usage is being logged\nif grep -q "privileged commands" /etc/audit/audit.rules; then\n    echo "Status: Pass"\n    echo "Current Value: Use of privileged commands is being collected."\n    echo "Expected Value: Use of privileged commands should be collected."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Status: Fail"\n    echo "Current Value: Use of privileged commands is not being collected."\n    echo "Expected Value: Use of privileged commands should be collected."\n    echo "Recommendation: Add rule to collect use of privileged commands."\n    echo "Remediation:"\n    echo "# To collect use of privileged commands, add the following rule to /etc/audit/rules.d/audit.rules:"\n    echo "# -w /usr/bin/sudo -p x"\n    echo "# Then restart auditd: sudo systemctl restart auditd"\nfi\n', '#!/bin/bash\n\necho "Check: Ensure unsuccessful file access attempts are collected"\n\n# Check if unsuccessful file access attempts are being logged\nif grep -q "failed" /etc/audit/audit.rules; then\n    echo "Status: Pass"\n    echo "Current Value: Unsuccessful file access attempts are being collected."\n    echo "Expected Value: Unsuccessful file access attempts should be collected."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Status: Fail"\n    echo "Current Value: Unsuccessful file access attempts are not being collected."\n    echo "Expected Value: Unsuccessful file access attempts should be collected."\n    echo "Recommendation: Add rule to collect unsuccessful file access attempts."\n    echo "Remediation:"\n    echo "# To collect unsuccessful file access attempts, add the following rule to /etc/audit/rules.d/audit.rules:"\n    echo "# -w /etc/passwd -p r"\n    echo "# Then restart auditd: sudo systemctl restart auditd"\nfi\n', '#!/bin/bash\n\necho "Check: Ensure events that modify user/group information are collected"\n\n# Check if user/group modification events are being logged\nif grep -q "user/group" /etc/audit/audit.rules; then\n    echo "Status: Pass"\n    echo "Current Value: Events that modify user/group information are being collected."\n    echo "Expected Value: Events that modify user/group information should be collected."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Status: Fail"\n    echo "Current Value: Events that modify user/group information are not being collected."\n    echo "Expected Value: Events that modify user/group information should be collected."\n    echo "Recommendation: Add rule to collect user/group modification events."\n    echo "Remediation:"\n    echo "# To collect user/group modification events, add the following rule to /etc/audit/rules.d/audit.rules:"\n    echo "# -w /etc/passwd -p wa"\n    echo "# Then restart auditd: sudo systemctl restart auditd"\nfi\n', '#!/bin/bash\n\necho "Check: Ensure discretionary access control permission modification events are collected"\n\n# Check if DAC permission modification events are being logged\nif grep -q "dac" /etc/audit/audit.rules; then\n    echo "Status: Pass"\n    echo "Current Value: DAC permission modification events are being collected."\n    echo "Expected Value: DAC permission modification events should be collected."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Status: Fail"\n    echo "Current Value: DAC permission modification events are not being collected."\n    echo "Expected Value: DAC permission modification events should be collected."\n    echo "Recommendation: Add rule to collect DAC permission modification events."\n    echo "Remediation:"\n    echo "# To collect DAC permission modification events, add the following rule to /etc/audit/rules.d/audit.rules:"\n    echo "# -w /etc/selinux/ -p wa"\n    echo "# Then restart auditd: sudo systemctl restart auditd"\nfi\n', '#!/bin/bash\n\necho "Check: Ensure successful file system mounts are collected"\n\n# Check if file system mount events are being logged\nif grep -q "mount" /etc/audit/audit.rules; then\n    echo "Status: Pass"\n    echo "Current Value: Successful file system mount events are being collected."\n    echo "Expected Value: Successful file system mount events should be collected."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Status: Fail"\n    echo "Current Value: Successful file system mount events are not being collected."\n    echo "Expected Value: Successful file system mount events should be collected."\n    echo "Recommendation: Add rule to collect file system mount events."\n    echo "Remediation:"\n    echo "# To collect file system mount events, add the following rule to /etc/audit/rules.d/audit.rules:"\n    echo "# -w /etc/fstab -p wa"\n    echo "# Then restart auditd: sudo systemctl restart auditd"\nfi\n', '#!/bin/bash\n\necho "Check: Ensure session initiation information is collected"\n\n# Check if session initiation information is being logged\nif grep -q "session" /etc/audit/audit.rules; then\n    echo "Status: Pass"\n    echo "Current Value: Session initiation information is being collected."\n    echo "Expected Value: Session initiation information should be collected."\n    echo "Recommendation: No remediation required."\nelse\n    echo "Status: Fail"\n    echo "Current Value: Session initiation information is not being collected."\n    echo "Expected Value: Session initiation information should be collected."\n    echo "Recommendation: Add rule to collect session initiation information."\n    echo "Remediation:"\n    echo "# To collect session initiation information, add the following rule to /etc/audit/rules.d/audit.rules:"\n    echo "# -w /var/log/auth.log -p wa"\n    echo "# Then restart auditd: sudo systemctl restart auditd"\nfi\n']

def powershell_run_script(command):
    """Runs a PowerShell command and checks its compliance status."""
    script = ['bash','-c', command]
    try:
        result = subprocess.run(
            script,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        # Log output and errors for debugging
        print(f"Command Output: {result.stdout}")
        print(f"Command Error: {result.stderr}")
        
        if result.returncode == 0 and "Pass" in result.stdout:
            return 1  
        else:
            return 0  
    except Exception as e:
        print(f"Error executing command: {e}")
        return None

def run_ubuntu_22_04():
    """Runs compliance checks and generates an audit report."""
    pass_count = 0
    fail_count = 0
    results = {"cis_index": [], "title": [], "status": []}
    
    for i in range(len(cis_index)):
        # Append results incrementally
        results["cis_index"].append(cis_index[i])
        results["title"].append(title[i])
        status = powershell_run_script(code[i])
        results["status"].append("Pass" if status == 1 else "Fail")
        
        if status == 1:
            pass_count += 1
        else:
            fail_count += 1
    
    # Create a DataFrame for the results
    df = pd.DataFrame(data=results)
    filename = os.path.join("./", f"audit_file_{datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}.csv")
    df.to_csv(filename, index=False)
    
    print("Stats:-")
    print("Pass count:", pass_count)
    print("Fail count:", fail_count)
    print(f"Compliance Percentage: {(pass_count / (pass_count + fail_count)) * 100:.2f}%")
    print(f"Audit report saved to {filename}")

run_ubuntu_22_04()
print(len(title),len(cis_index),len(code))